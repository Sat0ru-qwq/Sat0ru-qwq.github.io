<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Sat0ru_G0j0 | むりょうくうきょ</title>

  
  <meta name="author" content="Satoru">
  

  
  <meta name="description" content="不当了 不当高手！">
  

  
  <meta name="keywords" content="Penetration Testing">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="Sat0ru_G0j0"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Sat0ru_G0j0" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Sat0ru_G0j0</a>
    </h1>
    <p class="site-description">むりょうくうきょ</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/archives">文档</a></li>
      
        <li><a href="/categories">分类</a></li>
      
        <li><a href="/tags">标签</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2024/07/17/子域名建站/"><span></span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/07/17/子域名建站/" rel="bookmark">
        <time class="entry-date published" datetime="2024-07-17T01:41:05.356Z">
          2024-07-17
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2024/07/14/手机+charles+burpsuite配合抓包/"><span>WX小程序抓包&amp;游戏封包技术</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/07/14/手机+charles+burpsuite配合抓包/" rel="bookmark">
        <time class="entry-date published" datetime="2024-07-14T06:33:00.000Z">
          2024-07-14
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="微信小程序-公众号抓包的主流方式"><a href="#微信小程序-公众号抓包的主流方式" class="headerlink" title="微信小程序&#x2F;公众号抓包的主流方式"></a>微信小程序&#x2F;公众号抓包的主流方式</h1><p>目前有以下几种：</p>
<p>1、Windows+Burp+Proxifier（配置困难，数据包卡顿)</p>
<p>2、Burp+安卓模拟器（模拟器卡顿）</p>
<p>3、Burp+Charles（本文测试，抓包完整，放包流畅）</p>
<p>一、下载</p>
<h4 id="1、Charles官网下载安装包"><a href="#1、Charles官网下载安装包" class="headerlink" title="1、Charles官网下载安装包"></a>1、Charles官网下载安装包</h4><p><a target="_blank" rel="noopener" href="https://www.charlesproxy.com/download/latest-release/">https://www.charlesproxy.com/download/latest-release/</a></p>
<h4 id="2、Burpsuite下载"><a href="#2、Burpsuite下载" class="headerlink" title="2、Burpsuite下载"></a>2、Burpsuite下载</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://portswigger.net/burp/releases</span><br></pre></td></tr></table></figure>

<h4 id="3、Charles破解"><a href="#3、Charles破解" class="headerlink" title="3、Charles破解"></a>3、Charles破解</h4><p>进入链接，输入任意内容作为用户名，获取注册码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.zzzmode.com/mytools/charles/</span><br></pre></td></tr></table></figure>

<p>打开Charles,打开上方工具栏中Help—Register Charles，输入用户名和激活码</p>
<p>打开Charles,打开上方工具栏中Help—Register Charles，输入用户名和激活码</p>
<h3 id="二、Charles设置"><a href="#二、Charles设置" class="headerlink" title="二、Charles设置"></a>二、Charles设置</h3><h4 id="1、Charles设置代理"><a href="#1、Charles设置代理" class="headerlink" title="1、Charles设置代理"></a>1、Charles设置代理</h4><p>打开工具栏中Proxy-Proxy Settings</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/d8c24248e8ee40169178ecc42a62836f.png" alt="img"></p>
<p>设置为如下格式</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/03f1ce83357c4a478a1c23b3a573ef16.png" alt="img"></p>
<p>然后，抓取包的规则配置（*是代表抓取任意端口和域名，如果只抓取固定的端口or域名可自行设置。）</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/60e3b14ad74f45e2af485fd4a1d13c00.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/f844baa2145b4ce182af424db5651b7b.png" alt="img"></p>
<p>接下来配置Charles代理到burpsuit的规则（我这里偷懒，配置的burp默认的8080端口，为避免端口冲突，可自行想想1-65535之内的端口，与burp协同配置即可）</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/57635112886a4064955e578ed29e42b4.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/ee5d8a67623a4979a5b0bbaf772dde94.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/41cb4950910e481c8ed2b31f31ed58d8.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/4f367272290a44edac26e6f90f6286ea.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/4fb4ca3b468a4e32a82bdf13c28f5091.png" alt="img"></p>
<h4 id="2、关闭对windows端的抓包（每次打开软件都是默认开启的，记得关闭）"><a href="#2、关闭对windows端的抓包（每次打开软件都是默认开启的，记得关闭）" class="headerlink" title="2、关闭对windows端的抓包（每次打开软件都是默认开启的，记得关闭）"></a>2、关闭对windows端的抓包（每次打开软件都是默认开启的，记得关闭）</h4><p>因为主要是联动手机对微信抓包，所以可以关闭windows端的抓包，避免干扰。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/a9aed4740923446fbb449694c92f5a13.png" alt="img"></p>
<h4 id="3、配置PC端证书"><a href="#3、配置PC端证书" class="headerlink" title="3、配置PC端证书"></a>3、配置PC端证书</h4><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/b5ef86e515634c1099c51d03f981eae0.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/c7f39dd9529940e59a8c97313062e2b9.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/e6604a88a8a44b6d9152d69c24520b1e.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/c7750c91696b40e9b555f08b270c0501.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/10cd0da8757444da9fd7ef640f1c2169.png" alt="img"></p>
<p>点击下一步，再点击完成，PC显示导入完成就完成PC端证书配置了。</p>
<h4 id="4-移动端证书配置（我这里使用苹果手机测试）"><a href="#4-移动端证书配置（我这里使用苹果手机测试）" class="headerlink" title="4.移动端证书配置（我这里使用苹果手机测试）"></a>4.移动端证书配置（我这里使用苹果手机测试）</h4><p>在这里出现了两种可能性，依次进行即可：</p>
<h5 id="4-1手机连接电脑热点，并配置端口"><a href="#4-1手机连接电脑热点，并配置端口" class="headerlink" title="4.1手机连接电脑热点，并配置端口"></a>4.1手机连接电脑热点，并配置端口</h5><p>开启电脑热点</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/4c3aea78624043ee81d75414ffa5d693.png" alt="img"></p>
<p>手机连接热点，然后在Charles中进行如下操作：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/506f55c1d8b843bfaf4eff5c4f57a0e1.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/186401f5edfa444fbb4dcea3daf5b8de.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/d754328f2a1f433a84ca9d9fd52be0f2.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/41b6e5105fac43e8a77eaf56d2d422d6.jpeg" alt="img"></p>
<h5 id="4-2证书下载后手机能直接识别"><a href="#4-2证书下载后手机能直接识别" class="headerlink" title="4.2证书下载后手机能直接识别"></a>4.2证书下载后手机能直接识别</h5><p>在手机上使用chrome浏览器访问下面这个网址</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chls.pro/ssl</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/fcdc424fd5874c5d8af17e280e4dbff4.jpeg" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/64dae3270ca34e04adbefe605f610378.jpeg" alt="img"></p>
<p>在手机中的设置路径去设置证书：<strong>设置—&gt;通用—&gt;关于本机—&gt;证书信任设置</strong>中打开对根证书启用完全信任。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/7817da8b93ae48c2b33435669110182e.jpeg" alt="img"></p>
<p>所有的流程配置完成，现在就可以抓包了。</p>
<p>三、抓包<br>上面配置好了以后就可以开始抓包了，以后如果再有小程序、微信抓包需求直接进行以下流程即可。</p>
<p>1.打开Charles.</p>
<p>2.打开burp。on&#x2F;off拦截或者放包。</p>
<p>3.打开电脑热点，手机连接电脑热点。（如果生活中正常使用电脑热点记得把ip代理改回自动）</p>
<p>4.手机访问小程序或者公众号，在Charles和burp都可以看到包。</p>
<h3 id="同样的-我们也可以在模拟器如此部署"><a href="#同样的-我们也可以在模拟器如此部署" class="headerlink" title="同样的　我们也可以在模拟器如此部署"></a>同样的　我们也可以在模拟器如此部署</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43910861/article/details/123851267">burp+逍遥模拟器 app抓包 （导入证书到系统的解决方案）_逍遥导入证书失败-CSDN博客</a></p>
<h1 id="游戏封包技术"><a href="#游戏封包技术" class="headerlink" title="游戏封包技术"></a>游戏封包技术</h1><p>第一步：下载所需要的环境</p>
<p>雷电模拟器</p>
<p>雷电安卓模拟器-手游模拟器安卓版_android手机模拟器电脑版_雷电模拟器官网</p>
<p>ProxyDroid</p>
<p>链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1F8Yv9aDZuoN3yUgDCOVRBQ">https://pan.baidu.com/s/1F8Yv9aDZuoN3yUgDCOVRBQ</a>     提取码：s4ds </p>
<p>CCProxy+WPE</p>
<p>链接: <a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1HxVDuglgsEzXKsDZrSXS1Q">https://pan.baidu.com/s/1HxVDuglgsEzXKsDZrSXS1Q</a> 提取码: jti8 </p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/20210704231129143.png" alt="img"></p>
<p>第二步：代理环境的配置</p>
<p>首先adb 命令查看自己的ip 在终端输入    ipconfig ,就可以查看到自己的ip, 我这里连接的是wifi,</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/20210605222428167.png" alt="img"></p>
<p>在雷电模拟器上打开安装好的  ProxyDroid.apk  ，将自己的电脑的 ip  填写在 HOST 里面，端口自己设置，不要超过 65535  ，</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/fde7482c47e14fecaf60d1662b38aa16.png" alt="img"></p>
<p> 设置好 之后  再将上面 这个开关打开</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/2ecd9200873346db9206fdb169b8981b.png" alt="img"></p>
<p>然后 在pc 端打开 CCProxy, 打开设置，端口  是 上面 app  里面填写的端口，IP 和代理app 的保持一直 都是自己电脑上的ip 。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/20210605222522362.png" alt="img"></p>
<p>在点击下面的   高级   ，把ip改成和自己电脑的一至，再点击确定。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/20210605222527721.png" alt="img"></p>
<p>ccproxy 还要开启账户里面的允许所有。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/20210704230543369.png" alt="img"></p>
<p>我们再打开模拟器上的游戏，看到ccp 中有这样一条线，就能看到代理成功。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/20210605222548577.png" alt="img"></p>
<p>接下来我们就打开 ，WPE , 在目标程序中找到ccp 的进程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/20210605222608143.png" alt="img"></p>
<p>在视图里面可以设置 拦截发送的数据包，还是接受到的数据包，我这里只拦截发送的数据包。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/2021060522262510.png" alt="img"></p>
<p>设置好之后，我们进入游戏，找到游戏的中角色的升级，我们打开wpe, 点击 黑色的运行按钮，我们就能看到扇形的数据包中开始变化，点击一次升级，我们就暂停拦截，我们就取分析，拦截到的数据包，在如下的列表中我们可以很快浏览一下，我们 找到规律了，  </p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/20210605222656425.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/20210605222711573.png" alt="img"></p>
<p>总结： 我们设置的ip: 172.20.4.153  我们现在就查看，只要来源和目标 ip 都是一样的。这就说明是本地和本地的发送，我们就将这些直接过滤掉， 我们剩下的也不多，就一个一个的试试，</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/source/categories/Penetration-Testing-Basic/">Penetration Testing Basic</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/source/tags/pr0gram/">pr0gram</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2024/07/11/从0开始的渗透/"><span>从0开始的渗透Day1-3desu</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/07/11/从0开始的渗透/" rel="bookmark">
        <time class="entry-date published" datetime="2024-07-11T06:33:00.000Z">
          2024-07-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="Day1-基础入门-操作系统-名词-文件下载-反弹shell-防火墙绕过"><a href="#Day1-基础入门-操作系统-名词-文件下载-反弹shell-防火墙绕过" class="headerlink" title="Day1:基础入门-操作系统&amp;名词&amp;文件下载&amp;反弹shell&amp;防火墙绕过"></a>Day1:基础入门-操作系统&amp;名词&amp;文件下载&amp;反弹shell&amp;防火墙绕过</h1><h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sunny11/p/13583083.html">https://www.cnblogs.com/sunny11/p/13583083.html</a></p>
<h1 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h1><p><a target="_blank" rel="noopener" href="https://forum.ywhack.com/bountytips.php?download">https://forum.ywhack.com/bountytips.php?download</a></p>
<p><strong>在渗透的过程中，如果我们要在对方的服务里面下载我们制作好的病毒文件等，是不可能通过打开对方的浏览器进而进行下载的，因此弹出shell后我们也要掌握一些基本的文件下载命令，并且自己搭建一个小型的渗透站点用于传输一些安全脚本或者安全文件作为攻击手段。</strong></p>
<h1 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h1><p>反弹shell主要用于<strong>命令发送后无回显的情况</strong>，<strong>大部分 的安全工具都是一条命令发送过后便了无音讯</strong>，服务器接收了但并没有给我们对应的反馈，这个时候就需要反弹shell。</p>
<p>同时反弹shell能够解决一些需要交互式问答的命令的执行问题，一般情况下<strong>webshell是无法进一步验证我们的命令的</strong>，如果我们需要进行一些高权限的操作，这时服务器要求我们验证root权限，即使我们有root密码也是无济于事的，<strong>因为交互式命令的进一步交互并没有反馈到所谓的webshell这里</strong>，这个时候就更需要反弹shell了</p>
<h1 id="防火墙绕过"><a href="#防火墙绕过" class="headerlink" title="防火墙绕过"></a>防火墙绕过</h1><p>案例</p>
<h2 id="1-内网："><a href="#1-内网：" class="headerlink" title="1.内网："></a>1.内网：</h2><p>内网**–&gt;**xzb666-hub</p>
<p>xzb666-hub**!–&gt;**内网</p>
<p>这里的xzb666-hub可以代指类似本博客这样部署在公网上的站点</p>
<p>这块的监听可以用nc做实验，分别以xzb666-hub为代表的公网以及以虚拟机为代表的内网作为被监听端和监听端</p>
<p>发现此时监听成立，能够弹shell</p>
<p>但反过来，以xzb666-hubd为代表的公网想要监听内网是不成立的</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/008jCdW0gy1hriyt8rqkwj30xd0xinbv.jpg" alt="img"></p>
<p>那么这就是一个很生草的问题了</p>
<p>下面我们来解释下这个问题</p>
<p>内网能够主动找到外网地址，但外网地址想要找内网地址却很难，下面扒取一段解释，可以作为参考</p>
<ol>
<li><p><strong>内网可以直接访问外网么？</strong></p>
<p>答案是<code>不能</code>，内网IP访问外网必须要通过路由器来中转 ，路由器只有连上了电信服务器，分配有外网IP才能访问外网。但内网通过路由器的中继是可以精准找到外网的。</p>
</li>
<li><p><strong>外网能否访问内网？</strong></p>
<p>答案是外网设备不能直接访问内网设备。这是因为内网（局域网）和外网（广域网）之间存在一个隔离层，通常由路由器或防火墙来维持。这种隔离是为了保护内网设备不受外部攻击和未经授权的访问</p>
<p>————————————————————————————————————</p>
<ol>
<li><strong>NAT（网络地址转换）</strong>：路由器通常使用NAT技术，将内网IP地址转换为外网IP地址。外部设备无法直接访问内网IP，因为这些IP在外网中是不可见的。</li>
<li><strong>防火墙</strong>：路由器或专用防火墙通常会阻止外部未授权的访问请求进入内网，以保护内网设备的安全。</li>
</ol>
<p>尽管如此，外网访问内网设备并非完全不可能。通过配置端口转发（Port Forwarding）或使用VPN（虚拟专用网络），你可以允许外部设备访问特定的内网设备或服务。不过，这些配置需要手动设置，并且通常仅用于特定用途，例如远程桌面访问或托管网络服务。</p>
<p>————————————————————————————————————</p>
<p><strong>如何解决外网无法访问内网的问题？</strong></p>
<p>端口映射</p>
<p>这个又叫虚拟映射，这个方法就是在连接外网的路由器上做一个端口映射的设置，具体说将访问该路由器外网地址和特定端口的服务映射到内网的一台电脑的某一个端口上。</p>
<p><strong>其实是很通俗易懂的,外网访问的过程中将流量转发到路由器上，（也就是我们百度直接搜ip时会弹出的ip–称为出口ip），然后我们选择一个端口。使这个端口又映射到内网主机的某个端口上实现流量从外网到内网主机的精准转发desu喵</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/008jCdW0gy1hfdyq4d43tj30u00u0q74.jpg" alt="img"></p>
<p>具体上面来说，<strong>就是在光猫+路由器上做一个虚拟映射的设置，例如，将访问122.15.244.39，端口10101的访问映射到192.168.2.2的端口10101上。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240711112852515.png" alt="image-20240711112852515"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240711112917706.png" alt="image-20240711112917706"></p>
<p>设置完成后，在外网浏览器输入：122.15.244.39:10101，则可以直接访问到服务器。<br>需要注意的是：<br>(1)<strong>公网映射时，选择的外部端口最好不选择常用的80，21等，因为路由器会屏蔽这些！！！</strong><br>(2) 服务器需要连接到包含公网IP的服务器上！</p>
<p><strong>如何获得公网IP</strong><br>实际当中，你的光猫+路由器的那个IP地址（可以在登录路由器界面后看到）不一定是公网IP，如果不是，则以上无法完成。因为IP地址很有限，所以很多运营商给你的是私网IP。例如，你看到你的那个地址是通过PPOE得来的，就是私有的。可以参见这里<a target="_blank" rel="noopener" href="https://blog.csdn.net/hongkaihua1987/article/details/106046819%E3%80%82%E8%A6%81%E8%8E%B7%E5%BE%97%E5%85%AC%E7%BD%91IP%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%89%BE%E8%BF%90%E8%90%A5%E5%95%86%EF%BC%8C%E8%A6%81%E6%B1%82%E7%BB%99%E5%85%AC%E7%BD%91IP%EF%BC%8C%E4%BB%96%E4%BB%AC%E4%BC%9A%E5%9C%A8%E5%90%8E%E5%8F%B0%E8%AE%BE%E7%BD%AE%EF%BC%8C%E8%AE%BE%E7%BD%AE%E5%AE%8C%E5%90%8E%E5%B0%B1%E6%98%AF%E5%85%AC%E7%BD%91%E7%9A%84%E4%BA%86%E3%80%82">https://blog.csdn.net/hongkaihua1987/article/details/106046819。要获得公网IP，可以找运营商，要求给公网IP，他们会在后台设置，设置完后就是公网的了。</a></p>
<p>**</p>
<p><strong>公网IP是动态的怎么办</strong><br>你的公网IP有了，但是他通常是动态的（登录路由器，如果是DHCP获得的，就是动态的）。所谓动态就是分给你的是变化的，当你路由器重新加电或复位后就会重新分配一个。这就有点傻了，总不能每次去查路由器吧。这里有两个办法：</p>
<p><strong>申请固定IP</strong><br>（1）找运营商，申请一个固定的公网IP。但是有个前提，运营商只对公司分配固定IP，对个人用户是不可以的。同时公司用户必须申请公司宽带，不能是个人宽带。公司宽带的资费要比个人的贵一些。同时，如果想要申请固定IP，还需要额外收一笔费用，按月计费。</p>
<p>转载自<a target="_blank" rel="noopener" href="https://blog.csdn.net/kevinshift/article/details/122148573#31__25">从外网访问局域网服务器的六种方法_内部服务如何才能外部访问-CSDN博客</a></p>
<p>————————————————————————————————————</p>
</li>
<li><p><strong>路由器的作用是什么，什么是路由？</strong></p>
<p>比如说我们手机要访问<a href="https://link.zhihu.com/?target=http://baidu.com">http://baidu.com</a> ，必须先经过路由中转然后路由外网IP对<a href="https://link.zhihu.com/?target=http://baidu.com">http://baidu.com</a> 发送请求，百度收到后对路由响应一个网页或者 数据之类的东东。</p>
<p>路由器接收到 <a href="https://link.zhihu.com/?target=http://baidu.com">http://baidu.com</a> 的页面后，把页面发送给你的电脑或手机。路由器知道如何给这些信息指路，路由器就是一个指路人，这就是「路由」两个字的来历。</p>
<p>路，就是「必由之路」中的路。由，就是「必由之路」中的由（由是经过、缘由的意思）。所有的信息都要经过路由器，然后被指向一条它该去的路。<br>也就是说内网和外网就像两个隔绝的空间，无法互通，唯一的联通点就是路由器（因为路由器既有外网 IP 也有内网 IP），所以路由器有时候也被叫做「网关」，这个「关」是「一夫当关，万夫莫开」的「关」。如果路由器到电信的连接中断了，那么内网中所有的设备也就无法上网了。（这很好理解，相当于唯一一条出去的路断了）</p>
</li>
<li><p><strong>内网能访问内网么？</strong></p>
<p>内网中的设备可以互相访问（比如你可以用电脑或手机进入 <a href="https://link.zhihu.com/?target=http://192.168.1.1">http://192.168.1.1</a> 来查看你的路由器），但是不能直接访问外网，内网设备想要访问外网，就必须经过路由器中转。</p>
</li>
<li><p><strong>外网能访问外网么？</strong></p>
<p>外网中的设备可以互相访问（比如 <a href="https://link.zhihu.com/?target=http://qq.com">http://qq.com</a> 可以把首页发送给你的路由器，你的路由器有外网 IP），但是外网中的设备无法访问你的内网设备（这很好理解，内网是一个封闭的网络，外人进不来，所以实际上 <a href="https://link.zhihu.com/?target=http://qq.com">http://qq.com</a> 无法直接把首页放送给你的电脑和手机</p>
<p><strong>来源于<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/34521011">HTTP访问要素：IP 与 端口 - 知乎 (zhihu.com)</a></strong></p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240711110331630.png" alt="image-20240711110331630"></p>
<h2 id="2-防火墙："><a href="#2-防火墙：" class="headerlink" title="2.防火墙："></a>2.防火墙：</h2><p>xzb666-hub <strong>&lt;–&gt;</strong> aliyun</p>
<p>xzb666-hub防火墙 <strong>–&gt;</strong> aliyun</p>
<p>aliyun <strong>!- &gt;</strong> xzb666防火墙</p>
<p><strong>这里准备两台外网主机，查看两台主机之间是否能够正常通讯</strong> </p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240711145047314.png" alt="image-20240711145047314"></p>
<p>也就是像现在这样，<strong>两台服务器之间通过nc建立了反弹shell的基本操作</strong></p>
<p>然后可以发现二者都可以充当监听端，被监听端.</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240711151136536.png" alt="image-20240711151136536"></p>
<p><strong>当防火墙开启时，发现连接超时，说明入站的数据被严格过滤了，也就是说经过这一层防火墙的拦截，服务端哪怕成功被我们建立起监听也无法接收对应的弹shell等操作，也就是说吗，这里我们想要把cmd.exe弹过去想经过防火墙这一层简直是天方夜谭</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/008jCdW0gy1hriyt8rqkwj30xd0xinbv.jpg" alt="img"></p>
<p>这也是个很生草的问题，因此我们开始用防火墙开发者的角度思考问题，便出现了一个奇妙的思路</p>
<p><strong>防火墙绕过-正向链接&amp;反向连接&amp;内网服务器</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240711150850670.png" alt="image-20240711150850670"></p>
<p>防火墙有个特性，对入站的数据很严格，对出站的数据便放的很松，这类似于SQL注入中的一个分类，就是SQL二次注入的原理desu喵，<strong>假如我们通过服务端这里作为发出cmd.exe的对象，这时由于部署防火墙的服务端对出站的数据过滤的不是很严格，</strong>，因此shell成功被另一台外网主机所接收，这样的绕过也就可以实现了喵!!!</p>
<p><strong>所以以后碰上防火墙的部署的话，尽量让它出来找你而不是让你出来找它，让它主动把数据给你而不是你找它讨！这样卑微desu！</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/008jCdW0gy1hfdyq4d43tj30u00u0q74.jpg" alt="img"></p>
<h2 id="有手就行的实战desu"><a href="#有手就行的实战desu" class="headerlink" title="有手就行的实战desu"></a>有手就行的实战desu</h2><p>这里用fofa搜索对应的pikachu靶场，来打打同行（doge）</p>
<p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQozfTZKNXRTR0quy3Ca3nmSgkKsfM76uQn_g&s" alt="永雏塔菲手机壁纸- 抖音"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240711153357307.png" alt="image-20240711153357307"></p>
<p>然后这里打到了某个ip，发现功能齐全（阴险desu  打算开始做进一步入侵</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240711153516754.png" alt="image-20240711153516754"></p>
<p>–后续不具体做展示desu</p>
<p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQozfTZKNXRTR0quy3Ca3nmSgkKsfM76uQn_g&s" alt="永雏塔菲手机壁纸- 抖音"></p>
<h1 id="Day2-Web应用-架构搭建-漏洞-HTTP数据包-代理服务器"><a href="#Day2-Web应用-架构搭建-漏洞-HTTP数据包-代理服务器" class="headerlink" title="Day2:Web应用-架构搭建-漏洞-HTTP数据包-代理服务器"></a>Day2:Web应用-架构搭建-漏洞-HTTP数据包-代理服务器</h1><h1 id="网站搭建前置知识"><a href="#网站搭建前置知识" class="headerlink" title="网站搭建前置知识"></a>网站搭建前置知识</h1><p>#域名，子域名，DNS，HTTP&#x2F;HTTPS，证书等</p>
<p>第一步：准备域名，可以通过阿里云购买，服务器同理</p>
<p>PS：倘若域名没有经过备案，那么这个域名在运营过程中只能对大陆以外的服务器进行解析，这个时候服务器可以选择香港、新加坡等离国内较近的服务器desu，（备案是需要很长时间的，如果比较急的话就没必要）</p>
<p>第二步：将服务器基本配置配好过后，对域名进行解析，并利用阿里云自带的管理系统开始搭建网站</p>
<p>第三步：这个时候小白可以通过宝塔平台一键搭建网站</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240712161427668.png" alt="image-20240712161427668"></p>
<h2 id="一些进阶的参考资料"><a href="#一些进阶的参考资料" class="headerlink" title="一些进阶的参考资料"></a>一些进阶的参考资料</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhyl8157121/article/details/100551592">如何给你的网站套上Cloudflare（以阿里云为例）_如何套用cloudlfare-CSDN博客</a></p>
<h1 id="Web应用环境的架构"><a href="#Web应用环境的架构" class="headerlink" title="Web应用环境的架构"></a>Web应用环境的架构</h1><p>理解不同WEB应用组成角色功能架：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240712094332684.png" alt="image-20240712094332684"></p>
<p>不同的架构自然可能出现的安全漏洞不同</p>
<h1 id="Web安全漏洞分类"><a href="#Web安全漏洞分类" class="headerlink" title="Web安全漏洞分类"></a>Web安全漏洞分类</h1><p>这里不过多赘述</p>
<p>但需要明白一个原理</p>
<p>如图的这些漏洞都是代码实现功能过程中代码不够完善从而出现的</p>
<h1 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240712094451574.png" alt="image-20240712094451574"></h1><p>同时，根据上述架构的分类：从语言上，中间件层面上，服务器操作系统等不同层面上都会出现一些安全问题。</p>
<h1 id="HTTP数据包和代理"><a href="#HTTP数据包和代理" class="headerlink" title="HTTP数据包和代理"></a>HTTP数据包和代理</h1><p>图示是一个最基本的请求图示</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240712095029242.png" alt="image-20240712095029242"></p>
<p>加入所谓的代理拦截后</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240712095104496.png" alt="image-20240712095104496"></p>
<p>浏览器先传入代理，代理再传入服务器，对应的返回的过程也需要经过代理的中转。 </p>
<h2 id="案例–pax学长的评论区desu！！"><a href="#案例–pax学长的评论区desu！！" class="headerlink" title="案例–pax学长的评论区desu！！"></a>案例–pax学长的评论区desu！！</h2><p><strong>比方说我们对某个网站点赞</strong></p>
<p>这里找到了pax学长的博客，随便点开一篇博文，发现其评论区功能正常运营，并且有点赞功能。Satoru打算套上Sherlock的马甲干点坏事情，发现Pax所用的butterfly框架甚至连头像都自动爬取上传好了（替你造马甲的框架，他真的，我哭死） 接下来准备进行对评论刷赞，看看是否成立</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240712100613082.png" alt="image-20240712100613082"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240712110446321.png" alt="image-20240712110446321"></p>
<p>这里对点赞请求进行抓包，本想通过User-Agent在不同的浏览器中对同一个id点赞，但发现由于token机制，以作者当前的水平想实现python脚本自动化抓取token是很困难的，因此转换另一个思路，抓取评论时的请求，通过Burp Intruder不断构造新的评论，开始炸库。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240712111235234.png" alt="image-20240712111235234"></p>
<p>不断构造评论显然是可以实现的，毕竟是评论区自带的功能，不过利用这点依然是可以搞一些事情的</p>
<p>首先这个评论区功能是支持上传文件的，如果我上传一系列图片进去，是否有可能拖垮pax博客的负载？</p>
<p>同时这个马甲是支持信息伪造的，假设我传入一些有害网站作为个人马甲，这是否又是一层攻击？</p>
<p>再不济，我挂着Burp Intruder模块批量发包，积少成多的同时并且在pax的所有文章下发送一些无用信息，这只是拖累负载而已，但假设我传入的是有害的信息呢？这也是需要考虑的</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240712111940495.png" alt="image-20240712111940495"></p>
<h1 id="Day3-基础入门-抓包-封包-APP-小程序-PC应用-Web应用"><a href="#Day3-基础入门-抓包-封包-APP-小程序-PC应用-Web应用" class="headerlink" title="Day3:基础入门-抓包&amp;封包&amp;APP&amp;小程序&amp;PC应用&amp;Web应用"></a>Day3:基础入门-抓包&amp;封包&amp;APP&amp;小程序&amp;PC应用&amp;Web应用</h1><h1 id="学会对不同对象采用不同抓包封包抓取"><a href="#学会对不同对象采用不同抓包封包抓取" class="headerlink" title="学会对不同对象采用不同抓包封包抓取"></a>学会对不同对象采用不同抓包封包抓取</h1><p>什么是抓包：</p>
<p>抓包就是抓取相关应用的一些数据，如果我们进行安全测试的话，有些应用的目标是会直接给到你的，但有些目标却是未知的</p>
<p>对于这些看不见的目标，我们可以通过抓取数据包来解决。</p>
<p>很经典的web流程，在任意一个浏览器通过F12打开网络（或者叫做networkl）</p>
<p>这个时候浏览器会起一个监听的进程，用于抓取基本的数据包</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240714153412205.png" alt="image-20240714153412205"></p>
<p>这就是很经典的一个单纯抓包，并没有对数据包做任何的额外操作。</p>
<p>同时对应的它也会展示一些加载的资源，比如前端展示的js或css等</p>
<p>还有一种可能，数据包是会被封装在微信小程序，app或者一些电脑的应用中，这个时候就需要一些专门的工具用于模拟对应的环境</p>
<h1 id="抓包应用对象"><a href="#抓包应用对象" class="headerlink" title="抓包应用对象"></a>抓包应用对象</h1><h2 id="WEB应用站点（网站）"><a href="#WEB应用站点（网站）" class="headerlink" title="WEB应用站点（网站）"></a>WEB应用站点（网站）</h2><p>浏览器审查查看元素网络监听</p>
<h2 id="APP-小程序-PC抓包-HTTP-S数据-—Burpsuite-Charles-Fiddler"><a href="#APP-小程序-PC抓包-HTTP-S数据-—Burpsuite-Charles-Fiddler" class="headerlink" title="APP&amp;小程序&amp;PC抓包-HTTP&#x2F;S数据  —Burpsuite&amp;Charles&amp;Fiddler"></a>APP&amp;小程序&amp;PC抓包-HTTP&#x2F;S数据  —Burpsuite&amp;Charles&amp;Fiddler</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">环境配置</span><br><span class="line">1、安卓模拟器安装搭建：</span><br><span class="line">雷电、逍遥、夜神等自行安装</span><br><span class="line">2、工具相关证书安装</span><br><span class="line">Burpsuite&amp;Charles&amp;Fiddler</span><br><span class="line">这三样工具看自己使用的是哪一样，对应的看工具官方手册或一些教程即可安装对应的证书</span><br><span class="line">3.封包抓取</span><br></pre></td></tr></table></figure>

<p>对应的记得安装证书，修改模拟器代理即可</p>
<p>在这里个人建议使用Charles配合Burpsuite，对小程序和app等进行抓包也可以直接配合手机使用，这里也有配套的教程.</p>
<h2 id="程序进程-网络接口-其他协议抓包-–-Wireshark-科来网络分析系统"><a href="#程序进程-网络接口-其他协议抓包-–-Wireshark-科来网络分析系统" class="headerlink" title="程序进程&amp;网络接口&amp;其他协议抓包 – Wireshark&amp;科来网络分析系统"></a>程序进程&amp;网络接口&amp;其他协议抓包 – Wireshark&amp;科来网络分析系统</h2><p>当有一些程序走的是非web协议，这个时候burp和charles本质上是派不上用场的，这个时候我们也可以选择使用wireshark抓到类似UDP协议和IDMP协议等。</p>
<h2 id="通讯类应用封包分析发送接收-–WPE四件套封包-科来网络分析系统"><a href="#通讯类应用封包分析发送接收-–WPE四件套封包-科来网络分析系统" class="headerlink" title="通讯类应用封包分析发送接收 –WPE四件套封包&amp;科来网络分析系统"></a>通讯类应用封包分析发送接收 –WPE四件套封包&amp;科来网络分析系统</h2><p>封包和抓包是两个本质不同的概念，对通讯类应用，比如游戏这类实时交互的进程，在不断产生流量交互的应用，使用对应的网络分析系统对本机的流量包进行分析，然后对协议的状态进行对应的观察</p>
<p>比方说<strong>打开模拟器，想要抓取某传奇手游的数据包</strong>。</p>
<p>这个时候利用科来网络分析系统对模拟器网段流量进行分析，可以通过TCP的状态发掘正在运行的进程，通过排除法（在模拟器中开始畅玩游戏（），发现相对较活跃的流量）可以发现当前运行的数据包中哪个是对应游戏的数据包喵</p>
<p><strong>类似这种游戏，一般走的都是TCP协议</strong>，因为HTTP使用请求-响应模型，客户端发送请求，服务器返回响应。因此HTTP模型适合于Web浏览中一次性数据获取的场景却不适用于游戏。</p>
<p>可能这个时候就会有人问了：SatoruSatoru，<strong>这哪里是Web渗透啊？分明就是抓包而已，这能有啥？</strong></p>
<p>Satoru这个时候就会说了：<strong>抓个包其实是很简单的事，但是拿到真实IP开始扫描资产，看看端口上其他的服务这种操作就要考虑的很多了（套用公式就是快）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240714210927280.png" alt="image-20240714210927280"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240714210940142.png" alt="image-20240714210940142"></p>
<h2 id="真正意义上的封包技术"><a href="#真正意义上的封包技术" class="headerlink" title="真正意义上的封包技术"></a>真正意义上的封包技术</h2><p>详解wpe封包：</p>
<p>WPE是一个强大的网络封包编辑器，它可以截取网络上的信息，修改封包的数据，一般在安全测试中可以用来调试数据通讯的地址</p>
<p>封包指将网络传输过程中封片传输的数据，比方说一个游戏中，回城由十个数据包组成，那么WPE对我们发送的数据包进行整合封装，将分片传输的数据重新整合成一套数据包，然后重新发送，达到在游戏外实现功能的效果</p>
<h3 id="封包概念解释"><a href="#封包概念解释" class="headerlink" title="封包概念解释"></a>封包概念解释</h3><p><strong>封包（Packet）</strong> 是指在网络通信中，数据被分割成小块并通过网络传输的基本单位。每个封包通常包括头部（Header）和数据（Data）部分：</p>
<ul>
<li><strong>头部</strong>：包含控制信息，例如源地址、目的地址、序列号、协议信息等。</li>
<li><strong>数据</strong>：实际传输的数据内容。</li>
</ul>
<p>封包在网络中传输时，通过路由器和交换机等设备进行传递，最终到达目的地。封包技术是网络通信的基础，通过将大块数据分割成小块，可以实现高效和可靠的传输。</p>
<h3 id="封包编辑（Packet-Editing）"><a href="#封包编辑（Packet-Editing）" class="headerlink" title="封包编辑（Packet Editing）"></a>封包编辑（Packet Editing）</h3><p>封包编辑指的是捕获、分析、修改和重放网络封包的过程。这通常用于网络调试、性能测试、漏洞利用等场景。WPE（Winsock Packet Editor）是常用的封包编辑工具之一。</p>
<h3 id="WPE（Winsock-Packet-Editor）封包编辑技术"><a href="#WPE（Winsock-Packet-Editor）封包编辑技术" class="headerlink" title="WPE（Winsock Packet Editor）封包编辑技术"></a>WPE（Winsock Packet Editor）封包编辑技术</h3><p>WPE Pro 是一种流行的网络封包编辑工具，用于捕获和修改通过 Windows 网络堆栈传输的数据包。以下是使用 WPE 进行封包编辑的步骤：</p>
<h4 id="1-下载并安装-WPE-Pro"><a href="#1-下载并安装-WPE-Pro" class="headerlink" title="1.下载并安装 WPE Pro"></a>1.下载并安装 WPE Pro</h4><p>首先，从可信的来源下载并安装 WPE Pro。</p>
<h4 id="2-打开目标程序"><a href="#2-打开目标程序" class="headerlink" title="2. 打开目标程序"></a>2. 打开目标程序</h4><p>启动你想要捕获和编辑封包的应用程序。例如，一个网络游戏或聊天程序。</p>
<h4 id="3-启动-WPE-Pro"><a href="#3-启动-WPE-Pro" class="headerlink" title="3. 启动 WPE Pro"></a>3. 启动 WPE Pro</h4><p>启动 WPE Pro，并在工具界面中选择“Target Program”按钮，选择你要监控的目标程序。</p>
<h4 id="4-捕获封包"><a href="#4-捕获封包" class="headerlink" title="4. 捕获封包"></a>4. 捕获封包</h4><p>在 WPE Pro 中，点击“Play”按钮开始捕获封包。然后在目标程序中执行一些操作（如发送消息、移动角色等）。</p>
<h4 id="5-停止捕获并分析封包"><a href="#5-停止捕获并分析封包" class="headerlink" title="5. 停止捕获并分析封包"></a>5. 停止捕获并分析封包</h4><p>完成操作后，点击“Stop”按钮停止捕获。你将看到捕获到的封包列表。</p>
<h4 id="6-修改封包"><a href="#6-修改封包" class="headerlink" title="6. 修改封包"></a>6. 修改封包</h4><p>选中你想要修改的封包，右键选择“Send”或“Send to Send List”。在“Send List”中，你可以编辑封包的数据内容。修改完成后，点击“Send”按钮发送修改后的封包。</p>
<h4 id="示例步骤："><a href="#示例步骤：" class="headerlink" title="示例步骤："></a>示例步骤：</h4><p>假设你在一个在线游戏中想要修改发送的聊天消息：</p>
<ol>
<li>在游戏中发送一条消息（如“Hello”）。</li>
<li>在 WPE Pro 中捕获到相应的封包。</li>
<li>找到包含“Hello”消息的封包，右键选择“Send”或“Send to Send List”。</li>
<li>在编辑器中将“Hello”修改为其他内容（如“Hi there”）。</li>
<li>点击“Send”按钮发送修改后的封包，观察游戏中的变化。</li>
</ol>
<p>也可以封装一个回城功能（doge）,然后通过发送整合后的数据包就可以实现游戏外回城的功能（doge）</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240714213902020.png" alt="image-20240714213902020"></p>
<p>所以封包和wireshark监听查找进程的本质区别在于封包是一组整合的数据包，wireshark查找进程是一堆零散的数据包</p>
<p>步骤：</p>
<p>1.首先在模拟器中先装上代理机器人</p>
<p>2.对应的打开ccproxy设置代理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">四件套示意图</span><br><span class="line">apk --&gt; ccproxy  --&gt;wpe监听cc进程，实现封包抓包</span><br><span class="line"></span><br><span class="line">burp charles</span><br><span class="line">模拟器设置证书后，设置代理，运行工具的本机IP 端口</span><br><span class="line">burpsuite茶杯 配置代理 监听抓取</span><br><span class="line"></span><br><span class="line">wireshark 科来  不需要设置任何东西</span><br><span class="line">只是监听全频段网络接口</span><br></pre></td></tr></table></figure>

<p>这里也可以用<strong>下雪的傻瓜式封包监听工具</strong>，不过现在一般模拟器都已经上了一层防护了，不会轻易的让你使用模拟器对应的进程名，所以这个时候更新工具版本或者选择一些老版本模拟器（）说不定有奇效</p>
<p>当然这是因为WPE工具已经太老了，基本的原理连逍遥安卓论坛都能讲明白，加上一层比较基本的防护器就可以防御住了，这后面再细说</p>
<p>雷电模拟器的进程一般是这个</p>
<p>X64进程名|Ld9BoxHeadless.exe|PID|30320</p>
<p>但是进程ID可能会实时改变（？）</p>
<p>在我封包成功一次过后雷电模拟器好像把PID给换了，细思极恐</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240715145004014.png" alt="image-20240715145004014"></p>
<h1 id="抓包应用协议"><a href="#抓包应用协议" class="headerlink" title="抓包应用协议"></a>抓包应用协议</h1><p>分为Web协议和非Web协议</p>
<h1 id="抓包应用意义"><a href="#抓包应用意义" class="headerlink" title="抓包应用意义"></a>抓包应用意义</h1><p>把app中的一些数据或者一些信息提取出来，就是这么简单，然后将这些信息用于对应的安全攻防。</p>
<h1 id="封包应用意义"><a href="#封包应用意义" class="headerlink" title="封包应用意义"></a>封包应用意义</h1><p><strong>WPE四件套封包&amp;科来网络分析系统  Wireshark</strong></p>
<p><strong>Burpsuite&amp;Charles&amp;Fiddler</strong></p>
<h2 id="傻瓜式封包流程"><a href="#傻瓜式封包流程" class="headerlink" title="傻瓜式封包流程"></a>傻瓜式封包流程</h2><p>封包工具可以将类似于游戏这种实时交互的网站做完整的监听而非拦截</p>
<h3 id="进程获取"><a href="#进程获取" class="headerlink" title="进程获取"></a>进程获取</h3><p>没有发现模拟器对应的进程，那么封包也是天方夜谭</p>
<p>首先通过Wireshark或者科来网络分析系统监听本机进程，并在游戏中多进行释放技能，领取奖励等数据包交互很多的操作，可以发现对应的字节波动大的进程，通过进程名推敲一下看看是否就是这个模拟器的进程。</p>
<h3 id="最后封包"><a href="#最后封包" class="headerlink" title="最后封包"></a>最后封包</h3><p>后续直接用封包工具对模拟器起一个监听，然后打开监听，在游戏内进行想要封包的操作（例如回城等），点击回城后关闭监听开始测试抓取到的数据包，如果选中的数据包发送后能够成功实现该功能，则说明封包成功（虽然Burpsuite其实也能做到直接监听对应模拟器配置的虚拟网卡）</p>
<h2 id="进阶封包流程"><a href="#进阶封包流程" class="headerlink" title="进阶封包流程"></a>进阶封包流程</h2><p>进阶的封包无非是在模拟器中装入代理机器人，后续代理机器人将抓到的数据包传回到本机的CCproxy（也是工具），CCproxy（也是工具）对应的进程则被WPE所监听，但由于这个流程已经太老了，模拟器以及游戏本身可能都有对应的防护，所以一般傻瓜式封包会比进阶封包更容易抓到包。</p>
<p><strong>后续有条件一定要自己尝试写出来封包监听工具，毕竟公开的工具会被ban，但公开的原理不会，通过进阶封包这里学得原理，自己做个封包监听工具又有何不可呢。</strong></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/source/categories/Penetration-Testing-Basic/">Penetration Testing Basic</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/source/tags/pr0gram/">pr0gram</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2024/07/11/从3开始的渗透/"><span></span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/07/11/从3开始的渗透/" rel="bookmark">
        <time class="entry-date published" datetime="2024-07-11T06:33:00.000Z">
          2024-07-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="Day4-30余种加解密编码进制-Web-数据库-系统-代码-参数值"><a href="#Day4-30余种加解密编码进制-Web-数据库-系统-代码-参数值" class="headerlink" title="Day4:30余种加解密编码进制&amp;Web &amp;数据库&amp;系统&amp;代码&amp;参数值"></a>Day4:30余种加解密编码进制&amp;Web &amp;数据库&amp;系统&amp;代码&amp;参数值</h1><h2 id="加解密编码进制"><a href="#加解密编码进制" class="headerlink" title="加解密编码进制"></a>加解密编码进制</h2><p>识别算法编码类型</p>
<p>1.看密文位数</p>
<p>2.看密文的特征（数字，字符，大小写，符号等）</p>
<p>3.看当前密文存在的地方（Web，数据库，操作系统等应用）</p>
<p>演示案例如下，接下来会从这些方面出发</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240715163704329.png" alt="image-20240715163704329"></p>
<p>详细列举</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240715163856227.png" alt="image-20240715163856227"></p>
<p>对于一些密码算法，类似md5这类不可逆的密码算法</p>
<p>这个时候解密的方式就有：<strong>枚举和碰撞</strong></p>
<p><strong>解密不通过算法解密，而是尝试生成很多的加密或对应明文的字符来枚举</strong></p>
<p>同时加密的应用场景比较多，这里列举出这些</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240715164423363.png" alt="image-20240715164423363"></p>
<p>加密存储相对明文存储而言，不同之处就在于在攻防过程中，如果你的密文设置的足够复杂，其实也可以防止攻击端进一步攻击网络资产。</p>
<p>—-1—</p>
<p>类似于最基本的md5加密，类似个人博客这种最基本的站点，一般会采取md5加密，这个时候假设你进入了数据库，可以直接利用某些线上工具完成解密</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240715170018370.png" alt="10"></p>
<p>—2—</p>
<p>对应了<strong>国外论坛discuz类的站点</strong>采用了md5+salt加密的方式，在本身就用md5加密的条件下还额外加入了“salt“字段，这个时候使加密更加完善，攻击者在未知网站信息或存储机制的情况下难以进一步操作</p>
<p>不过还是有机会通过一些信息的收集得知其加密的机制的</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240715165911780.png" alt="image-20240715165911780"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240715170242476.png" alt="image-20240715170242476"></p>
<p>密算法是不可能第一时间就能知道的，而是要对这个站点采取信息收集，收集过后找到对应的架构是怎么样的**(Web站点之间的不同？还是对应想要查看的是某个操作系统？)**，架构知道了，那么这个加密算法具体怎么实现的也就可以通过网上的信息，甚至是自己搭一个这样的站点，对应这些思路自然也就一通百通。</p>
<p>这里介绍一个工具，mimikatz，它是用于获取windows系统上所有的明文和密钥进行获取。 不过这个不一定有用，因为mimikatz对应在windows2008后版本取消显示明文密码过后，作用并不是那么明显。</p>
<p>不过从这里可以看出，不管是什么样的架构都有迹可循。</p>
<p>这样就能防止我们单纯的拿到明文过后却无计可施。 </p>
<p><strong>不只是有存储类的加密</strong>，<strong>就连代码也会有对应的代码加密</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240715205508717.png" alt="image-20240715205508717"></p>
<p>对应的 数据库也有对应的密文加密方式</p>
<p>以及浏览器也是对应有其加密方式</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240715211129660.png" alt="image-20240715211129660"></p>
<p>这些只要掌握大概，以及懂得工具的使用就可以了</p>
<h1 id="Day5：资产架构-端口-应用-CDN-WAF-站库分离-负载均衡"><a href="#Day5：资产架构-端口-应用-CDN-WAF-站库分离-负载均衡" class="headerlink" title="Day5：资产架构&amp;端口&amp;应用&amp;CDN&amp;WAF&amp;站库分离&amp;负载均衡"></a>Day5：资产架构&amp;端口&amp;应用&amp;CDN&amp;WAF&amp;站库分离&amp;负载均衡</h1><p>本阶段复现可能需要基于<strong>阿里云服务器+完整备案后域名+宝塔面板&#x2F;github上自主部署服务。</strong></p>
<p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQZqNyI04OHsCJqTXg5b9F0RmJpBNvbD9ZF0Q&s" alt="关注永雏塔菲谢谢喵什么梗- 抖音"></p>
<h2 id="资产架构-端口-目录-插件接口-多站点-多应用"><a href="#资产架构-端口-目录-插件接口-多站点-多应用" class="headerlink" title="资产架构-端口&amp;目录&amp;插件接口&amp;多站点&amp;多应用"></a>资产架构-端口&amp;目录&amp;插件接口&amp;多站点&amp;多应用</h2><p> 这里由于Satoru前期部署网站和域名备案等琐事，时间线拉长的让人寒心，只能找Wells要了个子域名，所以这里也懒得用我已经部署好的网站重新演示一遍（主要是完整的站点目录我只拿着一个子域名也很难复现（戳手手））</p>
<p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRHNG07AZ4KHRaS7k_YotkiGRnl7kIwbX9hMQ&s" alt="塔菲盒官方下载-永雏塔菲盒(Taffy盒)下载v1.0 安卓版-100手游网"></p>
<p>这里已经通过域名解析服务器IP，后续宝塔面板一键部署在该域名解析的服务器上实现了建站。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240717095245678.png" alt="image-20240717095245678"></p>
<h2 id="番外安全-域名-服务器本身-服务厂商-管理人员"><a href="#番外安全-域名-服务器本身-服务厂商-管理人员" class="headerlink" title="番外安全-域名&amp;服务器本身&amp;服务厂商&amp;管理人员"></a>番外安全-域名&amp;服务器本身&amp;服务厂商&amp;管理人员</h2><h2 id="考虑阻碍-站库分离-CDN-WAP-负载均衡-主机防护"><a href="#考虑阻碍-站库分离-CDN-WAP-负载均衡-主机防护" class="headerlink" title="考虑阻碍-站库分离&amp;CDN&amp;WAP&amp;负载均衡&amp;主机防护"></a>考虑阻碍-站库分离&amp;CDN&amp;WAP&amp;负载均衡&amp;主机防护</h2>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/source/categories/Penetration-Testing-Basic/">Penetration Testing Basic</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/source/tags/pr0gram/">pr0gram</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2024/07/10/信息泄露与信息收集/"><span>信息收集初养成（基础的一些玩法）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/07/10/信息泄露与信息收集/" rel="bookmark">
        <time class="entry-date published" datetime="2024-07-10T06:33:00.000Z">
          2024-07-10
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>想要学好渗透测试，需要很多努力，不同于以往的学习体系抛给你漏洞原理和payload那么简单，是从底层慢慢摸索，甚至站在运维的角度，站在开发者站在甲方的角度去看问题，自然所要掌握的知识会多得多，但学会渗透测试其实并不难，市面上流通的工具和套路足够你成为所谓的脚本小子了，那么我们就从学会做一个脚本小子开始，依靠调试几个参数和市面上给定的脚本完成最基本的渗透吧！</p>
<p>这篇文章主要是讲解通常情况下的一些信息泄露和渗透者如何进行各方面的信息收集的，信息泄露和信息收集二者所指的概念统一却又相互分离，等到具体接触就会明白这是什么了</p>
<h1 id="Web之信息泄露"><a href="#Web之信息泄露" class="headerlink" title="Web之信息泄露"></a>Web之信息泄露</h1><p>这里不好意思通篇复制，可以转到这里看看信息泄露是怎么样的</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/a597934448/article/details/105431367">CTFHUBWeb技能树——信息泄露writeup_ctfhub web writeup-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/cx17775140296/article/details/130500741">CTFSHOW信息泄露</a></p>
<p>掌握了最基本的一些信息过后，下面以运维者的角度将一些需要注意的点罗列出来</p>
<h1 id="漏洞扫描技术"><a href="#漏洞扫描技术" class="headerlink" title="漏洞扫描技术"></a>漏洞扫描技术</h1><p>**</p>
<p><strong>目前，国内大多数单位都采用静态和动态两种方式进行漏洞扫描。</strong>静态扫描是指利用事先编写好的程序和相应的测试模板，对被测系统或信息系统进行全面的检查，得出系统或信息系统存在漏洞、缺陷或不足等结论；动态扫描则是在计算机运行时对其进行扫描，从计算机运行状态发现系统、信息系统中存在的问题。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240608162000454.png" alt="image-20240608162000454"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240608162022673.png" alt="image-20240608162022673"></p>
<p>主动扫描和被动扫描</p>
<p>主动扫描就是最简单的大量发包根据响应判断是否存在漏洞</p>
<p>被动扫描则使工具作为中间人篡改参数,通讯双方则都认为是自己在与对方对话</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240608170139818.png" alt="image-20240608170139818"></p>
<h3 id="漏洞扫描的作用"><a href="#漏洞扫描的作用" class="headerlink" title="漏洞扫描的作用"></a><strong>漏洞扫描的作用</strong></h3><p>（1）扫描被测系统存在的安全漏洞，了解其安全现状，以便及时修补漏洞，防止漏洞被利用。</p>
<p>（2）扫描被测系统的漏洞是为了提高其安全性。对于应用层的系统来说，当其<strong>操作系统版本较低</strong>时，由于其自身的一些漏洞会影响到其他软件功能的实现，如文件操作、访问权限、数据处理等功能。针对这种情况，<strong>需要进行漏洞扫描。</strong></p>
<p>（3）通过扫描，可以发现被测系统、信息系统中存在的安全隐患和不足，提出相应的修补建议，并通过测试验证该建议的可行性。</p>
<p>（4）为网络管理人员提供信息。在对被测系统进行漏洞扫描时，如果发现被测系统存在安全漏洞，就需要对其进行修补。如果发现了新的安全漏洞，就需要根据新发现的安全漏洞及时制定相应的安全策略和补丁措施。</p>
<p>（5）为黑客提供攻击目标。通过对被测系统进行漏洞扫描，可以发现黑客可能采用的攻击目标，为黑客提供攻击目标。</p>
<h3 id="扫描工具"><a href="#扫描工具" class="headerlink" title="扫描工具"></a><strong>扫描工具</strong></h3><p>漏洞扫描工具是利用软件工具对被测系统、信息系统进行的一种扫描。常见的漏洞扫描工具主要有：<strong>漏洞报告平台、渗透测试工具等。</strong></p>
<p><strong>漏洞报告是一个检测工具</strong>，它根据已知的网络和信息系统安全漏洞信息，按照一定的程序自动生成报告。渗透测试工具主要有：<strong>渗透测试平台、渗透测试器等。</strong></p>
<p>入侵检测是一种<strong>主动的网络安全技术</strong>，它能通过对网络数据包的分析和处理，发现网络系统中存在的各种安全隐患和风险，并对可能出现的威胁进行分析和判断，从而采取有效措施进行防范。入侵检测系统有：<strong>入侵检测分析软件、入侵检测服务器等。</strong></p>
<h3 id="漏洞评估"><a href="#漏洞评估" class="headerlink" title="漏洞评估"></a><strong>漏洞评估</strong></h3><p><strong>漏洞评估是指利用漏洞扫描工具对系统或信息系统进行扫描，发现可能存在的漏洞、安全风险，并对漏洞的安全性进行评估。</strong></p>
<p>常见的漏洞评估工具有：端口扫描工具、命令检测工具、服务检测工具等。在实际操作中，利用漏洞扫描工具对被测系统或信息系统进行全面的扫描，可以发现系统或信息系统中存在的问题。</p>
<p>常见的漏洞评估方法有：<strong>漏洞优先级评估法、漏洞利用风险评估法、入侵检测技术和模糊测试技术</strong>。</p>
<p>由于各种安全评估方法之间存在一定的差异，因此在实际应用中应根据被测系统或信息系统的实际情况进行选择，不能盲目照搬其他方法。<strong>如端口扫描工具是利用端口号来查找被测系统或信息系统中可能存在的安全问题，它能帮助用户发现那些已经被证明是不安全的端口，并对其进行屏蔽，从而避免了使用其他方法存在的缺陷。</strong></p>
<h3 id="漏洞扫描流程"><a href="#漏洞扫描流程" class="headerlink" title="漏洞扫描流程"></a><strong>漏洞扫描流程</strong></h3><p>漏洞扫描的基本流程一般包括以下几个步骤：</p>
<p>（1）发现系统存在的漏洞，了解系统存在的安全隐患；</p>
<p>（2）针对系统漏洞提出攻击策略，设计扫描工具，并生成可执行的扫描程序；</p>
<p>（3）发送扫描程序到目标网络；</p>
<p>（4）目标网络向扫描程序反馈信息；</p>
<p>（5）扫描程序根据信息进行漏洞攻击，并生成可执行的攻击代码；</p>
<p>（6）将攻击代码发送到被攻击的主机；</p>
<p>（7）被攻击的主机收到攻击代码后进行响应，修复漏洞。</p>
<p>其中，漏洞扫描技术一般采用<strong>渗透测试技术、漏洞挖掘技术和安全扫描技术三种方法进行</strong>。安全扫描技术一般包括主机安全扫描、应用安全扫描和服务安全扫描三种方法。目前，大多数单位都采用多种方法相结合的方式进行漏洞扫描。</p>
<h3 id="扫描步骤"><a href="#扫描步骤" class="headerlink" title="扫描步骤"></a><strong>扫描步骤</strong></h3><p>1、对目标系统或信息系统进行扫描，确定其是否存在安全漏洞。</p>
<p>2、编写测试脚本，从用户输入或系统配置文件中找到漏洞。</p>
<p>3、将找到的漏洞提交给漏洞挖掘工具或其他安全工具。</p>
<p>4、将扫描到的漏洞信息通知给被扫描单位。</p>
<p>5、被扫描单位根据扫描结果进行安全修复，或在主机上安装补丁程序，或采取其他相应的安全措施。</p>
<p>6、测试结束后，进行相关记录的保存工作。</p>
<p>7、根据收集到的信息，将报告发送给网络管理员进行处理。</p>
<p>8、对用户提出的改进建议及时回复给用户，并对用户提供相关技术支持。</p>
<p>漏洞挖掘工具会自动生成漏洞报告，记录扫描发现的所有信息并进行安全分析。<br>6.安全扫描类型<br>安全扫描有很多类型，常见的有：</p>
<p>1.基于操作系统的扫描：这种扫描主要是针对系统中存在的漏洞进行扫描，比如系统漏洞、配置漏洞、系统漏洞等，它能够发现用户可能忽略的潜在安全问题，并提供相关建议，其优点是简单易用，但是缺点是由于操作系统的限制，不能发现用户难以察觉到的高级安全问题。</p>
<p>2.基于应用程序的扫描：这种扫描主要是针对一些应用程序进行扫描，比如 Web应用程序、 WEB服务器、数据库等。它能够发现和分析应用程序中存在的安全问题，同时能够提供相关建议。其优点是能够发现比较隐蔽的安全问题，其缺点是不能发现高级安全问题。</p>
<p>3.基于协议的扫描：这种扫描主要是针对一些协议进行扫描。比如 TCP&#x2F;IP、 HTTP、 FTP、 SMTP等协议。</p>
<p>7.常见的漏洞类型及对应的扫描方法<br>（一）缓冲区溢出漏洞<br>这种漏洞在系统或应用中最常见，它的危害表现在用户会因为无意中访问了一些错误的数据包而造成严重的后果。我们可以利用在 Web服务器中常见的各种手段来发现这些问题，具体方法是：</p>
<p>1、将一个或多个用户名和密码存储在文件中，并对其进行加密。当用户输入密码时，这些信息就会被加密。如果系统存在缓冲区溢出漏洞，黑客就可以通过对文件进行直接拷贝或修改来获得密码，从而达到窃取用户信息的目的。</p>
<p>2、如果用户在网络连接时使用了外网 IP地址，则可以通过反向代理服务器来获得 IP地址。</p>
<p>（二）权限提升漏洞<br>这种漏洞可以通过以下方法来进行扫描：</p>
<p>1、通过网络向目标主机发送一个探测包。</p>
<p>2、在探测包中将包含一个伪造的 IP地址或域名作为密码，然后发送回探测包。</p>
<p>3、探测包中包含一个与目标主机建立连接的参数，并将其返回给管理员。</p>
<p>4、管理员可以根据收到的数据包来判断该主机是否存在权限提升漏洞，如果存在，则将该主机加入到目标主机的白名单中。</p>
<h1 id="域名信息"><a href="#域名信息" class="headerlink" title="域名信息"></a>域名信息</h1><h2 id="Whois"><a href="#Whois" class="headerlink" title="Whois"></a>Whois</h2><p><a target="_blank" rel="noopener" href="https://www.whois.com/">Whois</a> 可以查询域名是否被注册，以及注册域名的详细信息的数据库，其中可能会存在一些有用的信息，例如域名所有人、域名注册商、邮箱等。</p>
<h2 id="搜索引擎搜索"><a href="#搜索引擎搜索" class="headerlink" title="搜索引擎搜索"></a>搜索引擎搜索</h2><p>搜索引擎通常会记录域名信息，可以通过 <code>site: domain</code> 的语法来查询。</p>
<h2 id="第三方查询"><a href="#第三方查询" class="headerlink" title="第三方查询"></a>第三方查询</h2><p>网络中有相当多的第三方应用提供了子域的查询功能，下面有一些例子，更多的网站可以在 8.1 工具列表 中查找。</p>
<h3 id="Whois信息"><a href="#Whois信息" class="headerlink" title="Whois信息"></a>Whois信息</h3><p>站长之家：<a target="_blank" rel="noopener" href="http://whois.chinaz.com/">http://whois.chinaz.com</a> </p>
<p>万商数源：<a target="_blank" rel="noopener" href="https://www.wanshangdata.com/domainrelated/index.html">https://www.wanshangdata.com/domainrelated/index.html</a> </p>
<p>1.域名对应的邮箱； </p>
<p>2.该邮箱注册的所有域名； </p>
<p>3.企业CEO名称注册的域名；</p>
<p> SRC：安全应急响应中心（漏洞、情报）</p>
<h2 id="ASN信息关联"><a href="#ASN信息关联" class="headerlink" title="ASN信息关联"></a>ASN信息关联</h2><p>在网络中一个自治系统 (Autonomous System, AS) 是一个<strong>有权自主地决定在本系统中应采用何种路由协议的小型单位</strong>。这个网络单位可以是一个简单的网络也可以是一个由一个或多个普通的网络管理员来控制的网络群体，它是一个单独的可管理的网络单元 (例如一所大学，一个企业或者一个公司个体) 。</p>
<p><strong>一个自治系统有时也被称为是一个路由选择域</strong> (routing domain) 。一个自治系统将会分配一个全局的唯一的16位号码，这个号码被称为自治系统号 (ASN) 。因此可以通过ASN号来查找可能相关的IP，例如：</p>
<h2 id="域名相关性"><a href="#域名相关性" class="headerlink" title="域名相关性"></a>域名相关性</h2><p>同一个企业&#x2F;个人注册的多个域名通常具有一定的相关性，例如使用了同一个邮箱来注册、使用了同一个备案、同一个负责人来注册等，可以使用这种方式来查找关联的域名。一种操作步骤如下：</p>
<ul>
<li>查询<strong>域名注册邮箱</strong></li>
<li>通过域名查询<strong>备案号</strong></li>
<li>通过<strong>备案号查询域名</strong></li>
<li>反查<strong>注册邮箱</strong></li>
<li>反查<strong>注册人</strong></li>
<li>通过注册人查询到的域名在查询邮箱</li>
<li>通过上一步邮箱去查询域名</li>
<li>查询以上获取出的域名的子域名</li>
</ul>
<h2 id="多级域名"><a href="#多级域名" class="headerlink" title="多级域名"></a>多级域名</h2><p>域名：URL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">一级：ｅｘａｍｐｌｅ．ｃｏｍ</span><br><span class="line"></span><br><span class="line">　　　．ｃｎ　．ｕｓ／．ｃｏｍ　．ｏｒｇ</span><br><span class="line">   　．ｎｅｔ等</span><br><span class="line"></span><br><span class="line">二级域名：ｗｗｗ．ｅｘａｍｐｌｅ．ｃｏｍ</span><br><span class="line"></span><br><span class="line">三级域名：　</span><br><span class="line"></span><br><span class="line">ｂｂｓ．ａｂｃ．ｅｘａｍｐｌｅ．ｃｏｍ</span><br><span class="line"></span><br><span class="line">为ａｂｃ．ｅｘａｍｐｌｅ．ｃｏｍ的子域名</span><br><span class="line"></span><br><span class="line">同理为ｅｘａｍｐｌｅ．ｃｏｍ的子域名</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="网站信息利用"><a href="#网站信息利用" class="headerlink" title="网站信息利用"></a>网站信息利用</h2><p>网站中有相当多的信息，网站本身、各项安全策略、设置等都可能暴露出一些信息。</p>
<p><strong>网站本身的交互通常不囿于单个域名，会和其他子域交互。对于这种情况，可以通过爬取网站，收集站点中的其他子域信息。这些信息通常出现在JavaScript文件、资源文件链接等位置。</strong></p>
<p>网站的安全策略如跨域策略、CSP规则等通常也包含相关域名的信息。有时候多个域名为了方便会使用同一个SSL&#x2F;TLS证书，因此有时可通过证书来获取相关域名信息。</p>
<h2 id="HTTPS证书"><a href="#HTTPS证书" class="headerlink" title="HTTPS证书"></a>HTTPS证书</h2><h3 id="证书透明度"><a href="#证书透明度" class="headerlink" title="证书透明度"></a>证书透明度</h3><p>为了保证HTTPS证书不会被误发或伪造，CA会将证书记录到可公开验证、不可篡改且只能附加内容的日志中，任何感兴趣的相关方都可以查看由授权中心签发的所有证书。<strong>因此可以通过查询已授权证书的方式来获得相关域名。</strong></p>
<h3 id="SAN"><a href="#SAN" class="headerlink" title="SAN"></a>SAN</h3><p>主题备用名称 (Subject Alternate Name, SAN)，简单来说，在需要多个域名，并将其用于各项服务时，多使用SAN证书。<strong>SAN允许在安全证书中使用subjectAltName字段将多种值与证书关联，这些值被称为主题备用名称。</strong></p>
<h2 id="域传送漏洞"><a href="#域传送漏洞" class="headerlink" title="域传送漏洞"></a>域传送漏洞</h2><p>DNS域传送 (zone transfer) 指的是冗余备份服务器使用来自主服务器的数据刷新自己的域 (zone) 数据库。这是为了防止主服务器因意外不可用时影响到整个域名的解析。</p>
<p>一般来说，<strong>域传送操作应该只允许可信的备用DNS服务器发起，但是如果错误配置了授权，那么任意用户都可以获得整个DNS服务器的域名信息。这种错误授权被称作是DNS域传送漏洞。</strong></p>
<h2 id="Passive-DNS"><a href="#Passive-DNS" class="headerlink" title="Passive DNS"></a>Passive DNS</h2><p>Passive DNS<strong>被动的从递归域名服务器记录来自不同域名服务器的响应，形成数据库。利用Passive DNS数据库可以知道域名曾绑定过哪些IP，IP曾关联到哪些域名，</strong>域名最早&#x2F;最近出现的时间，为测试提供较大的帮助。Virustotal、passivetotal、CIRCL等网站都提供了Passive DNS数据库的查询。</p>
<h2 id="泛解析"><a href="#泛解析" class="headerlink" title="泛解析"></a>泛解析</h2><p>泛解析是把 *.example.com 的所有A记录都解析到某个IP 地址上，在子域名枚举时需要处理这种情况以防生成大量无效的记录。</p>
<h2 id="重要记录"><a href="#重要记录" class="headerlink" title="重要记录"></a>重要记录</h2><h3 id="CNAME"><a href="#CNAME" class="headerlink" title="CNAME"></a>CNAME</h3><p>CNAME即Canonical name，又称alias，<strong>将域名指向另一个域名。其中可能包含其他关联业务的信息。很多网站使用的CDN加速功能利用了该记录。</strong></p>
<h3 id="MX记录"><a href="#MX记录" class="headerlink" title="MX记录"></a>MX记录</h3><p>MX记录即Mail Exchanger，记录了<strong>发送电子邮件时域名对应的服务器地址</strong>。<strong>可以用来寻找SMTP服务器信息。</strong></p>
<h3 id="NS记录"><a href="#NS记录" class="headerlink" title="NS记录"></a>NS记录</h3><p>NS (Name Server) 记录是域名服务器的记录，用来指定域名由哪个DNS服务器来进行解析。</p>
<h3 id="SPF记录"><a href="#SPF记录" class="headerlink" title="SPF记录"></a>SPF记录</h3><p>SPF (Sender Policy Framework) 是<strong>为了防止垃圾邮件而提出来的一种DNS记录类型</strong>，是一种TXT类型的记录，用于登记某个域名拥有的用来外发邮件的所有IP地址。通过SPF记录可以获取相关的IP信息，常用命令为 <code>dig example.com txt</code> 。</p>
<h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>CDN就是依靠部署在各地的CDN节点边缘服务器，使各地用户访问时通过中心分流分发数据的，减少了延迟。</p>
<p>不过当一个网站上了CDN就出现了问题，真实ｉｐ自此被掩盖。这个时候就只能查找一些DNS解析历史记录</p>
<h3 id="CDN验证"><a href="#CDN验证" class="headerlink" title="CDN验证"></a>CDN验证</h3><p>可通过多地ping的方式确定目标是否使用了CDN，常用的网站有 </p>
<p><code>http://ping.chinaz.com/</code> <code>https://asm.ca.com/en/ping.php</code> 等。</p>
<h3 id="域名查找"><a href="#域名查找" class="headerlink" title="域名查找"></a>域名查找</h3><p>使用了CDN的域名的父域或者子域名不一定使用了CDN，可以通过这种方式去查找对应的IP</p>
<h3 id="历史记录查找"><a href="#历史记录查找" class="headerlink" title="历史记录查找"></a>历史记录查找</h3><p>CDN可能是在网站上线一段时间后才上线的，可以通过查找域名解析记录的方式去查找真实IP。</p>
<h3 id="邮件信息"><a href="#邮件信息" class="headerlink" title="邮件信息"></a>邮件信息</h3><p>通过社会工程学的方式进行邮件沟通，从邮件头中获取IP地址，IP地址可能是网站的真实IP或者是目标的出口IP。</p>
<h2 id="子域爆破"><a href="#子域爆破" class="headerlink" title="子域爆破"></a>子域爆破</h2><p>在内网等不易用到以上技巧的环境，或者想监测新域名上线时，可以通过批量尝试的方式，找到有效的域名。</p>
<h2 id="域名-子域名"><a href="#域名-子域名" class="headerlink" title="域名&amp;子域名"></a>域名&amp;子域名</h2><p>RappidDns：<a target="_blank" rel="noopener" href="https://rapiddns.io/subdomain">https://rapiddns.io/subdomain</a> （在线）</p>
<p>查子域&#x2F;备案：<a target="_blank" rel="noopener" href="https://chaziyu.com/">https://chaziyu.com/</a> （在线）</p>
<p>子域名挖掘机</p>
<p>OneForAll：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/shmilylty/OneForAll">https://github.com/shmilylty/OneForAll</a></p>
<p>ksubdomain：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/knownsec/ksubdomain">https://github.com/knownsec/ksubdomain</a></p>
<p>subDomainsBrute：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/lijiejie/subDomainsBrute">https://github.com/lijiejie/subDomainsBrute</a></p>
<p>Sublist3r：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/aboul3la/Sublist3r">https://github.com/aboul3la/Sublist3r</a></p>
<h2 id="缓存探测技术"><a href="#缓存探测技术" class="headerlink" title="缓存探测技术"></a>缓存探测技术</h2><p>在企业网络中通常都会配置DNS服务器为网络内的主机提供域名解析服务。域名缓存侦测（DNS Cache Snooping）技术就是向这些服务器发送域名解析请求，但并不要求使用递归模式，用于探测是否请求过某个域名。这种方式可以用来探测是否使用了某些软件，尤其是安全软件。</p>
<h1 id="端口信息"><a href="#端口信息" class="headerlink" title="端口信息"></a>端口信息</h1><h2 id="常见端口及其脆弱点"><a href="#常见端口及其脆弱点" class="headerlink" title="常见端口及其脆弱点"></a>常见端口及其脆弱点</h2><ul>
<li><ul>
<li><p>FTP (21&#x2F;TCP)</p>
<p>默认用户名密码 <code>anonymous:anonymous</code>暴力破解密码VSFTP某版本后门</p>
</li>
</ul>
</li>
<li><ul>
<li><p>SSH (22&#x2F;TCP)</p>
<p>部分版本SSH存在漏洞可枚举用户名暴力破解密码</p>
</li>
</ul>
</li>
<li><ul>
<li><p>Telent (23&#x2F;TCP)</p>
<p>暴力破解密码嗅探抓取明文密码</p>
</li>
</ul>
</li>
<li><ul>
<li><p>SMTP (25&#x2F;TCP)</p>
<p>无认证时可伪造发件人</p>
</li>
</ul>
</li>
<li><ul>
<li><p>DNS (53&#x2F;UDP &amp; 53&#x2F;TCP)</p>
<p>域传送漏洞DNS劫持DNS缓存投毒DNS欺骗SPF &#x2F; DMARC CheckDDoSDNS Query FloodDNS 反弹DNS 隧道</p>
</li>
</ul>
</li>
<li><ul>
<li><p>DHCP 67&#x2F;68</p>
<p>劫持&#x2F;欺骗</p>
</li>
</ul>
</li>
<li><p>TFTP (69&#x2F;TCP)</p>
</li>
<li><p>HTTP (80&#x2F;TCP)</p>
</li>
<li><ul>
<li><p>Kerberos (88&#x2F;TCP)</p>
<p>主要用于监听KDC的票据请求用于进行黄金票据和白银票据的伪造</p>
</li>
</ul>
</li>
<li><ul>
<li><p>POP3 (110&#x2F;TCP &amp; 995&#x2F;TCP)</p>
<p>爆破</p>
</li>
</ul>
</li>
<li><ul>
<li><p>RPC (135&#x2F;TCP)</p>
<p>wmic 服务利用</p>
</li>
</ul>
</li>
<li><ul>
<li><p>NetBIOS (137&#x2F;UDP &amp; 138&#x2F;UDP)</p>
<p>未授权访问弱口令</p>
</li>
</ul>
</li>
<li><ul>
<li><p>NetBIOS &#x2F; Samba (139&#x2F;TCP)</p>
<p>未授权访问弱口令</p>
</li>
</ul>
</li>
<li><p>IMAP (143&#x2F;TCP &amp; 993&#x2F;TCP)</p>
</li>
<li><ul>
<li><p>SNMP (161&#x2F;TCP &amp; 161&#x2F;UDP)</p>
<p>Public 弱口令</p>
</li>
</ul>
</li>
<li><ul>
<li><p>LDAP (389&#x2F;TCP)</p>
<p>用于域上的权限验证服务匿名访问注入</p>
</li>
</ul>
</li>
<li><p>HTTPS (443&#x2F;TCP)</p>
</li>
<li><ul>
<li><p>SMB (445&#x2F;TCP)</p>
<p>Windows 协议簇，主要功能为文件共享服务<code>net use \\192.168.1.1 /user:xxx\username password</code></p>
</li>
</ul>
</li>
<li><ul>
<li><p>Linux Rexec (512&#x2F;TCP &amp; 513&#x2F;TCP &amp; 514&#x2F;TCP)</p>
<p>弱口令</p>
</li>
</ul>
</li>
<li><ul>
<li><p>Rsync (873&#x2F;TCP)</p>
<p>未授权访问</p>
</li>
</ul>
</li>
<li><ul>
<li><p>RPC (1025&#x2F;TCP)</p>
<p>NFS匿名访问</p>
</li>
</ul>
</li>
<li><ul>
<li><p>Java RMI (1090&#x2F;TCP &amp; 1099&#x2F;TCP)</p>
<p>反序列化远程命令执行漏洞</p>
</li>
</ul>
</li>
<li><ul>
<li><p>MSSQL (1433&#x2F;TCP)</p>
<p>弱密码差异备份 GetShellSA 提权</p>
</li>
</ul>
</li>
<li><ul>
<li><p>Oracle (1521&#x2F;TCP)</p>
<p>弱密码</p>
</li>
</ul>
</li>
<li><ul>
<li><p>NFS (2049&#x2F;TCP)</p>
<p>权限设置不当<code>showmount &lt;host&gt;</code></p>
</li>
</ul>
</li>
<li><ul>
<li><p>ZooKeeper (2171&#x2F;TCP &amp; 2375&#x2F;TCP)</p>
<p>无身份认证</p>
</li>
</ul>
</li>
<li><ul>
<li><p>Docker Remote API (2375&#x2F;TCP)</p>
<p>未限制IP &#x2F; 未启用TLS身份认证<code>http://docker.addr:2375/version</code></p>
</li>
</ul>
</li>
<li><ul>
<li><p>MySQL (3306&#x2F;TCP)</p>
<p>弱密码日志写WebShellUDF提权MOF提权</p>
</li>
</ul>
</li>
<li><ul>
<li><p>RDP &#x2F; Terminal Services (3389&#x2F;TCP)</p>
<p>弱密码</p>
</li>
</ul>
</li>
<li><ul>
<li><p>Postgres (5432&#x2F;TCP)</p>
<p>弱密码执行系统命令</p>
</li>
</ul>
</li>
<li><ul>
<li><p>VNC (5900&#x2F;TCP)</p>
<p>弱密码</p>
</li>
</ul>
</li>
<li><ul>
<li><p>CouchDB (5984&#x2F;TCP)</p>
<p>未授权访问</p>
</li>
</ul>
</li>
<li><ul>
<li><p>WinRM (5985&#x2F;TCP)</p>
<p>Windows对WS-Management的实现在Vista上需要手动启动，在Windows Server 2008中服务是默认开启的</p>
</li>
</ul>
</li>
<li><ul>
<li><p>Redis (6379&#x2F;TCP)</p>
<p>无密码或弱密码绝对路径写 WebShell计划任务反弹 Shell写 SSH 公钥主从复制 RCEWindows 写启动项</p>
</li>
</ul>
</li>
<li><ul>
<li><p>Kubernetes API Server (6443&#x2F;TCP &amp;&amp; 10250&#x2F;TCP)</p>
<p><code>https://Kubernetes:10250/pods</code></p>
</li>
</ul>
</li>
<li><ul>
<li><p>JDWP (8000&#x2F;TCP)</p>
<p>远程命令执行</p>
</li>
</ul>
</li>
<li><p>ActiveMQ (8061&#x2F;TCP)</p>
</li>
<li><ul>
<li><p>Jenkin (8080&#x2F;TCP)</p>
<p>未授权访问</p>
</li>
</ul>
</li>
<li><ul>
<li><p>Elasticsearch (9200&#x2F;TCP)</p>
<p>代码执行<code>http://es.addr:9200/_plugin/head/``http://es.addr:9200/_nodes</code></p>
</li>
</ul>
</li>
<li><ul>
<li><p>Memcached (11211&#x2F;TCP &amp; 11211&#x2F;UDP)</p>
<p>未授权访问</p>
</li>
</ul>
</li>
<li><p>RabbitMQ (15672&#x2F;TCP &amp; 15692&#x2F;TCP &amp; 25672&#x2F;TCP)</p>
</li>
<li><ul>
<li><p>MongoDB (27017&#x2F;TCP)</p>
<p>无密码或弱密码</p>
</li>
</ul>
</li>
<li><ul>
<li><p>Hadoop (50070&#x2F;TCP &amp; 50075&#x2F;TCP)</p>
<p>未授权访问</p>
</li>
</ul>
</li>
</ul>
<p>除了以上列出的可能出现的问题，暴露在公网上的服务若不是最新版，都可能存在已经公开的漏洞</p>
<h2 id="常见端口扫描技术"><a href="#常见端口扫描技术" class="headerlink" title="常见端口扫描技术"></a>常见端口扫描技术</h2><h3 id="全扫描"><a href="#全扫描" class="headerlink" title="全扫描"></a>全扫描</h3><p>扫描主机尝试使用三次握手与目标主机的某个端口建立正规的连接，若成功建立连接，则端口处于开放状态，反之处于关闭状态。</p>
<p>全扫描实现简单，且以较低的权限就可以进行该操作。但是在流量日志中会有大量明显的记录。</p>
<h3 id="半扫描"><a href="#半扫描" class="headerlink" title="半扫描"></a>半扫描</h3><p>半扫描也称SYN扫描，在半扫描中，仅发送SYN数据段，如果应答为RST，则端口处于关闭状态，若应答为SYN&#x2F;ACK，则端口处于监听状态。不过这种方式需要较高的权限，而且现在的大部分防火墙已经开始对这种扫描方式做处理。</p>
<h3 id="FIN扫描"><a href="#FIN扫描" class="headerlink" title="FIN扫描"></a>FIN扫描</h3><p>FIN扫描是向目标发送一个FIN数据包，如果是开放的端口，会返回RST数据包，关闭的端口则不会返回数据包，可以通过这种方式来判断端口是否打开。</p>
<p>这种方式并不在TCP三次握手的状态中，所以不会被记录，相对SYN扫描要更隐蔽一些。</p>
<h2 id="Web服务（旁站＋真实IP＋端口-指纹信息-路径）"><a href="#Web服务（旁站＋真实IP＋端口-指纹信息-路径）" class="headerlink" title="Web服务（旁站＋真实IP＋端口+指纹信息+路径）"></a>Web服务（旁站＋真实IP＋端口+指纹信息+路径）</h2><h4 id="旁站信息"><a href="#旁站信息" class="headerlink" title="旁站信息"></a>旁站信息</h4><ul>
<li><p>一个服务器可以起多个web服务，开不同的端口即可，相当于一个IP映射给多个域名。</p>
<p>在线：<a target="_blank" rel="noopener" href="http://stool.chinaz.com/same">http://stool.chinaz.com/same</a></p>
<p>在线：<a target="_blank" rel="noopener" href="https://site.ip138.com/">https://site.ip138.com</a></p>
<p><strong>ipc横向</strong>,从侧面其他服务入手绕后拿下核心的安全业务–旁站攻击</p>
<p><strong>旁站的查询涉及到CDN的问题，所以为了查询到准确的旁站信息，我们需要找到目标的真实IP</strong></p>
<h4 id="真实ip"><a href="#真实ip" class="headerlink" title="真实ｉｐ"></a>真实ｉｐ</h4><p>全球ping：<a target="_blank" rel="noopener" href="http://tool.zhiduopc.com/ping">http://tool.zhiduopc.com/ping</a></p>
<p>17CE：<a target="_blank" rel="noopener" href="http://www.17ce.com/">http://www.17ce.com/</a></p>
<p>DNS检测：<a target="_blank" rel="noopener" href="https://tools.ipip.net/dns.php**%EF%BC%88%E8%BF%98%E5%8F%AF%E4%BB%A5%E6%9F%A5%E8%AF%A2IP%E7%B2%BE%E5%87%86%E4%BF%A1%E6%81%AF%EF%BC%89">https://tools.ipip.net/dns.php**（还可以查询IP精准信息）</a>**</p>
<p>IP查询：<a target="_blank" rel="noopener" href="https://ipchaxun.com/">https://ipchaxun.com/</a></p>
<p>BOCE：<a target="_blank" rel="noopener" href="https://www.boce.com/%EF%BC%88DNS%E6%A3%80%E6%B5%8B%E3%80%81%E5%8A%AB%E6%8C%81%E6%A3%80%E6%B5%8B%EF%BC%89">https://www.boce.com/（DNS检测、劫持检测）</a></p>
<p> ITDOG：<a target="_blank" rel="noopener" href="https://www.itdog.cn/ping/it">https://www.itdog.cn/ping/it</a></p>
<p>Ping.cn：<a target="_blank" rel="noopener" href="https://www.ping.cn/dns/">https://www.ping.cn/dns/</a></p>
<h4 id="端口-指纹信息-路径"><a href="#端口-指纹信息-路径" class="headerlink" title="端口+指纹信息+路径"></a>端口+指纹信息+路径</h4><p>fscan：探测神器</p>
<p>Nmap：<a target="_blank" rel="noopener" href="https://nmap.org/">https://nmap.org</a></p>
<p>Goby：<a target="_blank" rel="noopener" href="https://gobies.org/">https://gobies.org/</a></p>
<p>御剑：<a target="_blank" rel="noopener" href="https://github.com/foryujian/yujianportscan">https://github.com/foryujian/yujianportscan</a> 推荐在虚拟机里玩一玩dirsearch</p>
</li>
</ul>
<h1 id="站点信息"><a href="#站点信息" class="headerlink" title="站点信息"></a>站点信息</h1><ul>
<li><ul>
<li><p>判断网站操作系统</p>
<p>Linux大小写敏感Windows大小写不敏感</p>
</li>
</ul>
</li>
<li><ul>
<li><p>扫描敏感文件</p>
<p>robots.txtcrossdomain.xmlsitemap.xmlxx.tar.gzxx.bak等</p>
</li>
</ul>
</li>
<li><ul>
<li><p>确定网站采用的语言</p>
<p>如PHP &#x2F; Java &#x2F; Python等找后缀，比如php&#x2F;asp&#x2F;jsp</p>
</li>
</ul>
</li>
<li><ul>
<li><p>前端框架</p>
<p>如jQuery &#x2F; BootStrap &#x2F; Vue &#x2F; React &#x2F; Angular等查看源代码</p>
</li>
</ul>
</li>
<li><ul>
<li><p>中间服务器</p>
<p>如 Apache &#x2F; Nginx &#x2F; IIS 等查看header中的信息根据报错信息判断根据默认页面判断</p>
</li>
</ul>
</li>
<li><ul>
<li><p>Web容器服务器</p>
<p>如Tomcat &#x2F; Jboss &#x2F; Weblogic等</p>
</li>
</ul>
</li>
<li><ul>
<li><p>后端框架</p>
<p>根据Cookie判断根据CSS &#x2F; 图片等资源的hash值判断根据URL路由判断如wp-admin根据网页中的关键字判断根据响应头中的X-Powered-By</p>
</li>
</ul>
</li>
<li><ul>
<li><p>CDN信息</p>
<p>常见的有Cloudflare、yunjiasu</p>
</li>
</ul>
</li>
<li><ul>
<li><p>探测有没有WAF，如果有，什么类型的</p>
<p>有WAF，找绕过方式没有，进入下一步</p>
</li>
</ul>
</li>
<li><ul>
<li><p>扫描敏感目录，看是否存在信息泄漏</p>
<p>扫描之前先自己尝试几个的url，人为看看反应</p>
</li>
</ul>
</li>
<li><p>使用爬虫爬取网站信息</p>
</li>
<li><p>拿到一定信息后，通过拿到的目录名称，文件名称及文件扩展名了解网站开发人员的命名思路，确定其命名规则，推测出更多的目录及文件名</p>
</li>
<li><ul>
<li><p>常见入口目标</p>
<p>关注度低的系统业务线较长的系统</p>
</li>
</ul>
</li>
</ul>
<h1 id="搜索引擎利用"><a href="#搜索引擎利用" class="headerlink" title="搜索引擎利用"></a>搜索引擎利用</h1><p>恰当地使用搜索引擎（Google&#x2F;Bing&#x2F;Yahoo&#x2F;Baidu等）可以获取目标站点的较多信息。</p>
<h2 id="搜索引擎处理流程"><a href="#搜索引擎处理流程" class="headerlink" title="搜索引擎处理流程"></a>搜索引擎处理流程</h2><ul>
<li><ul>
<li><p>数据预处理</p>
<p>长度截断大小写转化去标点符号简繁转换数字归一化，中文数字、阿拉伯数字、罗马字同义词改写拼音改写</p>
</li>
</ul>
</li>
<li><ul>
<li><p>处理</p>
<p>分词关键词抽取非法信息过滤</p>
</li>
</ul>
</li>
</ul>
<h2 id="搜索技巧"><a href="#搜索技巧" class="headerlink" title="搜索技巧"></a>搜索技巧</h2><ul>
<li><ul>
<li><p>当然，下面是对这些搜索操作符的图解说明，帮助你更好地理解它们的用法。</p>
<h3 id="图解说明"><a href="#图解说明" class="headerlink" title="图解说明"></a>图解说明</h3><h4 id="1-site"><a href="#1-site" class="headerlink" title="1. site:"></a>1. <strong>site:</strong></h4><p><strong>作用</strong>：限定搜索结果在特定网站内。<br><strong>示例</strong>：</p>
<ul>
<li><code>site:www.hao123.com</code></li>
<li>返回结果：该网站上被搜索引擎收录的所有内容。</li>
</ul>
<p><img src="https://i.imgur.com/6tA6w7c.png" alt="site: 操作符"></p>
<h4 id="2-site-keyword"><a href="#2-site-keyword" class="headerlink" title="2. site: + keyword"></a>2. <strong>site: + keyword</strong></h4><p><strong>作用</strong>：在特定网站内搜索包含某关键词的所有页面。<br><strong>示例</strong>：</p>
<ul>
<li><code>site:www.hao123.com 密码修改</code></li>
<li>返回结果：hao123.com网站内包含“密码修改”关键词的页面。</li>
</ul>
<p><img src="https://i.imgur.com/MLYd18n.png" alt="site: + keyword"></p>
<h4 id="3-site-inurl"><a href="#3-site-inurl" class="headerlink" title="3. site: + inurl:"></a>3. <strong>site: + inurl:</strong></h4><p><strong>作用</strong>：在特定网站内搜索URL中包含特定词语的页面。<br><strong>示例</strong>：</p>
<ul>
<li><code>site:www.hao123.com inurl:admin.php</code></li>
<li>返回结果：hao123.com网站内URL中包含“admin.php”的页面。</li>
</ul>
<p><img src="https://i.imgur.com/NmPtyU8.png" alt="site: + inurl:"></p>
<h4 id="4-link"><a href="#4-link" class="headerlink" title="4. link:"></a>4. <strong>link:</strong></h4><p><strong>作用</strong>：返回所有包含目标站点链接的页面。<br><strong>示例</strong>：</p>
<ul>
<li><code>link:www.hao123.com</code></li>
<li>返回结果：所有包含<a target="_blank" rel="noopener" href="http://www.hao123.com链接的页面./">www.hao123.com链接的页面。</a></li>
</ul>
<p><img src="https://i.imgur.com/Mw4XeWd.png" alt="link: 操作符"></p>
<h4 id="5-related"><a href="#5-related" class="headerlink" title="5. related:"></a>5. <strong>related:</strong></h4><p><strong>作用</strong>：返回与目标站点相似的页面。<br><strong>示例</strong>：</p>
<ul>
<li><code>related:www.hao123.com</code></li>
<li>返回结果：所有与hao123.com相似的页面。</li>
</ul>
<p><img src="https://i.imgur.com/Bak8V2r.png" alt="related: 操作符"></p>
<h4 id="6-intitle"><a href="#6-intitle" class="headerlink" title="6. intitle:"></a>6. <strong>intitle:</strong></h4><p><strong>作用</strong>：搜索页面标题中包含特定词语的页面。<br><strong>示例</strong>：</p>
<ul>
<li><code>intitle:&quot;500 Internal Server Error&quot; &quot;server at&quot;</code></li>
<li>返回结果：页面标题中包含这些词语的页面，通常用来查找出错页面。</li>
</ul>
<p><img src="https://i.imgur.com/RW3jTqG.png" alt="intitle: 操作符"></p>
<h4 id="7-inurl"><a href="#7-inurl" class="headerlink" title="7. inurl:"></a>7. <strong>inurl:</strong></h4><p><strong>作用</strong>：搜索URL中包含特定词语的页面。<br><strong>示例</strong>：</p>
<ul>
<li><code>inurl:&quot;nph-proxy.cgi&quot; &quot;Start browsing&quot;</code></li>
<li>返回结果：URL中包含这些词语的页面，通常用来查找代理服务器。</li>
</ul>
<p><img src="https://i.imgur.com/EnuPYdm.png" alt="inurl: 操作符"></p>
<h4 id="8-allintitle"><a href="#8-allintitle" class="headerlink" title="8. allintitle:"></a>8. <strong>allintitle:</strong></h4><p><strong>作用</strong>：搜索页面标题中包含所有给定词语的页面。<br><strong>示例</strong>：</p>
<ul>
<li><code>allintitle:keyword1 keyword2</code></li>
<li>返回结果：标题中同时包含keyword1和keyword2的页面。</li>
</ul>
<p><img src="https://i.imgur.com/XCJpfo5.png" alt="allintitle: 操作符"></p>
<h4 id="9-allinurl"><a href="#9-allinurl" class="headerlink" title="9. allinurl:"></a>9. <strong>allinurl:</strong></h4><p><strong>作用</strong>：搜索URL中包含所有给定词语的页面。<br><strong>示例</strong>：</p>
<ul>
<li><code>allinurl:keyword1 keyword2</code></li>
<li>返回结果：URL中同时包含keyword1和keyword2的页面。</li>
</ul>
<p><img src="https://i.imgur.com/MLWxkjc.png" alt="allinurl: 操作符"></p>
<h4 id="10-allintext"><a href="#10-allintext" class="headerlink" title="10. allintext:"></a>10. <strong>allintext:</strong></h4><p><strong>作用</strong>：搜索页面正文中包含所有给定词语的页面。<br><strong>示例</strong>：</p>
<ul>
<li><code>allintext:keyword1 keyword2</code></li>
<li>返回结果：正文中同时包含keyword1和keyword2的页面。</li>
</ul>
<p><img src="https://i.imgur.com/5W4z0Ft.png" alt="allintext: 操作符"></p>
<h4 id="11-inanchor"><a href="#11-inanchor" class="headerlink" title="11. inanchor:"></a>11. <strong>inanchor:</strong></h4><p><strong>作用</strong>：搜索链接锚文本中包含特定词语的页面。<br><strong>示例</strong>：</p>
<ul>
<li><code>inanchor:keyword</code></li>
<li>返回结果：链接文本中包含keyword的页面。</li>
</ul>
<p><img src="https://i.imgur.com/mqdpYJG.png" alt="inanchor: 操作符"></p>
<h4 id="12-intext"><a href="#12-intext" class="headerlink" title="12. intext:"></a>12. <strong>intext:</strong></h4><p><strong>作用</strong>：搜索页面正文中包含特定词语的页面。<br><strong>示例</strong>：</p>
<ul>
<li><code>intext:keyword</code></li>
<li>返回结果：正文中包含keyword的页面。</li>
</ul>
<p><img src="https://i.imgur.com/bznljFV.png" alt="intext: 操作符"></p>
<h4 id="13-filetype"><a href="#13-filetype" class="headerlink" title="13. filetype:"></a>13. <strong>filetype:</strong></h4><p><strong>作用</strong>：搜索特定文件类型。<br><strong>示例</strong>：</p>
<ul>
<li><code>filetype:pdf keyword</code></li>
<li>返回结果：包含keyword的PDF文件。</li>
</ul>
<p><img src="https://i.imgur.com/JLXEL9t.png" alt="filetype: 操作符"></p>
<h4 id="14-info"><a href="#14-info" class="headerlink" title="14. info:"></a>14. <strong>info:</strong></h4><p><strong>作用</strong>：返回关于某个URL的信息页面。<br><strong>示例</strong>：</p>
<ul>
<li><code>info:www.hao123.com</code></li>
<li>返回结果：关于<a target="_blank" rel="noopener" href="http://www.hao123.com的信息./">www.hao123.com的信息。</a></li>
</ul>
<p><img src="https://i.imgur.com/rXodN8L.png" alt="info: 操作符"></p>
<h4 id="15-numrange"><a href="#15-numrange" class="headerlink" title="15. numrange:"></a>15. <strong>numrange:</strong></h4><p><strong>作用</strong>：搜索特定数字范围内的内容。<br><strong>示例</strong>：</p>
<ul>
<li><code>numrange:100..200</code></li>
<li>返回结果：包含100到200之间数字的页面。</li>
</ul>
<p><img src="https://i.imgur.com/jFxdeUk.png" alt="numrange: 操作符"></p>
<h4 id="16-cache"><a href="#16-cache" class="headerlink" title="16. cache:"></a>16. <strong>cache:</strong></h4><p><strong>作用</strong>：查看搜索引擎缓存的页面版本。<br><strong>示例</strong>：</p>
<ul>
<li><code>cache:www.hao123.com</code></li>
<li>返回结果：<a target="_blank" rel="noopener" href="http://www.hao123.com的缓存版本./">www.hao123.com的缓存版本。</a></li>
</ul>
<p><img src="https://i.imgur.com/VtpQbg0.png" alt="cache: 操作符"></p>
<p>通过这些图解，你可以更直观地理解每个操作符的作用和用法。希望这些信息对你有帮助！</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240608141716536.png" alt="image-20240608141716536"></p>
</li>
</ul>
</li>
</ul>
<h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><p>在Github中，可能会存在源码泄露、AccessKey泄露、密码、服务器配置泄露等情况，常见的搜索技巧有：</p>
<ul>
<li><code>@example.com password/pass/pwd/secret/credentials/token</code></li>
<li><code>@example.com username/user/key/login/ftp/</code></li>
<li><code>@example.com config/ftp/smtp/pop</code></li>
<li><code>@example.com security_credentials/connetionstring</code></li>
<li><code>@example.com JDBC/ssh2_auth_password/send_keys</code></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240608142344463.png" alt="image-20240608142344463"></p>
<h2 id="网盘引擎"><a href="#网盘引擎" class="headerlink" title="网盘引擎"></a>网盘引擎</h2><p>盘多多：<a target="_blank" rel="noopener" href="http://www.panduoduo.top/">http://www.panduoduo.top/</a></p>
<p> UP云搜：<a target="_blank" rel="noopener" href="https://www.upyunso.com/">https://www.upyunso.com/</a></p>
<p>学搜搜：<a target="_blank" rel="noopener" href="https://www.xuesousou.net/">https://www.xuesousou.net/</a></p>
<p>猫狸盘搜：<a target="_blank" rel="noopener" href="https://www.alipansou.com/">https://www.alipansou.com/</a></p>
<p>云盘4K：<a target="_blank" rel="noopener" href="https://www.codelicence.cn/">https://www.codelicence.cn/</a></p>
<p>聚合搜索引擎：<a target="_blank" rel="noopener" href="https://www.xiongbeng.com/">https://www.xiongbeng.com/</a></p>
<h2 id="空间搜索引擎"><a href="#空间搜索引擎" class="headerlink" title="空间搜索引擎"></a>空间搜索引擎</h2><p>FOFA：<a target="_blank" rel="noopener" href="https://fofa.info/">https://fofa.info/</a> 之前被禁用，目前已恢复，但是功能阉割严重</p>
<p>Quake：<a target="_blank" rel="noopener" href="https://quake.360.cn/quake/#/index">https://quake.360.cn/quake/#/index</a></p>
<p>ZoomEye：<a target="_blank" rel="noopener" href="https://www.zoomeye.org/">https://www.zoomeye.org/</a></p>
<p>Shadon：<a target="_blank" rel="noopener" href="https://www.shodan.io/">https://www.shodan.io</a></p>
<p>基础语法：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Vdieoo/article/details/109622838">https://blog.csdn.net/Vdieoo/article/details/109622838</a></p>
<p>切记：<strong>搜索到敏感信息之后，不要随意下载和传播，属于违法行为！应该主动进行报备</strong>。</p>
<h2 id="历史漏洞"><a href="#历史漏洞" class="headerlink" title="历史漏洞"></a>历史漏洞</h2><p><strong>CNVD</strong>：<a target="_blank" rel="noopener" href="https://www.cnvd.org.cn/">https://www.cnvd.org.cn/</a>  </p>
<p><strong>CNNVD</strong>：<a target="_blank" rel="noopener" href="https://www.cnnvd.org.cn/home/childHome">https://www.cnnvd.org.cn/home/childHome</a>  </p>
<p><strong>Seebug</strong>：<a target="_blank" rel="noopener" href="https://www.seebug.org/">https://www.seebug.org</a>  </p>
<p><strong>Exploit</strong> <strong>Database</strong>：<a target="_blank" rel="noopener" href="https://www.exploit-db.com/">https://www.exploit-db.com</a>  </p>
<h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p>微信直接搜索</p>
<p>搜狗：<a target="_blank" rel="noopener" href="https://weixin.sogou.com/">https://weixin.sogou.com</a></p>
<h2 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h2><p>微信直接搜索  </p>
<h2 id="信息深度收集"><a href="#信息深度收集" class="headerlink" title="信息深度收集"></a>信息深度收集</h2><p>指纹识别</p>
<p>火狐插件：Wappalyzer(网站技术嗅探工具）</p>
<p>云悉：<a target="_blank" rel="noopener" href="http://www.yunsee.cn/">http://www.yunsee.cn</a></p>
<p>潮汐：<a target="_blank" rel="noopener" href="http://finger.tidesec.net/">http://finger.tidesec.net/</a></p>
<p>Nuclei：<a target="_blank" rel="noopener" href="https://github.com/projectdiscovery/nuclei">https://github.com/projectdiscovery/nuclei</a> </p>
<p>Whatweb：<a target="_blank" rel="noopener" href="https://morningstarsecurity.com/research/whatweb">https://morningstarsecurity.com/research/whatweb</a></p>
<h1 id="社会工程学"><a href="#社会工程学" class="headerlink" title="社会工程学"></a>社会工程学</h1><h2 id="企业信息收集"><a href="#企业信息收集" class="headerlink" title="企业信息收集"></a>企业信息收集</h2><p>一些网站如天眼查等，可以提供企业关系挖掘、工商信息、商标专利、企业年报等信息查询，可以提供企业的较为细致的信息。</p>
<p>公司主站中会有业务方向、合作单位等信息。</p>
<p>企查查：<a target="_blank" rel="noopener" href="https://www.qichacha.com/">https://www.qichacha.com</a> </p>
<p>天眼查：<a target="_blank" rel="noopener" href="https://www.tianyancha.com/">https://www.tianyancha.com</a> 企业的工程师不一定比白帽子更了解企业自身的状况。 </p>
<h2 id="人员信息收集"><a href="#人员信息收集" class="headerlink" title="人员信息收集"></a>人员信息收集</h2><p>针对人员的信息收集考虑对目标重要人员、组织架构、社会关系的收集和分析。其中重要人员主要指高管、系统管理员、开发、运维、财务、人事、业务人员的个人电脑。</p>
<p>人员信息收集较容易的入口点是网站，网站中可能包含网站的开发、管理维护等人员的信息。从网站联系功能中和代码的注释信息中都可能得到的所有开发及维护人员的姓名和邮件地址及其他联系方式。</p>
<p><strong>在获取这些信息后，可以在Github&#x2F;Linkedin等社交、招聘网站中进一步查找这些人在互联网上发布的与目标站点有关的一切信息，分析并发现有用的信息。</strong></p>
<p>此外，<strong>可以对获取到的邮箱进行密码爆破的操作，获取对应的密码。</strong></p>
<h2 id="钓鱼"><a href="#钓鱼" class="headerlink" title="钓鱼"></a>钓鱼</h2><p>基于之前收集到的信息，可以使用Office&#x2F;CHM&#x2F;RAR&#x2F;EXE&#x2F;快捷方式等文件格式制作钓鱼邮件发送至目标，进一步收集信息。</p>
<p>其中Office可以使用Office漏洞、宏、OLE对象、PPSX等方式构造利用文件。</p>
<p>Exe可以使用特殊的Unicode控制字符如RLO (Right-to-Left Override) 等来构建容易混淆的文件名。</p>
<p>RAR主要是利用自解压等方式来构建恶意文件，同样加密的压缩包也在一定程度上可以逃逸邮件网关的检测。</p>
<p>如果前期信息收集获取到了运维等人员的邮箱，可以使用运维人员的邮箱发送，如果未收集到相关的信息，可以使用伪造发送源的方式发送邮件。</p>
<p>需要注意的是，钓鱼测试也需要注意合规问题，不能冒充监管单位、不能发送违法违规信息。具体可以参考《中华人民共和国电信条例》、《中华人民共和国互联网电子邮件服务管理办法》等法律法规。</p>
<h2 id="其他信息"><a href="#其他信息" class="headerlink" title="其他信息"></a>其他信息</h2><p>公司的公众号、企业号、网站，员工的网盘、百度文库等可能会存在一些敏感信息，如VPN&#x2F;堡垒机账号、TeamViewer账号、网络设备默认口令、服务器默认口令等。</p>
<h1 id="信息收集流程"><a href="#信息收集流程" class="headerlink" title="信息收集流程"></a>信息收集流程</h1><p>表层信息:</p>
<ol>
<li><p><strong>域名,邮箱,注册人,电话,备案号</strong></p>
</li>
<li><p><strong>域名,子域名,旁站</strong></p>
</li>
<li><p><strong>是否真实IP,判断有没有部署CDN</strong></p>
</li>
</ol>
<p>深层信息:</p>
<ol>
<li><strong>指纹识别</strong></li>
</ol>
<h1 id="NMAP"><a href="#NMAP" class="headerlink" title="NMAP"></a>NMAP</h1><p>Nmap（“Network Mapper&lt;网络映射器&gt;”）是一款开放源代码的网络探测和安全审核的工具。它的设计目标是快速扫描大型网络，当然用它扫描单个主机也没有问题。Nmap以新颖的方式使用原始IP报文来发现网络上有哪些主机，这些主机提供什么服务（应用程序名和版本），这些服务运行在什么操作系统中， 它们使用什么类型的报文过滤器&#x2F;防火墙，以及一堆其它功能。虽然Nmap通常用于安全审核，许多系统管理员和网络管理员也用它来做一些日常的工作，比如查看整个网络的信息， 管理服务升级计划，以及监视主机和服务的运行。</p>
<p>Nmap输出的是扫描目标的列表，以及每个目标的补充信息，至于是哪些补充信息则依赖于所使用的选项。通常会列出端口号，协议，服务名称和状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240608112437845.png" alt="image-20240608112437845"></p>
<h2 id="一个典型的Nmap扫描"><a href="#一个典型的Nmap扫描" class="headerlink" title="一个典型的Nmap扫描"></a>一个典型的Nmap扫描</h2><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240608113336508.png" alt="image-20240608113336508"></p>
<p>nmap简介<br>nmap是一款非常强大的主机发现和端口扫描工具，而且nmap运用自带的脚本，还能完成漏洞检测，同时支持多平台。</p>
<p>nmap常用命令<br>主机发现 </p>
<p>iR                                                                随机选择目标</p>
<p>-iL                                                                从文件中加载IP地址</p>
<p>-sL                                                               简单的扫描目标</p>
<p>-sn                                                               Ping扫描-禁用端口扫描</p>
<p>-Pn                                                              将所有主机视为在在线，跳过主机发现</p>
<p>-PS[portlist]                                              （TCP SYN ping） 需要root权限</p>
<p>-PA[portlist]                                              （TCP ACK ping）</p>
<p>-PU[portlist]                                              （UDP  ping）</p>
<p>-PY [portlist]                                             （SCTP ping）</p>
<p>-PE&#x2F;PP&#x2F;PM                                                 ICMP回显，时间戳和网络掩码请求探测</p>
<p>-PO[协议列表]                                            IP协议Ping</p>
<p>-n&#x2F;-R                                                           从不执行DNS解析&#x2F;始终解析[默认：有时]</p>
<p>–dns-servers                                              指定自定义DNS服务器</p>
<p>–system-dns                                              使用OS的dns服务器</p>
<p>–traceroute                                                跟踪到每个主机的跃点路径</p>
<p>扫描技术</p>
<p>-sS                                                             使用TCP的SYN进行扫描</p>
<p>-sT                                                             使用TCP进行扫描</p>
<p>-sA                                                            使用TCP的ACK进行扫描</p>
<p>-sU                                                            UDP扫描</p>
<p>-sI                                                             Idle扫描</p>
<p>-sF                                                            FIN扫描</p>
<p>-b&lt;FTP中继主机&gt;                                     FTP反弹扫描</p>
<p>端口规格和扫描顺序</p>
<p>-p                                                              扫描指定端口</p>
<p>–exclude-ports                                         从扫描中排除指定端口</p>
<p>-f                                                               快速模式-扫描比默认扫描更少的端口</p>
<p>-r                                                               连续扫描端口-不随机化</p>
<p>–top-ports                                                 扫描<number>最常用的端口</p>
<p>服务&#x2F;版本探测</p>
<p>-sV                                                            探测服务&#x2F;版本信息</p>
<p>–version-intensity                                     设置版本扫描强度（0-9）</p>
<p>–version-all                                              尝试每个强度探测</p>
<p>–version-trace                                          显示详细的版本扫描活动（用于调试）</p>
<p>脚本扫描</p>
<p>-SC                                                           等效于 –script&#x3D;defult</p>
<p>–script &#x3D; <lua scripts>,<lua scripts>        以逗号分隔的目录，脚本文件或脚本类别</p>
<p>–script-args &#x3D; &lt;n1&#x3D;v1, n2&#x3D;v2&gt;               为脚本提供参数</p>
<p>–script-args-file&#x3D;文件名                          从文件名中加载脚本参数</p>
<p>–script-trace                                            显示发送和接受的所有数据</p>
<p>–script-updatedb                                     更新脚本数据库</p>
<p>–script-help&#x3D;<lua scripts>                      显示有关脚本的帮助</p>
<p>操作系统检测</p>
<p>-o                                                            启用os检测</p>
<p>–osscan-limit                                          将os检测限制为可能的目标</p>
<p>–osscan-guess                                       推测操作系统检测结果</p>
<p>时间和性能</p>
<p>–host-timeout                                         设置超时时间</p>
<p>–scan-delay                                           设置探测之间的时间间隔</p>
<p>-T  &lt;0-5&gt;                                                设置时间模板,值越小，IDS报警几率越低</p>
<p>防火墙&#x2F;IDS规避和欺骗</p>
<p>-f                                                             报文分段</p>
<p>-s                                                             欺骗源地址</p>
<p>-g                                                            使用指定的本机端口</p>
<p>–proxies &lt;url,port&gt;                                 使用HTTP&#x2F;SOCK4代理</p>
<p>-data<hex string>                                   想发送的数据包中追加自定义的负载</p>
<p>–data-string                                            将自定义的ACSII字符串附加到发送数据包中   </p>
<p>–data-length                                           发送数据包时，附加随机数据</p>
<p>–spoof-mac                                            MAC地址欺骗</p>
<p>–badsum                                                发送带有虚假TCP&#x2F;UNP&#x2F;STCP校验和的数据包</p>
<p>输出</p>
<p>-oN                                                         标准输出</p>
<p>-oX                                                         XMl输出</p>
<p>-oS                                                         script jlddi3</p>
<p>-oG                                                        grepable</p>
<p>-oA                                                         同时输出三种主要格式</p>
<p>-v                                                           信息详细级别</p>
<p>-d                                                           调试级别</p>
<p>–packet-trace                                        跟踪发送和接收的报文</p>
<p>–reason                                                 显示端口处于特殊状态的原因</p>
<p>–open                                                    仅显示开放的端口</p>
<p>杂项</p>
<p>-6                                                          启动Ipv6扫描</p>
<p>-A                                                          启动Os检测，版本检测，脚本扫描和traceroute</p>
<p>-V                                                          显示版本号</p>
<p>-h                                                          帮助信息</p>
<h2 id="端口扫描目标"><a href="#端口扫描目标" class="headerlink" title="端口扫描目标"></a>端口扫描目标</h2><p>除了nmap选项，所有出现在Nmap命令行上的内容都被视为对目标主机的说明。最简单的情况是指定一个目标IP地址或主机名。</p>
<p>有时候我们希望<strong>扫描整个网络的相邻主机</strong>。为此，Nmap支持CIDR风格的地址。可以附加一个&#x2F;在一个IP地址或主机名后面， Nmap将会扫描所有和该参考IP地址具有 相同比特的所有IP地址或主机。 <strong>例如， 192.168.10.0&#x2F;24将会扫描192.168.10.0 (二进制格式: 11000000 10101000 00001010 00000000)和192.168.10.255 (二进制格式: 11000000 10101000 00001010 11111111)之间的256台主机。</strong></p>
<p>192.168.10.40&#x2F;24 代表同样的意义</p>
<p>假设主机scanme.nmap.org的<strong>IP地址是205.217.153.62</strong>,scanme.nmap.org&#x2F;16 将扫描205.217.0.0和205.217.255.255之间的65,536 个IP地址。 <strong>所允许的最小值是&#x2F;1， 这将会扫描半个互联网。最大值是&#x2F;32，这将会扫描该主机或IP地址， 因为所有的比特都固定了</strong>  </p>
<p>假设主机scanme.nmap.org的IP地址是205.217.153.62，scanme.nmap.org&#x2F;16 将扫描205.217.0.0和205.217.255.255之间的65,536 个IP地址。 所允许的最小值是&#x2F;1， 这将会扫描半个互联网。最大值是&#x2F;32，这将会扫描该主机或IP地址， 因为所有的比特都固定了  </p>
<p><strong>IPv6地址只能用规范的IPv6地址或主机名指定。 CIDR 和八位字节范围不支持IPv6，因为它们对于IPv6几乎没什么用。</strong></p>
<p>Nmap命令行接受多个主机说明，它们不必是相同类型，如：nmap scanme.nmap.org 192.168.0.0&#x2F;8 10.0.0.1</p>
<p>虽然目标通常在命令行指定，下列选项也可用来控制目标的选择：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240608112813496.png" alt="image-20240608112813496"></p>
<h2 id="主机发现（思考一下可以用来做什么？）"><a href="#主机发现（思考一下可以用来做什么？）" class="headerlink" title="主机发现（思考一下可以用来做什么？）"></a>主机发现（思考一下可以用来做什么？）</h2><p>任何网络探测任务的最初几个步骤之一就是把一组IP范围（有时该范围是巨大的）缩小为一列活动的或 者感兴趣的主机。扫描每个IP的每个端口很慢，通常也没必要。 当然，什么样的主机令您感兴趣主要依 赖于扫描的目的。网管也许只对运行特定服务的主机感兴趣，而从事安全的人员则可能对每一个主机都 感兴趣，只要它有IP地址:-)。一个系统管理员也许仅仅使用Ping来定位内网上的主机，而一个外部入侵 测试人员则可能绞尽脑汁用各种方法试图突破防火墙的封锁。</p>
<p>由于主机发现的需求五花八门，Nmap提供了一箩筐的选项来定制需求。主机发现有时候也叫做ping扫 描，但它远超越世人皆知的ping工具发送简单的ICMP回声请求报文。用户完全可以通过使用列表扫描(- sL)或者通过关闭ping (-P0)跳过ping的步骤，也可以使用多个端口把TCP SYN&#x2F;ACK，UDP和ICMP 任意组 合起来玩一玩。这些探测的目的是获得响应以显示某个IP地址是否是活动的（正在被某主机或者网络设 备使用）。在许多网络上，在给定的时间，往往只有小部分的IP地址是活动的。这种情况在私有地址空间如10.0.0.0&#x2F;8尤其普遍。私有网络有16,000,000个IP，<strong>但一些使用它的公司连1000台机器都没有。主 机发现能够找到零星分布于IP地址海洋上的机器。</strong></p>
<p>如果没有给出主机发现的选项，Nmap 就发送一个TCP ACK报文到80端口和一个ICMP回声请求到每台目 标机器。 一个例外是ARP扫描用于局域网上的任何目标机器。对于非特权UNIX shell用户，使用 connect()系统调用会发送一个SYN报文而不是ACK。这些默认行为和使用-PA -PE选项的效果相同。 扫描 局域网时，这种主机发现一般够用了，但是对于安全审核，建议进行更加全面的探测。</p>
<p>-P选项（用于选择ping的类型）可以被结合使用，可以通过使用不同的TCP端口&#x2F;标志位和ICMP码发送许 多探测报文来增加穿透防守严密的防火墙的机会。另外要注意的是即使指定了其它 -P*选项，ARP发现(- PR)对于局域网上的目标而言是默认行为，因为它总是更快更有效。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240608113001057.png" alt="image-20240608113001057"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240608113012283.png" alt="image-20240608113012283"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240608113022813.png" alt="image-20240608113022813"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240608113038109.png" alt="image-20240608113038109"></p>
<h2 id="端口扫描基础"><a href="#端口扫描基础" class="headerlink" title="端口扫描基础"></a><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240608113046355.png" alt="image-20240608113046355">端口扫描基础</h2><p>虽然Nmap这些年来功能越来越多，但它最初也是从一个端口扫描器开始的，并且这仍然是它的核心功 能。 nmap **这个简单的命令会扫描主机上的超过1660个TCP端口。许多传统的端口扫描器只列出所有 端口是开放还是关闭的，Nmap的信息粒度比它们要细得多。它把端口分成六个状态: open(开放的)， closed(关闭的)，filtered(被过滤的)， unfiltered(未被过滤的)， open|filtered(开放或者被过滤的)，或 者 closed|filtered(关闭或者被过滤的)。</p>
<p><strong>这些状态并非端口本身的性质，而是描述Nmap怎样看待它们。例如，对于同样的目标机器的135&#x2F;tcp端 口，从同网络扫描显示它是开放的，而跨网络进行完全相同的扫描则可能显示它是filtered(被过滤的).</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240608113146628.png" alt="image-20240608113146628"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240608113153000.png" alt="image-20240608113153000"></p>
<h2 id="端口扫描技术"><a href="#端口扫描技术" class="headerlink" title="端口扫描技术"></a>端口扫描技术</h2><p>大部分扫描类型只对特权用户可用，这是因为他们发送接收原始报文，在Unix系统需要root权限。在Windows上推荐使用administrator账户，但是当WinPcap已经被加载到操作系统时，非特权用户也可以正常使用Nmap。当Nmap在1997年发布时，需要root权限是一个严重的局限，因为很多用户只有共享的shell账户。现在，世界变了，计算机便宜了，更多人拥有互联网连接 ，桌面UNIX系统 (包括Linux和MAC OS X)很普遍了。Windows版本的Nmap现在也有了，这使它可以运行在更多的桌面上。 由于所有这些原因，用户不再需要用有限的共享shell账户运行Nmap。 这是很幸运的，因为特权选项让Nmap强大得多也灵活得多。</p>
<p>虽然Nmap努力产生正确的结果，但请记住所有结果都是基于目标机器(或者它们前面的防火墙)返回的报文的。这些主机也许是不值得信任的，它们可能响应以迷惑或误导Nmap的报文。 更普遍的是非RFC兼容的主机以不正确的方式响应Nmap探测，FIN，Null和Xmas扫描特别容易遇到这个问题，这些是特定扫描类型的问题。</p>
<p>这一节讨论Nmap支持的大约十几种扫描技术。一般一次只用一种方法，除了UDP扫描(-sU)可能和任何一种TCP扫描类型结合使用。友情提示一下，端口扫描类型的选项格式是-s， 其中是个显眼的字符，通常是第一个字符，一个例外是deprecated FTP bounce扫描(-b)。默认情况下，Nmap执行一个SYN扫描，但是如果用户没有权限发送原始报文(在UNIX上需要root权限)或者如果指定的是IPv6目标，Nmap调用connect()。本节列出的扫描中，非特权用户只能执行connect()和ftp bounce扫描</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240608114250340.png" alt="image-20240608114250340"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240608114259668.png" alt="image-20240608114259668"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240608114311915.png" alt="image-20240608114311915"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240608114327336.png" alt="image-20240608114327336"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240608114347555.png" alt="image-20240608114347555"></p>
<h2 id="端口说明和扫描顺序"><a href="#端口说明和扫描顺序" class="headerlink" title="端口说明和扫描顺序"></a>端口说明和扫描顺序</h2><p>除了所有前面讨论的扫描方法， Nmap提供选项说明哪些端口被扫描以及扫描是随机还是顺序进行。 默认情况下，Nmap用指定的协议对端口 1~1024 以及 nmap-services 文件中列出的更高的端口进行扫描。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240608114424923.png" alt="image-20240608114424923"></p>
<p>把Nmap指向一个远程机器，它可能告诉您端口25&#x2F;tcp，80&#x2F;tcp，和53&#x2F;udp是开放的，使用包含大约2,200个著名的服务的nmap-services数据库。Nmap可以报告哪些端口可能分别对应于一个邮件服务器 (SMTP)，web服务器(HTTP)，和域名服务器(DNS)。这种查询通常是正确的。事实上，绝大多数在TCP端口25监听的守护进程是邮件服务器。然而，您不应该把赌注押在这上面！管理员完全可以在一些奇怪的端口上运行服务。</p>
<p>即使Nmap是对的，假设运行服务的确实是 SMTP，HTTP和DNS，那也不是特别多的信息。 当为您的公司或者客户作安全评估(或者甚至简单的网络明细清单)时，您确实想知道正在运行什么邮件和域名服务器以及它们的版本，有一个精确的版本号对了解服务器有什么漏洞有巨大帮助，版本探测可以帮您获得该信息。</p>
<p>在用某种其它类型的扫描方法发现TCP 和&#x2F;或者UDP端口后，版本探测会询问这些端口，确定到底什么服务正在运行。nmap-service-probes 数据库包含查询不同服务的探测报文和解析识别响应的匹配表达式。Nmap试图确定服务协议 (如 ftp，ssh，telnet，http)，应用程序名(如ISC Bind，Apache httpd， Solaris telnetd)，版本号，主机名，设备类型(如打印机，路由器)，操作系统 (如Windows，Linux)以及其它的细节，如是否可以连接X server，SSH协议版本，或者KaZaA用户名。当然，并非所有服务都提供所有这些信息。 如果Nmap被编译成支持OpenSSL，它将连接到SSL服务器，推测什么服务在加密层后面监听。当发现RPC服务时，Nmap RPC grinder (-sR)会自动被用于确定RPC程序和它的版本号。如果在扫描某个UDP端口后仍然无法确定该端口是开放的还是被过滤的，那么该端口状态就被标记为open|filtered。 版本探测将试图从这些端口引发一个响应(就像它对开放端口做的一样)， 如果成功，就把状态改为开放。open|filtered TCP端口用同样的方法对待。注意Nmap -A选项在其它情况下打开版本探测。有一篇关于版本探测的原理，使用文章在<a target="_blank" rel="noopener" href="http://www.insecure.org/nmap/vscan/">http://www.insecure.org/nmap/vscan/</a></p>
<p>当Nmap从某个服务收到响应，但不能在数据库中找到匹配时，它就打印一个特殊的fingerprint和一个URL给您提交。如果您知道什么服务运行在端口，请花两分钟提交您的发现，让每个人受益。由于这些提交，Nmap有350种以上协议，如smtp，ftp，http等大约3,000条模式匹配。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240608114513196.png" alt="image-20240608114513196"></p>
<h2 id="操作系统探测"><a href="#操作系统探测" class="headerlink" title="操作系统探测"></a>操作系统探测</h2><p>Nmap最著名的功能之一是用TCP&#x2F;IP协议栈fingerprinting进行远程操作系统探测。Nmap发送一系列TCP和UDP报文到远程主机，检查响应中的每一个比特。在进行一打测试如TCP ISN采样、TCP选项支持和排序、IPID采样和初始窗口大小检查之后，Nmap把结果和数据库nmap-os-fingerprints中超过1500个已知的操作系统的fingerprints进行比较，如果有匹配，就打印出操作系统的详细信息。 每个fingerprint包括一个自由格式的关于OS的描述文本和一个分类信息，它提供供应商名称(如Sun)，下面的操作系统(如Solaris)，OS版本(如10)，设备类型(通用设备，路由器，switch，游戏控制台等)</p>
<p>。</p>
<p>如果</p>
<p>Nmap不能猜出操作系统，并且有些好的已知条件(如至少发现了一个开放端口和一个关闭端口)， Nmap会提供一个URL，如果您确知运行的操作系统，您可以把fingerprint提交到那个URL。这样您就扩大了Nmap的操作系统知识库，从而让每个Nmap用户都受益。</p>
<p>操作系统检测可以进行其它一些测试，这些测试可以利用处理过程中收集到的信息。例如运行时间检测，使用TCP时间戳选项(RFC 1323) 来估计主机上次重启的时间，这仅适用于提供这类信息的主机。另一种是TCP序列号预测分类，用于测试针对远程主机建立一个伪造的TCP连接的可能难度。这对于利用基于源IP地址的可信关系(rlogin，防火墙过滤等) 或者隐含源地址的攻击非常重要。这一类欺骗攻击现在很少见，但一些主机仍然存在这方面的漏洞。实际的难度值基于统计采样，因此可能会有一些波动。通常采用英国的分类较好，如“worthy challenge”或者 “trivial joke”。在详细模式(-v)下只以普通的方式输出，如果同时使用-O，还报告IPID序列产生号。很多主机的序列号是“增加”类别，即在每个发送包的IP头中增加ID域值， 这对一些先进的信息收集和欺骗攻击来说是个漏洞</p>
<p><a target="_blank" rel="noopener" href="http://nmap.org/book/osdetect.html">http://nmap.org/book/osdetect.html</a> 文档使用多种语言描述了版本检测的方式、使用和定制  </p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240608114609507.png" alt="image-20240608114609507"></p>
<h2 id="时间和性能"><a href="#时间和性能" class="headerlink" title="时间和性能"></a>时间和性能</h2><p>Nmap开发的最高优先级是性能。在本地网络对一个主机的默认扫描(nmap **)需要0.2秒，而仅仅眨眼的时间，就可以扫描上万甚至几十万的主机。此外，一些特定的扫描选项会明显增加扫描时间，如UDP扫描和版本检测。同样，防火墙配置以及特殊的响应速度限制也会增加时间。Nmap使用了并行算法和许多先进的算法来加速扫描，用户对Nmap如何工作有最终的控制权。高级用户可以仔细地调整Nmap命令，在满足时间要求的同时获得他们所关心的信息  </p>
<p>改善扫描时间的技术有：忽略非关键的检测、升级最新版本的Nmap(性能增强不断改善)。 优化时间参数也会带来实质性的变化，这些参数如下。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240608114651328.png" alt="image-20240608114651328"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240608114703908.png" alt="image-20240608114703908"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240608114712037.png" alt="image-20240608114712037"></p>
<h2 id="防火墙-IDS躲避和欺骗"><a href="#防火墙-IDS躲避和欺骗" class="headerlink" title="防火墙&#x2F;IDS躲避和欺骗"></a>防火墙&#x2F;IDS躲避和欺骗</h2><p>很多Internet先驱们设想了一个全球开放的网络，使用全局的IP地址空间，使得任何两个节点之间都有虚拟连接，这使得主机间可以作为真正的对等体，相互间提供服务和获取信息。</p>
<p>然而，这些全球连接的设想受到了地址空间短缺和安全考虑的限制。在90年代早期，各种机构开始部署防火墙来实现减少连接的目的，大型网络通过代理、NAT和包过滤器与未过滤的Internet隔离。不受限的信息流被严格控制的可信通信通道信息流所替代。</p>
<p>类似防火墙的网络隔离使得对网络的搜索更加困难，随意的搜索变得不再简单。然而，Nmap提供了很多特性用于理解这些复杂的网络，并且检验这些过滤器是否正常工作。此外，Nmap提供了绕过某些较弱的防范机制的手段。检验网络安全状态最有效的方法之一是尝试欺骗网络，将自己想象成一个攻击者，使用本节提供的技术来攻击自己的网络。如使用FTP bounce扫描、Idle扫描、分片攻击或尝试穿透自己的代理。</p>
<p>有时也会出现不同的意见，比如建议Nmap不应该提供躲闭防火墙规则或欺骗IDS的功能， 这些功能可能会被攻击者滥用，然而管理员却可以利用这些功能来增强安全性。实际上，即便是关闭Nmap绕过或者欺骗的功能，其他的攻击方法仍可被攻击者利用，他们可以发现其它工具或Nmap的补丁程序。同时，管理员发现攻击者的工作更加困难，相较于采取措施来预防执行FTP Bounce攻击的工具而言，部署先进的、打过补丁的FTP服务器更加有效。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240608114904271.png" alt="image-20240608114904271"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240608114952078.png" alt="image-20240608114952078"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240608114959829.png" alt="image-20240608114959829"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240608115029119.png" alt="image-20240608115029119"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240608115036669.png" alt="image-20240608115036669"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240608115042227.png" alt="image-20240608115042227"></p>
<p><strong>探测目录的过程中要时常维护字典</strong></p>
<h1 id="盲打平台"><a href="#盲打平台" class="headerlink" title="盲打平台"></a>盲打平台</h1><p><a target="_blank" rel="noopener" href="http://www.dnslog.cn/">www.dnslog.cn</a></p>
<p>在构造的payload中使被控制服务器访问该平台,如果有回显则证明成功控制.</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44029310/article/details/125694514">Web—信息收集(非常全)_web info hunter-CSDN博客</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/source/categories/Penetration-Testing-Basic/">Penetration Testing Basic</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/source/tags/pr0gram/">pr0gram</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2024/07/09/vscode和html，javascript和Docker/"><span>更底层更方便的一些部署</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/07/09/vscode和html，javascript和Docker/" rel="bookmark">
        <time class="entry-date published" datetime="2024-07-09T01:06:05.172Z">
          2024-07-09
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>WARNING ：<strong>请先有一定的linux命令基础再接触并进行部署</strong></p>
<h1 id="WHAT-IS-蜜罐"><a href="#WHAT-IS-蜜罐" class="headerlink" title="WHAT IS 蜜罐"></a>WHAT IS 蜜罐</h1><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240512091639288.png" alt="image-20240512091639288"></p>
<p>蜜罐是一种安全威胁的主动防御技术，<strong>它通过模拟一个或多个易受攻击的主机或服务来吸引攻击者，捕获攻击流量与样本，发现网络威胁、提取威胁特征，</strong>蜜罐的价值在于被探测、攻陷。其在本质上来说，<strong>是一个与攻击者进行攻防博弈的过程。</strong>蜜罐提供服务，攻击者提供访问，通过蜜罐对攻击者的吸引，攻击者对蜜罐进行攻击，在攻击的过程中，有经验的攻击者也可能识别出目标是一个蜜罐。为此，<strong>为更好的吸引攻击者，蜜罐也需要提供强悍的攻击诱骗能力。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240512092050232.png" alt="image-20240512092050232"></p>
<h1 id="Web服务中间件"><a href="#Web服务中间件" class="headerlink" title="Web服务中间件"></a><strong>Web服务中间件</strong></h1><p>类似Apache  Tomcat  Nginx将用户的HTTP请求解析，并返回到浏览器</p>
<h1 id="钓鱼网站制作"><a href="#钓鱼网站制作" class="headerlink" title="钓鱼网站制作"></a>钓鱼网站制作</h1><p>ctrl+s保存当前全部静态网页 并本地部署</p>
<p><strong>开始测试 打开本地网站发包</strong> </p>
<p>观察自身请求 <strong>可以发送请求后打开F12</strong></p>
<p>然后<strong>点击network并观察对应路径名–即可知请求发向文件</strong></p>
<p><strong>全局检索对应路径 然后直接替换接收数据文件</strong></p>
<h1 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h1><p><a target="_blank" rel="noopener" href="https://www.runoob.com/js/js-tutorial.html">JavaScript 教程 | 菜鸟教程 (runoob.com)</a></p>
<p>不会就查就行了</p>
<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p><a target="_blank" rel="noopener" href="https://docker-practice.github.io/zh-cn/">前言 · Docker – 从入门到实践 (docker-practice.github.io)</a></p>
<p>Docker是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任意一个搭载windows或者linux的机器上</p>
<p><strong>也可以实现虚拟化，容器完全使用沙箱机制，相互之间并无接口</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240525111213269.png" alt="image-20240525111213269"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240525111358970.png" alt="image-20240525111358970"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240525111550258.png" alt="image-20240525111550258"></p>
<h2 id="更新kali-apt源"><a href="#更新kali-apt源" class="headerlink" title="更新kali apt源"></a>更新kali apt源</h2><p>编辑 &#x2F;etc&#x2F;apt&#x2F;sources.list 文件， 在文件最前面添加以下条目：</p>
<p>**#**<strong>中科大稳定版分支</strong> <strong>Kali</strong> <strong>源</strong> </p>
<p>deb <a target="_blank" rel="noopener" href="https://mirrors.ustc.edu.cn/kali">https://mirrors.ustc.edu.cn/kali</a> kali-rolling main non-free non-free-firmware contrib</p>
<p>deb-src <a target="_blank" rel="noopener" href="https://mirrors.ustc.edu.cn/kali">https://mirrors.ustc.edu.cn/kali</a> kali-rolling main non-free non-free-firmware contrib</p>
<p>sudo nano &#x2F;etc&#x2F;apt&#x2F;sources.list</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/12790161/1716608995166-e9089a93-d685-4257-bb94-0822a054dd55.png" alt="img"></p>
<p>sudo apt update</p>
<h2 id="Linux安装docker"><a href="#Linux安装docker" class="headerlink" title="Linux安装docker"></a>Linux安装docker</h2><p>以kali 2024.1 为例，安装docker</p>
<h3 id="添加使用-HTTPS-传输的软件包以及-CA-证书"><a href="#添加使用-HTTPS-传输的软件包以及-CA-证书" class="headerlink" title="添加使用 HTTPS 传输的软件包以及 CA 证书"></a>添加使用 HTTPS 传输的软件包以及 CA 证书</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install \</span><br><span class="line">     apt-transport-https \</span><br><span class="line">     ca-certificates \</span><br><span class="line">     curl \</span><br><span class="line">     gnupg \</span><br><span class="line">     lsb-release</span><br></pre></td></tr></table></figure>

<h3 id="添加软件源的-GPG-密钥"><a href="#添加软件源的-GPG-密钥" class="headerlink" title="添加软件源的 GPG 密钥"></a>添加软件源的 GPG 密钥</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br></pre></td></tr></table></figure>

<h3 id="sources-list-中添加-Docker-软件源"><a href="#sources-list-中添加-Docker-软件源" class="headerlink" title="sources.list 中添加 Docker 软件源"></a>sources.list 中添加 Docker 软件源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/debian \</span></span><br><span class="line"><span class="string">  buster stable&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></pre></td></tr></table></figure>

<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line">$ sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure>

<p>如果无需体验最新版的docker，也可以直接执行下面命令安装</p>
<p>apt install docker.io</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://docker-practice.github.io/zh-cn/install/debian.html">https://docker-practice.github.io/zh-cn/install/debian.html</a></p>
<h3 id="Docker部署"><a href="#Docker部署" class="headerlink" title="Docker部署"></a><strong>Docker部署</strong></h3><p><a target="_blank" rel="noopener" href="https://hub.docker.com/?_gl=1*1k7v6iz*_ga*MTg4MjkxMTk4MS4xNzE2NjA3NDU1*_ga_XJWPQMJYHQ*MTcxNjYxODY3OC4yLjEuMTcxNjYxODY5Ni40Mi4wLjA.">Dockerhub</a></p>
<h2 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h2><h4 id="三件套"><a href="#三件套" class="headerlink" title="三件套"></a><strong>三件套</strong></h4><p>docker search 寻找想要的镜像 同时可以标签筛选</p>
<p>docker pull 拉取想要的镜像</p>
<p>docker run 运行镜像</p>
<p>docker stop {container id}</p>
<p><strong>查看对应容器信息</strong></p>
<p>docker ps </p>
<p><em>里面就有包含</em></p>
<h4 id="删除对应镜像"><a href="#删除对应镜像" class="headerlink" title="删除对应镜像"></a>删除对应镜像</h4><p>docker rmi {container id}</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240525144321937.png" alt="image-20240525144321937"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240525151120882.png" alt="image-20240525151120882"></p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-command-manual.html">Docker 命令大全 | 菜鸟教程 (runoob.com)</a></p>
<p><strong>创建镜像后能做什么</strong> <strong>镜像的特性是什么</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240529201943078.png" alt="image-20240529201943078"></p>
<h1 id="VS-Code-Remote-ssh-远程控制Windows主机-免密登录-内网穿透"><a href="#VS-Code-Remote-ssh-远程控制Windows主机-免密登录-内网穿透" class="headerlink" title="VS Code Remote-ssh 远程控制Windows主机 + 免密登录 + 内网穿透"></a>VS Code Remote-ssh 远程控制Windows主机 + 免密登录 + 内网穿透</h1><h2 id="VS-Code-Remote-ssh-远程控制Windows主机-免密登录-内网穿透-1"><a href="#VS-Code-Remote-ssh-远程控制Windows主机-免密登录-内网穿透-1" class="headerlink" title="VS Code Remote-ssh 远程控制Windows主机 + 免密登录 + 内网穿透"></a>VS Code Remote-ssh 远程控制Windows主机 + 免密登录 + 内网穿透</h2><p>1 我们为什么需要远程连接服务器？（使用需求+场景）<br>炼丹的研究生：在我们炼丹过程中，经常需要连接远程的服务器（通常是实验室的服务器）进行炼丹。通常情况下，我们会使用Pycharm的远程开发功能，同步服务器与本地的项目文件，使用远程解释器进行开发。但是使用过的同学都知道，重量级的Pycharm每次远程同步、加载远程解释器都需要相当长的时间。如果我们想要随时切换工位、宿舍、家里的各个场景，Pycharm的同步、加载就成了一场噩梦。特别是当我们的python环境安装了很多依赖包，项目生成了大量文件的时候更是这样。<strong>直到VS Code推出了Remote Development开发包，便完全解决了这个问题。让我可以在不同的场景快速切换，无需等待同步文件、环境。</strong>因为VS Code远程开发完全是运行在服务器上的，我们本地的VS Code只是一个前端界面，所以<strong>根本无需同步服务器上的文件</strong>、解释器依赖库就可以体验到与本地开发完全相同的体验。在远程连接服务器后，只需要使用可以随身携带的笔记本进行Coding，而炼丹就交由服务器来完成。优雅！<br>2 远程办公：<strong>将自己的台式机当成一个服务器在服务器上训练&#x2F;测试模型。这样自己远程办公时，可以通过ssh远程连接到自己的台式机在公司开会时，用笔记本远程连接自己的台式机</strong><br>3 以上只是列举出来的一些常见的使用场景，但具体到每个人都是不尽相同的，但是需求都是相似的——优化我们的工作流。</p>
<h2 id="为什么需要内网穿透？"><a href="#为什么需要内网穿透？" class="headerlink" title="为什么需要内网穿透？"></a>为什么需要内网穿透？</h2><p>通常<strong>服务器是在一个局域网下的，没有公网ip，需要通过局域网内的NAT</strong>（Network Address Translation）讲局域网内的私有IP地址转换为公网IP才能正常通信。如果想要远程连接，要么和服务器处在同一个局域网下，但这通常限制了我们使用场景，如果离开这个局域网，就没法远程开发了。因此需要内网穿透，解决处于使用了NAT设备的私有TCP&#x2F;IP网络中的主机之间建立连接的问题。但是如果你有公网IP，就没有这么多b事了。但是99%的可能你都没有公网IP，其中的原因也比较简单，公网IP地址是一种稀缺的有限的资源，而Internet是老美搞的，简单讲有人多了，就一定会有人少了，就得通各种各样的方式来提高我们为数不多的公网IP地址的利用率，以满足我国人民日益增长的上网需求doge。<br>什么是内网穿透？<br>内网穿透是一种网络技术，它允许在私有局域网（内网）中的设备或服务可以通过公共网络（如互联网）进行访问。通常情况下，内网设备由于NAT 设备屏蔽或防火墙等网络设备所保护，无法直接从公网访问。通过使用内网穿透技术，可以建立起公网和内网之间的通道，使得外部用户可以通过公网连接到内网中的设备，就像这些设备直接连接在公网上一样。内网穿透简单来说就是<strong>将内网外网通过隧道打通,让内网的数据让外网可以获取</strong>。</p>
<h3 id="什么是SSH？"><a href="#什么是SSH？" class="headerlink" title="什么是SSH？"></a>什么是SSH？</h3><p>安全外壳协议（Secure Shell Protocol，简称SSH）<strong>是一种运行在应用层的（默认端口号为22）加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境。</strong>SSH通过在网络中建立安全隧道来实现SSH客户端与服务器之间的连接。最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。SSH最常见的用途是远程登录系统，人们通常利用SSH来传输命令行界面和远程执行命令。SSH使用频率最高的场合是类Unix系统，但是Windows操作系统也能有限度地使用SSH。<strong>2015年，微软宣布将在未来的操作系统中提供原生SSH协议支持，Windows 10 1803版本已提供OpenSSH工具。</strong><br>SSH以非对称加密实现身份验证。身份验证有多种途径：</p>
<p>其中一种方法是使用自<strong>动生成的公钥-私钥对来简单地加密网络连接，随后使用密码认证进行登录</strong>；<br>另一种方法是<strong>人工生成一对公钥和私钥，通过生成的密钥进行认证，这样就可以在不输入密码的情况下登录。任何人都可以自行生成密钥。</strong>公钥需要放在待访问的电脑之中，而对应的私钥需要由用户自行保管。认证过程基于生成出来的私钥，但整个认证过程中私钥本身不会传输到网络中。其中公钥用于让对方加密信息，而自己的私钥可以解密经过自己公钥加密后的信息，这就是非对称加密。</p>
<p>SSH以非对称加密实现身份验证。身份验证有多种途径：</p>
<p>其中一种方法是使用自动生成的公钥-私钥对来简单地加密网络连接，随后使用密码认证进行登录；<br>另一种方法是人工生成一对公钥和私钥，通过生成的密钥进行认证，这样就可以在不输入密码的情况下登录。任何人都可以自行生成密钥。公钥需要放在待访问的电脑之中，而对应的私钥需要由用户自行保管。认证过程基于生成出来的私钥，但整个认证过程中私钥本身不会传输到网络中。其中公钥用于让对方加密信息，而自己的私钥可以解密经过自己公钥加密后的信息，这就是非对称加密。</p>
<h3 id="SSH远程连接之后能干什么？"><a href="#SSH远程连接之后能干什么？" class="headerlink" title="SSH远程连接之后能干什么？"></a>SSH远程连接之后能干什么？</h3><p>SSH远程连接之后，就可以像操作本地的机器一样操作远程机器。当需要操控的机器不在本地时就可以使用ssh协议远程连接操控。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240606153525709.png" alt="image-20240606153525709"></p>
<p><strong>在Powershell（管理员）中确保添加了防火墙规则</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">在Powershell（管理员）中确保添加了防火墙规则</span><br><span class="line"></span><br><span class="line"># 启动sshd服务</span><br><span class="line">Start-Service sshd</span><br><span class="line"></span><br><span class="line"># 将sshd服务设置为自动启动，若不设置需要在每次重启后重新开启sshd</span><br><span class="line">Set-Service -Name sshd -StartupType &#x27;Automatic&#x27;</span><br><span class="line"></span><br><span class="line"># 确认防火墙规则，一般在安装时会配置好</span><br><span class="line">Get-NetFirewallRule -Name *ssh*</span><br><span class="line"></span><br><span class="line"># 若安装时未添加防火墙规则&quot;OpenSSH-Server-In-TCP&quot;，则通过以下命令添加</span><br><span class="line">New-NetFirewallRule -Name sshd -DisplayName &#x27;OpenSSH Server (sshd)&#x27; -Enabled True -Direction Inbound -Protocol TCP -Action Allow -LocalPort 22</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二步：连接到 OpenSSH 服务器<br><strong>在第一次连接之前，我们先来了解两个概念</strong>：<strong>username和servername&#x2F;hostname。在windows的SSH服务器中也就是在你的远程主机中</strong></p>
<p>username可以用你激活电脑时使用的用户名，即文件资源管理器中C:\Users\username的username。<br>而servername则是“设置”&gt;“系统”&gt;“关于”里的“设备名称”<br>其中输入密码应该是你的远程主机的开机密码，并且这一次连接应该确保是在同一网络下进行的，因为我们并没有进行内网穿透操作</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240606154856346.png" alt="image-20240606154856346"></p>
<p><strong>如果你成果的看到了以下输出，恭喜你成功的连接上了你的远程主机，并且已经成功了一大半了。接下来我们去VS Code中连接，操作都是类似的。</strong></p>
<h3 id="在VS-Code中连接你的远程主机"><a href="#在VS-Code中连接你的远程主机" class="headerlink" title="在VS Code中连接你的远程主机"></a>在VS Code中连接你的远程主机</h3><p>这部分内容遵循VS Code的官方教程，但在此基础上做了精简，官方教程写的好的部分会直接贴出来。这一次的连接同样应该确保是在同一网络下进行的，因为我们并没有进行内网穿透操作。<br><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240606155050660.png" alt="image-20240606155050660"></p>
<h1 id="Vscode远程连接Docker"><a href="#Vscode远程连接Docker" class="headerlink" title="Vscode远程连接Docker"></a>Vscode远程连接<strong>Docker</strong></h1><p>Author ：探姬</p>
<p>原文于语雀发布，地址为：<a target="_blank" rel="noopener" href="https://www.yuque.com/probius/cs_wp/fegz0w">https://www.yuque.com/probius/cs_wp/fegz0w</a></p>
<p>本文也有配套视频，建议结合食用：(给个三连吧www)</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1684y1z7L6">https://www.bilibili.com/video/BV1684y1z7L6</a></p>
<h2 id="About"><a href="#About" class="headerlink" title="About"></a>About</h2><p>本文档完整的流程可以帮助您在<strong>Kali Linux</strong>上完成Docker环境，并且基于Vscode的Remote功能，利用SSH协议，构建 VSCODE + SSH + Docker 的工作流，提高效率。</p>
<p>同样，本文档也考虑了非Kali，用于开发&#x2F;生产环境的 <strong>Ubuntu &#x2F; Debian</strong> 系统 ，如果您想要在开发&#x2F;生产中使用该工作流，可以直接从<strong>Get Docker</strong> 或者 <strong>Build SSH＋vscode + docker Workflow</strong> 章节开始。</p>
<p>笔者水平有限，错误疏漏之处在所难免，烦请各位师傅斧正。</p>
<p>以及非常感谢 <strong>陈橘墨(@<strong>Randark_JMT</strong>)师傅</strong>提供的帮助。</p>
<h2 id="Get-Kali"><a href="#Get-Kali" class="headerlink" title="Get Kali"></a>Get Kali</h2><h3 id="Download"><a href="#Download" class="headerlink" title="Download"></a>Download</h3><p>在Kali官网下载即可，建议直接下载封装好的虚拟机版本：</p>
<p><a target="_blank" rel="noopener" href="https://www.kali.org/get-kali/#kali-virtual-machines">https://www.kali.org/get-kali/#kali-virtual-machines</a></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665941610725-938968ad-7947-4e8b-9030-e3758268b763.png" alt="img"></p>
<p>解压下载好的压缩包到您想要放置虚拟机的位置，然后双击配置文件直接打开自动添加，或者在VMware中手动添加：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665941724211-28de32c3-f423-4a93-9834-e73779c30df1.png" alt="img"></p>
<p>添加完成后，启动即可：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665941756080-5769f591-f33d-4acb-bc6d-d3e6b05d214f.png" alt="img"></p>
<p>（当然，作为DockerRuner，您可能需要设置一个稍微大点的内存值）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665941814497-37c98101-8d6b-4c1d-80c1-a63fc7952de8.png" alt="img"></p>
<h3 id="ChangeResource？"><a href="#ChangeResource？" class="headerlink" title="ChangeResource？"></a>ChangeResource？</h3><p>笔者并不建议换源，Kali官方源的速度还是不错的，换源可能会导致您软件管理出现问题。</p>
<h1 id="虚拟机迁移发现远程连接消失"><a href="#虚拟机迁移发现远程连接消失" class="headerlink" title="虚拟机迁移发现远程连接消失?"></a>虚拟机迁移发现远程连接消失?</h1><p>VM虚拟机移动后IP修改，要做一些什么操作，就可以在自己电脑上使用了<br>第一步：我们打开虚拟机<br>你要在虚拟机文件的里面打开你创建保存的虚拟机文件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240609004828634.png" alt="image-20240609004828634"></p>
<p>打开后是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240609004907612.png" alt="image-20240609004907612"></p>
<p>你可以打开并且允许虚拟机了，但是他就是连不上xshell，这个是问题是你的那个虚拟编辑器上面的网关和xshell之前的网关不一样，所以他就连接不上。<br>打开虚拟编辑器</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240609004921035.png" alt="image-20240609004921035"><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240609004934951.png" alt="image-20240609004934951"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240609004955897.png" alt="image-20240609004955897"></p>
<p>看看上面箭头的有没有钩选上。其中将主机虚拟机适配器连接到网络和使用本地DHCP必须选择上，不然你的虚拟机就是另外一个问题。</p>
<p>记住自己的子网ip:192.168.xxx.xxx</p>
<p>我们先:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 dhclient  自己获取IP的一个命令</span><br><span class="line">2 然后 ip add</span><br><span class="line">3 查看自动获取的ip地址</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240609005029453.png" alt="image-20240609005029453"></p>
<p>我们输入下面这个可以修改网关的ip的命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 vi /etc/sysconfig/network-scripts/ifcfg-ens33</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240609005049558.png" alt="image-20240609005049558"></p>
<p>上这个图片是和7有个参考，如果你是拷贝其他人的虚拟机，就改那个IPADDR就行，因为，其他的别人都改好的。</p>
<p>IPPADDR，我们最好改成我们刚刚ip add 自动获取的那个ip.</p>
<p>改好后我们保存退出：</p>
<p>按esc wq保存退出：</p>
<p>下面我们开始重新启动网卡：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 systemctl restart network.service</span><br><span class="line">2 如果这个命令不行就用：service network restart 重新启动网关</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>重新启动后面，我们就再</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 ip add</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>后面，我试试虚拟机连接网络：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure>







<h2 id="Get-Docker"><a href="#Get-Docker" class="headerlink" title="Get Docker"></a>Get Docker</h2><h3 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h3><p>docker安装目前有两个版本，一个是官方的<strong>docker.ce</strong>版本，一个是有Debian团队维护的<strong>docker.io</strong>版本。</p>
<p>之前有争议说 docker.io 是旧版本的docker 而新版的docker是 dockers.ce</p>
<p>然而docker.io的版本有时会比docker.ce高，事实上，两者只是负责维护的组织不同，前者是Debian官方维护，后者则为Docker官方维护，并没后新旧之分：</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/45023363/what-is-docker-io-in-relation-to-docker-ce-and-docker-ee-now-called-mirantis-k">https://stackoverflow.com/questions/45023363/what-is-docker-io-in-relation-to-docker-ce-and-docker-ee-now-called-mirantis-k</a></p>
<h4 id="docker-io"><a href="#docker-io" class="headerlink" title="docker.io"></a>docker.io</h4><p>该版本由Debian团队维护，采用 apt 的方式管理依赖</p>
<p>安装过程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665991778767-3780c1b4-c778-4896-b0eb-70651e627778.png" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install docker.io</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665991813089-2477e73a-9650-4eae-b3b4-0f338801b331.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665991905446-84b04c96-1d8d-46b7-a569-945ed7041921.png" alt="img"></p>
<h4 id="docker-ce"><a href="#docker-ce" class="headerlink" title="docker.ce"></a>docker.ce</h4><p> 由docker官方维护的版本，采用 go 的方式管理依赖，如果您要在开发&#x2F;生产环境中使用docker，推荐使用该版本。</p>
<p>如果您的Linux版本为Ubuntu&#x2F;Debian，可以使用一下命令自动安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO- https://get.docker.com/ | sh</span><br></pre></td></tr></table></figure>

<p>（注意，Docker并不支持Kali一键安装，同样笔者也不推荐您用kali作为开发生产环境，Kali满足日常需要，使用io版本即可，当然您也可以使用.ce版本的手动安装）</p>
<p>手动安装：</p>
<p>可以参考Docker官方的 Docker Engine安装步骤：</p>
<p><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/debian/">https://docs.docker.com/engine/install/debian/</a></p>
<p>但是该步骤在 Kali Linux上面可能会存在一定问题，以Kali为例，完整的按照流程如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg \</span><br><span class="line">    lsb-release</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666080331410-5ec0dec8-2032-404b-82a4-ae31e0ad436d.png" alt="img"></p>
<p>选项选择Yes就好。</p>
<p>然后按照官网提示，添加Docker官方的 GPG key：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/apt/keyrings</span><br><span class="line">curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span><br></pre></td></tr></table></figure>

<p>然后设置仓库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=<span class="subst">$(dpkg --print-architecture)</span> signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian \</span></span><br><span class="line"><span class="string">  <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></pre></td></tr></table></figure>

<p>然后开始安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure>

<p>随后，如果您是Kali Linux，您可能会遭遇以下报错：</p>
<p><a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/630643/how-to-install-docker-ce-in-kali-linux">How to install docker-ce in kali-linux?</a></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666080964792-ad4bf959-2049-4979-9924-48c11bc2641d.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666080978683-d1a1900c-fea3-4134-b2cb-98ed2d2c5a42.png" alt="img"></p>
<p>这是由于Docker官方并没有提供直接支持Kali的源，所以我们使用Debian的源就好：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%s\n&quot;</span> <span class="string">&quot;deb [arch=amd64] https://download.docker.com/linux/debian buster stable&quot;</span> |\</span><br><span class="line">sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/docker-ce.list</span><br></pre></td></tr></table></figure>

<p>并且添加对应的密钥：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure>

<p>注意不要忘了给密钥相应权限：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chmod</span> a+r /etc/apt/keyrings/docker.gpg</span><br></pre></td></tr></table></figure>

<p>此时再跑一次 <code>sudo apt-get update</code>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<p>您可能会遇到一个找不到的源，这个是正常的。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666081542730-3abaa686-0c14-4ee9-835b-c9244e7a601c.png" alt="img"></p>
<p>接下来安装docker：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure>

<p>就能正常获取了：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666081606647-ba60b180-36d3-4d71-9696-63ff6fb0068f.png" alt="img"></p>
<p>安装完成后，执行hello-world，得到图示则安装成功。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666083076099-29da6da2-2c69-4862-a93b-0d343b5e78f7.png" alt="img"></p>
<h3 id="DockerHub"><a href="#DockerHub" class="headerlink" title="DockerHub"></a>DockerHub</h3><p><a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<p>尝试登录您的<code>**DockerHub**</code>账号：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665992062442-9121927b-e352-4d24-8494-e073942e856a.png" alt="img"></p>
<p>如果出现类似错误，请手动配置DNS：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/resolv.conf</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665992104653-95449c6a-2e19-49a3-8ccc-f57ecf3b0b93.png" alt="img"></p>
<p>保存，再次尝试即可成功登录：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665992136237-ce188b31-9008-4375-95ef-f06d4ac013a7.png" alt="img"></p>
<h2 id="Build-SSH＋vscode-docker-Workflow"><a href="#Build-SSH＋vscode-docker-Workflow" class="headerlink" title="Build SSH＋vscode + docker Workflow"></a>Build SSH＋vscode + docker Workflow</h2><p>该步骤适用于支持SSH协议的Linux（废话，哪个Linux没有个SSH），除了在本地的Kali或者其他Linux上面构建，也支持远程构建该工作流。</p>
<h3 id="Start-SSH-Service"><a href="#Start-SSH-Service" class="headerlink" title="Start SSH Service"></a>Start SSH Service</h3><h4 id="Kali-Linux"><a href="#Kali-Linux" class="headerlink" title="Kali Linux"></a>Kali Linux</h4><p>Kali虚拟机默认是没有开启ssh服务的 （ssh状态：<code>/etc/init.d/ssh status</code>）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665992570893-88f65a45-ca5e-4295-a9fb-932fc2f9db2f.png" alt="img"></p>
<p>所以需要手动启动一下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/ssh start </span><br></pre></td></tr></table></figure>

<p>当然，为了方便，我们将ssh添加到开机自启中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo update-rc.d ssh <span class="built_in">enable</span></span><br><span class="line"><span class="comment"># Or use:</span></span><br><span class="line">systemctl <span class="built_in">enable</span> ssh.service</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665992653697-a499a2eb-da24-435e-87f3-4fda32a2669d.png" alt="img"></p>
<p>启动之后就可以开始后面的步骤了。</p>
<h4 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h4><p>由于ubuntu默认不自带openssh-server，所以这里需要手动安装。</p>
<p>安装openssh-server：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure>

<p>安装完成后启动服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service ssh start</span><br></pre></td></tr></table></figure>

<h3 id="Get-Remote-SSH"><a href="#Get-Remote-SSH" class="headerlink" title="Get Remote - SSH"></a>Get Remote - SSH</h3><p>为了使用vscode的远程ssh功能 您可能需要在扩展中安装<code> Remote - SSH</code>插件：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666002987439-4e307846-0b99-4578-9b54-ddd628aefd77.png" alt="img"></p>
<h3 id="Let-Vscode-Connect-to-host"><a href="#Let-Vscode-Connect-to-host" class="headerlink" title="Let Vscode Connect to host"></a>Let Vscode Connect to host</h3><p>连接方式有两种：<code>密码连接</code> 和 <code>ssh的公私钥</code>。</p>
<p>一般情况下我们使用密码连接，这样的方法安全性较低，而且每次连接和每次切换目录的时候都会要求输入密码，所以在确保能够密码连接情况下，我们可以进一步使用公私钥验证的方式来提升安全性和优化操作友好性。</p>
<h4 id="Using-password-connection"><a href="#Using-password-connection" class="headerlink" title="Using password connection"></a>Using password connection</h4><p>打开vscode，点击左下角的远程连接（绿色的部分）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665992886788-3aa8ff94-7d9f-461a-a1fb-4e108cffd83d.png" alt="img"></p>
<p>接着在弹出的窗口中选择 Connect to Host</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665992849406-4490a1c9-c017-4952-9930-c7845e7efd7e.png" alt="img"></p>
<p>选择 <code>Add New SSH Host</code>：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665992979730-8b19217b-f803-4298-8537-fcd5af749130.png" alt="img"></p>
<p>按照要求输入对应的指令：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665993031322-111547cb-b185-4ca5-a767-e8c3ee49506f.png" alt="img"></p>
<p>IP可通过 <code>ip a</code> 获取</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665993103994-c44e4858-ef69-45d9-9b5d-38150e83f710.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh kali@192.168.28.145 -A</span><br></pre></td></tr></table></figure>

<p>保存位置默认第一个就好：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665993185976-069830bf-af5d-4a79-9a1d-3958e9b99274.png" alt="img"></p>
<p>然后连接：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665993196349-e231aea3-bdd0-422d-b475-c4669252a75d.png" alt="img"></p>
<p>选择对应的系统：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665993227789-8b0ec6b0-d9eb-4bcb-b0fd-94368350a908.png" alt="img"></p>
<p>选择继续：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665993257173-dfc7b2ab-a5ee-4821-9e7e-3a7af8ac7cc7.png" alt="img"></p>
<p>输入密码：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665993277058-231f6520-9afc-4375-9bf4-7c42f1718163.png" alt="img"></p>
<p>初始化完成后就连接上了：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665993334466-214c5073-08fc-4492-9674-29b9e6e8fff3.png" alt="img"></p>
<h4 id="Using-public-and-private-keys"><a href="#Using-public-and-private-keys" class="headerlink" title="Using public and private keys"></a>Using public and private keys</h4><h5 id="Create-public-and-private-keys"><a href="#Create-public-and-private-keys" class="headerlink" title="Create public and private keys"></a>Create public and private keys</h5><p>首先在本机上生成对应的公钥私钥：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666022363207-1faad277-da27-4d65-9a77-7f65f22cc0d3.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter file in which to save the key (C:\Users\Probius/.ssh/id_rsa):</span><br></pre></td></tr></table></figure>

<p>输入保存路径，如果为空默认为 <code>C:\Users\USERNAME/.ssh/id_rsa</code>，这里笔者直接输入了名字，让其以该名字直接保存在当前目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase):</span><br></pre></td></tr></table></figure>

<p>输入私钥密码，为空则没有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter same passphrase again:</span><br></pre></td></tr></table></figure>

<p>注意：如果您使用了私钥密码，那么在进行ssh登录的时候，会提示您输入私钥密码，相当于再使用公私钥登录的情况下又加了一层密码，安全性有很大的提升，但是这样会变得和密码登录一样每次都要输入，这里笔者建议，如果是本地一路回车就好了，如果是远程资源的管理，可以综合安全性考虑</p>
<p>生成过后，得到的<code>id_rsa.pub</code>(Kali_test.pub)是<strong>公钥</strong>，<code>id_rsa</code>(Kali_test)是<strong>私钥</strong> </p>
<p>将得到的私钥放在我们的.ssh(C:\Users\USERNAME.ssh)中。</p>
<p>(您也可以在生成的时候就让他防止在此，当然这并不是重点）</p>
<h5 id="Configuring-Remote-Host"><a href="#Configuring-Remote-Host" class="headerlink" title="Configuring Remote Host"></a>Configuring Remote Host</h5><p>将得到的公钥上传到 Kali&#x2F;服务器中对应用户的.ssh文件夹中(请确保该文件夹至少有700的权限)：</p>
<p>（注意 kali默认没有该文件夹，需要用户手动创建，并且赋700权限 <code>mkdir ~/.ssh</code> ）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666023486280-3163a1ad-2809-44a8-a9e2-a8f29b452de3.png" alt="img"></p>
<p>在此处打开终端，用公钥文件来生成 authorized_keys：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> id_ras.pub &gt;&gt; authorized_keys</span><br><span class="line"><span class="comment"># 此处既 cat Kali_test.pub &gt;&gt; authorized_keys</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666023722693-73b3cecc-1273-4a42-88f8-9ed336a90588.png" alt="img"></p>
<p>由于Linux系统对.ssh拥有比较严格的权限限制，请确保权限配置正确：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chmod</span> 600 authorized_keys</span><br><span class="line">sudo <span class="built_in">chmod</span> 700 ~/.ssh</span><br></pre></td></tr></table></figure>

<p>编辑ssh配置文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>

<p>确保拥有以下条目：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RSAAuthentication <span class="built_in">yes</span></span><br><span class="line">PubkeyAuthentication <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>

<p>注意Kali的ssh默认配置是没有上诉两项的，需要自行添加：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666026484050-a32d3cb9-76dc-4635-bfa1-087cc833ee2d.png" alt="img"></p>
<p>然后搞定一切后 重启SSH服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service ssh restart</span><br></pre></td></tr></table></figure>

<p>Linux部分的配置这样就搞定啦~</p>
<p>（在您确保您的连接无误后，如果是服务器等远程设备，可以在config中关闭密码登录以提升安全性：</p>
<p><code>PasswordAuthentication no</code>）</p>
<h5 id="Configuring-Local-Host"><a href="#Configuring-Local-Host" class="headerlink" title="Configuring Local Host"></a>Configuring Local Host</h5><p>然后是Windows，也就是vscode这边的配置：</p>
<p>添加NewHost：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666028378220-501e16a9-549c-4312-8afd-3e73b559abe5.png" alt="img"></p>
<p>使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh USERNAME@IP -i C:\\Users\\Probius\\.ssh\\RAS_ID</span><br></pre></td></tr></table></figure>

<p>（注意使用指令添加时，务必使用双斜杠）</p>
<p>当然，也可以在已经添加的配置文件上改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host 192.168.28.145</span><br><span class="line">	HostName 192.168.28.145</span><br><span class="line">	User kali</span><br><span class="line">	IdentityFile C:\Users\Probius\.ssh\Kali_test</span><br></pre></td></tr></table></figure>

<p>如果操作无误，且没有设置私钥密码，那么点击连接之后无需其他额外操作即可连接；如果设置了私钥密码，那么按照提示输入即可。</p>
<h5 id="Other-About-SSH-key-login"><a href="#Other-About-SSH-key-login" class="headerlink" title="Other_About SSH key login"></a>Other_About SSH key login</h5><p>关于ssh密钥登录的更多知识可以看这一篇文章：</p>
<p><a target="_blank" rel="noopener" href="https://wangdoc.com/ssh/key.html">https://wangdoc.com/ssh/key.html</a></p>
<h3 id="Get-The-Docker-Extension"><a href="#Get-The-Docker-Extension" class="headerlink" title="Get The Docker Extension"></a>Get The Docker Extension</h3><h4 id="Install-extension"><a href="#Install-extension" class="headerlink" title="Install extension"></a>Install extension</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665993503285-4cad91c3-c5be-42f1-949b-b06dd63b3dce.png" alt="img"></p>
<p>（当然 如果显示的是 <code>安装</code>也是一样的）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665993640582-33e0292d-1a01-4a4e-bdb4-5052a3cc658d.png" alt="img"></p>
<h4 id="Solve-error"><a href="#Solve-error" class="headerlink" title="Solve error"></a>Solve error</h4><p>如果您使用自动安装，应该不会遇到该问题，自动安装的sh会自动完成用户组添加的操作。</p>
<p>由于权限原因，我们可能无法访问到  <code>/var/run/docker.sock</code></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666085731016-37a5a8a0-770c-4759-ac00-4c124fcd5165.png" alt="img"></p>
<h5 id="By-add-user-group"><a href="#By-add-user-group" class="headerlink" title="By add user group"></a>By add user group</h5><p>一劳永逸的解决权限问题，将当前用户组添加到docker组即可。</p>
<p>创建docker用户组，默认安装时就会自动创建，所以执行可能会显示<code>exist</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd docker </span><br></pre></td></tr></table></figure>

<p>添加当前用户到该组：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker <span class="variable">$&#123;USER&#125;</span> </span><br></pre></td></tr></table></figure>

<p>然后重新启动容器服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart docker </span><br></pre></td></tr></table></figure>

<p>再次重新登入即可，如果重新登录之后依旧报错无法读取，请尝试重启：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>

<h5 id="By-chmod"><a href="#By-chmod" class="headerlink" title="By chmod"></a>By chmod</h5><p>也可以使用<code> sudo chmod 777 /var/run/docker.sock</code>，但是每次重启之后权限都会重置，不推荐</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665993792130-55218849-ff43-4565-8b31-b7a7d81a99f6.png" alt="img"></p>
<p>然后就能正常访问了：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665993848043-242f6244-7db2-4cd0-bfe4-5f1c5456ce0b.png" alt="img"></p>
<h3 id="Start-Use"><a href="#Start-Use" class="headerlink" title="Start Use"></a>Start Use</h3><p>（以下操作使用<strong>DockerHub</strong>演示）</p>
<p>因为在安装Docker的时候登录过DockerHub所以这里连接之后，系统会自动获取您的凭证，您可以在这查看您的DockerHub仓库：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665994063185-82918af8-46ea-43a3-a524-f5a66280d2b2.png" alt="img"></p>
<p>当然，您也可以添加其他仓库，具体的用法可以参考官方文档：</p>
<p><a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/containers/quickstart-container-registries">https://code.visualstudio.com/docs/containers/quickstart-container-registries</a></p>
<h4 id="Pull-Image"><a href="#Pull-Image" class="headerlink" title="Pull Image"></a>Pull Image</h4><p>当然 对于自己仓库的镜像还是比较方便的233：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665995599834-3c92a723-9476-43d9-aa8f-9553055a3403.png" alt="img"></p>
<p>当然如果是公开镜像的话 还是免不了指令啦，不过还是比较方便的，旁边就是终端：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665995757090-9bd04c4b-fb0b-47a1-b96c-c6393e110ba4.png" alt="img"></p>
<p>完成之后就能在IMAGES栏看到了：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665995915572-4b40f768-d4d5-4f32-a536-ffadb2421c86.png" alt="img"></p>
<h4 id="Run-Docker"><a href="#Run-Docker" class="headerlink" title="Run Docker"></a>Run Docker</h4><p>运行容器有两个选项Run &#x2F; Run Ineractive</p>
<h5 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h5><p>默认后台运行，Run执行后效果和在Linux执行 -d的效果相同：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666116092112-5dc775b4-197e-48b1-a345-3bde2132a8ac.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665997253030-26e1cb0b-0014-4c19-b2e6-f219945e510a.png" alt="img"></p>
<h5 id="Run-Interacitve"><a href="#Run-Interacitve" class="headerlink" title="Run Interacitve"></a>Run Interacitve</h5><p>该选项运行执行后，除了运行容器，还会跳到容器的汇总shell处，这里会实时打印容器日志，</p>
<p>效果和 <code>View Log</code>效果相同：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666116324737-328fd245-853d-416c-acf7-6adfd5f1e7e3.png" alt="img"></p>
<h4 id="View-Log"><a href="#View-Log" class="headerlink" title="View Log"></a>View Log</h4><p>直达容器后台日志，如果在运行的时候选择<code>Run Interacitve</code>那么也会跳转到该log页面。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665998996602-944ea384-cf80-4711-9989-b937c4bd02a6.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665999366319-2a41bc0f-4f89-4b63-9cd5-253b54bcd031.png" alt="img"></p>
<h4 id="Attach-Shell"><a href="#Attach-Shell" class="headerlink" title="Attach Shell"></a>Attach Shell</h4><p>右键选中之后可以直接建立一个容器内部的shell，省去<code>docker exec -i -t  ID /bin/bash</code></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665998911154-243825b7-d7be-47fa-9a30-214d7591f75f.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665999322527-061fab7c-02b4-471c-92bd-b64a716ee583.png" alt="img"></p>
<h4 id="Edit-Container"><a href="#Edit-Container" class="headerlink" title="Edit Container"></a>Edit Container</h4><p>在CONTAINERS中下拉一个容器的file可以对其进行查看和编辑：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665997210054-cc018f63-7e66-4201-a27c-2aa6c78d7b0a.png" alt="img"></p>
<p>可以看到对于容器来说 修改是即时的（支持热更新的）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665997987509-8642ebda-72c7-45a8-b2f4-9e1ef04ac2da.png" alt="img"></p>
<h4 id="Attach-Container（Advanced-Edit？）"><a href="#Attach-Container（Advanced-Edit？）" class="headerlink" title="Attach Container（Advanced Edit？）"></a>Attach Container（Advanced Edit？）</h4><p>我们也可以用Vscode建立类似SSH的连接，直接连接到整个容器：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665998467833-cf59f140-9f33-43c1-a2b2-c635c6662598.png" alt="img"></p>
<p>并且操作同步：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665998565856-6d6953de-1afd-4a98-b99f-a9076387a9b3.png" alt="img"></p>
<p>而且容器支持文件拖拽，相比单纯的COPY指令 拥有更好的体验（个人感觉</p>
<h4 id="Port-Forward"><a href="#Port-Forward" class="headerlink" title="Port Forward"></a>Port Forward</h4><p>通过SSH直接将远程端口转发到本地，免除防火墙困扰ww</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665999460970-c81a131d-6712-4ab9-9b30-d0fd0084a6cb.png" alt="img"></p>
<p>一般来讲在您启动容器的时候 vscode会自动配置 当然为了更好的区分和避免冲突 也可以手动分配</p>
<p>配置如图：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666000511669-34c924ab-ac4a-42d5-92cb-8b658afe39f1.png" alt="img"></p>
<h4 id="Open-in-Borrow"><a href="#Open-in-Borrow" class="headerlink" title="Open in Borrow"></a>Open in Borrow</h4><p>如果您配置完成了端口转发(或者vscode自动为您完成配置）那么点击Open in Borrow将在您的默认浏览器中快速打开该端口对应的页面：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666117172873-9d4b7fb4-574d-426d-8dd3-b62b5c1b71e1.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666117247770-7b5c5b4c-a8f9-4c70-9bdc-61b21790fb28.png" alt="img"></p>
<h4 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h4><p>其他用法，就请佬们自行探索啦ww</p>
<h2 id="ExtensionRecommend"><a href="#ExtensionRecommend" class="headerlink" title="ExtensionRecommend"></a>ExtensionRecommend</h2><h3 id="Thunder-Client"><a href="#Thunder-Client" class="headerlink" title="Thunder Client"></a>Thunder Client</h3><p>Thunder Client is a lightweight Rest API Client Extension for Visual Studio Code, hand-crafted by Ranga Vadhineni with simple and clean design.</p>
<p>要注意的是 该插件基于远程运行（既本体在虚拟机&#x2F;服务器上），在测试的时候请确保url指向正确。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666002204613-bd552d8b-851a-4528-baf0-fbe018d7ad51.png" alt="img"></p>
<h1 id="win11虚拟机部署pikachu"><a href="#win11虚拟机部署pikachu" class="headerlink" title="win11虚拟机部署pikachu"></a>win11虚拟机部署pikachu</h1><p>Phpstudy，Phpstorm，pikachu、外加的话浏览器别太老。<br>Phpstudy：<a target="_blank" rel="noopener" href="https://www.xp.cn/">https://www.xp.cn/</a><br>Phpstorm：<a target="_blank" rel="noopener" href="https://www.jetbrains.com/zh-cn/phpstorm/">https://www.jetbrains.com/zh-cn/phpstorm/</a><br>pikachu：<a target="_blank" rel="noopener" href="https://github.com/zhuifengshaonianhanlu/pikachu">https://github.com/zhuifengshaonianhanlu/pikachu</a></p>
<p>这里我并没有一步一步截图，因为碰壁很多次，所以，我将针对我所遇到的问题以及解决方法展开阐述，仅供参考。<br>1、win11本机搭建步骤</p>
<p>1、安装Phpstudy以及Phpstorm软件，并启动apacha以及mysql<br><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240530151311289.png" alt="image-20240530151311289"><br>其实，这里一个版本就行。</p>
<p>2、这下去pikachu的那个文件进行把mysql的root密码写进去，这里如果你的密码不是初始密码root的话，那么这里则需要修改两个Php中的密码：</p>
<p>3、修改密码</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240530151238531.png" alt="image-20240530151238531"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240530151250834.png" alt="image-20240530151250834"></p>
<p>4、ctrl+c以及ctrl+v将修改之后的pikachu文件放在phpstudy安装之后文件夹的www文件目录中；</p>
<p>5、修改完之后我就又碰见了问题四，也就是执行127.0.0.1&#x2F;pikachu之后报错<br>说有个文件的14行有错误。详见问题四：</p>
<p>6、直接进入浏览器输入127.0.0.1&#x2F;pikachu<br><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240530151224015.png" alt="image-20240530151224015"><br>7、当然，这里是win主机搭建的靶机，而且即使到这一步依旧没有结束<br>因为还要进行安装初始化：<br>所以，在URL输入框中，我们输入127.0.0.1&#x2F;pikachu&#x2F;install.php<br>然后回车就可以看到安装以及初始化了：<br><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240530151158114.png" alt="image-20240530151158114"><br>我所碰见的问题以及解决方式：</p>
<p>1、文件打不开，也就是pikachu的那个ins配置文件直接打不开，这个我觉得和电脑以及环境有关，我使用的是win11，之前win10还没碰见过这种情况：<br>解决方式：<br>这里我采用的是直接关机重启，这里注意进程，最好别有什么系统程序执行</p>
<p>2、至于上面pikachu配置文件更改，也就是给那个里面写入root的密码，双击那个文件直接卡住的情况：<br>解决方式：<br>这里直接打开Phpstorm软件进行选中文件打开，这里自己找到文件的路径进行打开。<br>这里路径不好找？可以去搜everthing官网进行下载（搜索文件很快）。<br><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240530150821979.png" alt="image-20240530150821979"></p>
<p>3、主机与虚拟机win2012进行连接实现文件传输达不到，使用moba以及winSCP都无法连接到，那么文件该如何传输到虚拟机中？<br><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240530150808530.png" alt="image-20240530150808530"><br>解决方式：<br>这里用到了VMware tools，首先，我们将win2012先关闭客户机：<br>然后点击编辑虚拟机设置——&gt;选项——&gt;共享文件夹<br><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240530150759674.png" alt="image-20240530150759674">这里创建一个共享文件夹实现本机与win2012的文件互通。</p>
<p>4、这里浏览器输出127.0.0.1&#x2F;pikachu的图像，这里报错了，很明显可以看到是mysql的密码导致的错误，可这里并没有出错，两个文件都配置的是root用户名以及root密码：<br>解决方式：<br>这里在小皮也就是Phpstudy中添加创建一个数据库：<br><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240530150749344.png" alt="image-20240530150749344"><br>点击上面的创建数据库，如果出现了root密码未修改，那么一修改，然后继续创建数据库，同样设置6位以上的密码，没什么讲究的。这下即可成功进入靶场。</p>
<p>5、我进行安装以及初始化之后，浏览器中改变URL之后回车，链接后面便加上一个#号，同时界面是一个固定的界面，不能进行跳转界面：<br>解决方法：<br>嗯······我当时使用的是win2012的浏览器，这里换个浏览器重新在虚拟机访问127.0.0.1&#x2F;pikachu便好······没什么技术要求，以及在本机访问中，也就不会出现这样的情况了。</p>
<p>好了，pikachu靶场搭建就分享到这，希望能帮到各位。<br>————————————————</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_63172698/article/details/131498908">https://blog.csdn.net/weixin_63172698/article/details/131498908</a></p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p><a target="_blank" rel="noopener" href="https://www.runoob.com/mysql/mysql-tutorial.html">MySQL 教程 | 菜鸟教程 (runoob.com)</a></p>
<p>可以使用phpstudy自带的sql_front或navicat通过pikachu数据库进行一系列实践</p>
<p>或者我之前的个人笔记也有的</p>
<h1 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h1><h2 id="Docker网络理论"><a href="#Docker网络理论" class="headerlink" title="Docker网络理论"></a>Docker网络理论</h2><p>容器网络实际上是<strong>由Docker为应用程序所创造的虚拟环境的一部分，它能够使应用从宿主机操作系统的网络系统中独立出来。</strong>形成容器自有的网络设备、IP 协议栈、端口套接字、IP 路由表、防火墙等等与网络相关的模块。</p>
<h3 id="CNM"><a href="#CNM" class="headerlink" title="CNM"></a><strong>CNM</strong></h3><p>Docker 网络架构采用的设计规范是 CNM（Container Network Model）：<strong>CNM 中规定了 Docker 网络的基础组成要素：Sandbox、Endpoint、Network。如图所示，</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240604004145261.png" alt="image-20240604004145261"></p>
<ul>
<li>Sandbox，提供了<strong>容器的虚拟网络栈</strong>，也即端口套接字、IP 路由表、防火墙、DNS 配置等内容。<strong>主要用于隔离容器网络与宿主机网络</strong>，形成了完全独立的容器网络环境。</li>
<li>Network，Docker 内部的虚拟子网，网络内的参与者相互可见并能够进行通讯。<strong>Docker 的虚拟网路和宿主机网络是存在隔离关系的，其目的主要是形成容器间的安全通讯环境。</strong></li>
<li>Endpoint，<strong>就是虚拟网络的接口</strong>，就像普通网络接口一样，Endpoint 的主要职责是<strong>负责创建连接。在 CNM 中，终端负责将沙盒连接到网络。</strong>个人理解：Endpoint 与常见的网络适配器类似，也就意味着 Endpoint 只能接入某一个网络。<strong>因此，如果容器需要接入到多个网络，就需要多个 Endpoint。</strong></li>
</ul>
<h3 id="Libnetwork"><a href="#Libnetwork" class="headerlink" title="Libnetwork"></a><strong>Libnetwork</strong></h3><p>Libnetwork 是 CNM 的标准实现。Libnetwork 是开源库，采用 Go 语言编写（跨平台的），也是 Docker 所使用的库，Docker 网络架构的核心代码都在这个库中。</p>
<h2 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a><strong>驱动</strong></h2><p>“驱动”在计算机和电子设备领域中，通常指的是设备驱动程序（Device Driver），是一种特殊的软件程序，负责控制硬件设备的操作并与操作系统进行通信。<strong>驱动程序充当硬件与操作系统或应用程序之间的中介，</strong>使得软件可以通过标准化的接口与硬件设备进行交互，而无需了解硬件设备的具体实现细节。</p>
<h3 id="驱动的主要功能"><a href="#驱动的主要功能" class="headerlink" title="驱动的主要功能"></a>驱动的主要功能</h3><ol>
<li><p><strong>硬件初始化</strong>：</p>
<ul>
<li>驱动程序在设备启动时初始化硬件，使其处于可以正常工作的状态。</li>
</ul>
</li>
<li><p><strong>中断处理</strong>：</p>
<ul>
<li>处理来自硬件设备的中断信号，并将相应的信息传递给操作系统或应用程序。</li>
</ul>
</li>
<li><p><strong>数据传输</strong>：</p>
<ul>
<li>管理硬件设备的数据传输，包括读取和写入操作。比如，从硬盘读取数据或向打印机发送打印作业。</li>
</ul>
</li>
<li><p><strong>提供接口</strong>：</p>
<ul>
<li>提供标准化的接口，使得操作系统和应用程序能够通过统一的方法访问硬件设备的功能。</li>
</ul>
</li>
</ol>
<h3 id="驱动程序的类型"><a href="#驱动程序的类型" class="headerlink" title="驱动程序的类型"></a>驱动程序的类型</h3><p>驱动程序可以根据不同的设备类型进行分类，以下是一些常见的驱动程序类型：</p>
<ol>
<li><p><strong>设备驱动程序</strong>：</p>
<ul>
<li>控制特定硬件设备的驱动程序，如键盘、鼠标、打印机、硬盘等。</li>
</ul>
</li>
<li><p><strong>内核驱动程序</strong>：</p>
<ul>
<li>运行在操作系统内核中的驱动程序，<strong>提供低级别的硬件控制和管理。</strong></li>
</ul>
</li>
<li><p><strong>文件系统驱动程序</strong>：</p>
<ul>
<li>负责管理文件系统的驱动程序，使得操作系统能够读取和写入存储设备上的文件。</li>
</ul>
</li>
<li><p><strong>网络驱动程序</strong>：</p>
<ul>
<li>管理网络接口卡（NIC）或其他网络设备的驱动程序，负责网络通信和数据传输。</li>
</ul>
</li>
</ol>
<h3 id="驱动程序的安装与更新"><a href="#驱动程序的安装与更新" class="headerlink" title="驱动程序的安装与更新"></a>驱动程序的安装与更新</h3><p>驱动程序通常由硬件设备制造商提供，可以通过以下几种方式安装和更新：</p>
<ol>
<li><p><strong>操作系统自带</strong>：</p>
<ul>
<li>操作系统通常自带一些常用硬件设备的驱动程序，安装操作系统时会自动安装这些驱动程序。</li>
</ul>
</li>
<li><p><strong>设备制造商提供</strong>：</p>
<ul>
<li>硬件设备通常附带驱动程序安装光盘或下载链接，用户可以通过制造商的网站下载最新的驱动程序。</li>
</ul>
</li>
<li><p><strong>自动更新</strong>：</p>
<ul>
<li>现代操作系统（如Windows Update）提供自动更新功能，可以自动检测并安装最新的驱动程序。</li>
</ul>
</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以下是一些具体的驱动程序示例：</p>
<ol>
<li><p><strong>显卡驱动程序（Graphics Driver）</strong>：</p>
<ul>
<li>控制显卡硬件，提供图形显示和渲染功能。例如，NVIDIA或AMD提供的显卡驱动程序。</li>
</ul>
</li>
<li><p><strong>声卡驱动程序（Audio Driver）</strong>：</p>
<ul>
<li>控制声卡硬件，提供音频输入和输出功能。例如，Realtek声卡驱动程序。</li>
</ul>
</li>
<li><p><strong>网络适配器驱动程序（Network Adapter Driver）</strong>：</p>
<ul>
<li>控制网络适配器硬件，提供网络连接和数据传输功能。例如，Intel或Broadcom网络适配器驱动程序。</li>
</ul>
</li>
</ol>
<h3 id="驱动程序的工作原理"><a href="#驱动程序的工作原理" class="headerlink" title="驱动程序的工作原理"></a>驱动程序的工作原理</h3><p>驱动程序通常包括以下几个主要部分：</p>
<ol>
<li><p><strong>硬件接口</strong>：</p>
<ul>
<li>直接与硬件设备交互，发送命令和接收数据。</li>
</ul>
</li>
<li><p><strong>操作系统接口</strong>：</p>
<ul>
<li>提供给操作系统的标准化接口，使得操作系统能够通过系统调用与硬件设备交互。</li>
</ul>
</li>
<li><p><strong>中断处理</strong>：</p>
<ul>
<li>处理硬件设备发出的中断信号，并通知操作系统进行相应的处理。</li>
</ul>
</li>
<li><p><strong>内存管理</strong>：</p>
<ul>
<li>管理硬件设备使用的内存空间，包括数据缓冲区和控制寄存器。</li>
</ul>
</li>
</ol>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><strong>驱动程序在计算机系统中扮演着关键角色，通过提供标准化的接口，使得操作系统和应用程序能够高效、安全地与各种硬件设备进行交互。</strong>了解驱动程序的基本原理和类型，有助于更好地管理和维护计算机系统，确保硬件设备的正常运行和最佳性能。</p>
<h3 id="驱动-for-Docker"><a href="#驱动-for-Docker" class="headerlink" title="驱动　 for　Ｄｏｃｋｅｒ"></a>驱动　 for　Ｄｏｃｋｅｒ</h3><p>驱动就负责实现数据层。比如<strong>网络的连通性和隔离性是由驱动来处理的</strong>。驱动通过实现特定网络类型的方式扩展了 Docker 网络栈，例如桥接网络和覆盖网络。</p>
<p>Docker 内置了若干驱动，通常被称作原生驱动或者本地驱动。比如 <strong>Bridge Driver</strong>、<strong>Host Driver</strong>、<strong>Overlay Driver</strong>、<strong>MacLan Driver</strong>、<strong>None Driver</strong> 等等。第三方也可以编写 Docker 网络驱动，这些驱动被叫做远程驱动，例如 Calico、Contiv、Kuryr 以及 Weave 等。每个驱动负责创建其上所有网络资源的创建和管理。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240604004633142.png" alt="image-20240604004633142"></p>
<p>在 Docker 安装时，会自动安装一块 Docker 网卡称为 docker0，用于 Docker 各容器及宿主机的网络通信。</p>
<h1 id="桥接网络基本概念"><a href="#桥接网络基本概念" class="headerlink" title="桥接网络基本概念"></a>桥接网络基本概念</h1><p>桥接网络（Bridging Network）是一种网络配置方法，通过使用网络桥接（network bridging）技术将两个或多个网络段连接在一起，使它们能够作为一个统一的网络进行通信。这种技术常用于局域网（LAN）环境中，以扩展网络的覆盖范围或连接不同的网络类型。</p>
<h4 id="网络桥接的基本概念"><a href="#网络桥接的基本概念" class="headerlink" title="网络桥接的基本概念"></a>网络桥接的基本概念</h4><p>网络桥接的基本概念包括以下几个方面：</p>
<ol>
<li><p><strong>网络桥（Bridge）</strong>：</p>
<ul>
<li>网络桥是一种网络设备，可以是专用硬件设备或软件实现的虚拟桥。<strong>其主要功能是连接两个或多个网络段，使它们能够互相通信</strong>。</li>
<li>桥接设备会在<strong>不同的网络段之间转发数据包</strong>，使用媒体访问控制（MAC）地址来决定数据包的转发路径。</li>
</ul>
</li>
<li><p><strong>透明桥（Transparent Bridge）</strong>：</p>
<ul>
<li>透明桥是最常见的一种网络桥，它在连接的网络段之间转发数据包，而不会对网络协议进行任何修改。</li>
<li>透明桥通过学习网络设备的MAC地址来建立内部地址表，从而智能地转发数据包，仅将数据包发送到目标网络段。</li>
</ul>
</li>
</ol>
<h4 id="桥接网络的用途"><a href="#桥接网络的用途" class="headerlink" title="桥接网络的用途"></a>桥接网络的用途</h4><p>桥接网络可以用于多种用途，包括但不限于：</p>
<ol>
<li><p><strong>扩展网络覆盖范围</strong>：</p>
<ul>
<li>通过将两个或多个物理分开的网络段桥接在一起，可以扩展网络的覆盖范围，使更多的设备能够互相通信。</li>
</ul>
</li>
<li><p><strong>连接不同类型的网络</strong>：</p>
<ul>
<li>桥接可以<strong>连接不同类型的网络，例如以太网和无线网络</strong>，使得有线设备和无线设备能够在同一个网络中通信。</li>
</ul>
</li>
<li><p><strong>增强网络性能</strong>：</p>
<ul>
<li>通过合理的桥接配置，可以减少网络中的广播域，从而减少网络拥塞，提高整体网络性能。</li>
</ul>
</li>
</ol>
<h4 id="桥接网络的类型"><a href="#桥接网络的类型" class="headerlink" title="桥接网络的类型"></a>桥接网络的类型</h4><p>桥接网络可以有多种配置方式，以下是几种常见的类型：</p>
<ol>
<li><p><strong>以太网桥接（Ethernet Bridging）</strong>：</p>
<ul>
<li>通过以太网桥将多个以太网段连接在一起，使它们成为一个逻辑上的单一网络。</li>
</ul>
</li>
<li><p><strong>无线桥接（Wireless Bridging）</strong>：</p>
<ul>
<li>使用无线设备（如无线接入点）将两个或多个无线网络段连接在一起，常用于扩展无线网络的覆盖范围。</li>
</ul>
</li>
<li><p><strong>混合桥接（Hybrid Bridging）</strong>：</p>
<ul>
<li>结合有线和无线桥接，将有线网络段和无线网络段连接在一起。</li>
</ul>
</li>
</ol>
<h4 id="桥接网络的实现"><a href="#桥接网络的实现" class="headerlink" title="桥接网络的实现"></a>桥接网络的实现</h4><p>桥接网络可以通过硬件设备或软件配置来实现：</p>
<ol>
<li><p><strong>硬件实现</strong>：</p>
<ul>
<li>使用专用的网络桥设备或交换机（具有桥接功能）来连接不同的网络段。</li>
</ul>
</li>
<li><p><strong>软件实现</strong>：</p>
<ul>
<li>在操作系统中使用虚拟桥接软件（如Linux的<code>brctl</code>工具或Windows的网络桥接功能）来实现桥接网络。</li>
</ul>
</li>
</ol>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>假设有两个局域网（LAN），分别位于两个不同的楼层，每个楼层都有一个交换机连接所有的计算机。通过在两个交换机之间连接一个网络桥，可以使两个楼层的计算机互相通信，如同它们在同一个网络中一样。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>桥接网络是一种有效的网络配置方法，可以扩展网络的覆盖范围、连接不同类型的网络和增强网络性能。通过使用网络桥设备或软件实现桥接网络，可以将多个物理上分离的网络段连接在一起，形成一个逻辑上的统一网络。</p>
<p><strong>Docker 的 bridge 网络采用内置的 bridge 驱动，而 bridge 的底层采用的是</strong> <strong>Linux</strong> <strong>内核中 Linux bridge 技术</strong>（这意味着 bridge 是高性能并且是非常稳定的）。</p>
<h2 id="桥接网络-for-Docker"><a href="#桥接网络-for-Docker" class="headerlink" title="桥接网络 for Docker"></a>桥接网络 for Docker</h2><p>Docker 的 bridge 网络采用内置的 bridge 驱动，而 bridge 的底层采用的是 Linux 内核中 Linux bridge 技术（这意味着 bridge 是高性能并且是非常稳定的）。</p>
<p><strong>由于容器运行在自己单独的 network namespace 中，所以有单独的协议栈。</strong>容器中配置网关为 172.17.0.1，发出去的数据包<strong>先到达 br0</strong>，然后交给主机的协议栈，由于<strong>目的 IP 是外网 IP</strong>，且主机会开启 IP forward 功能，于是<strong>数据包通过主机的 eth0 发出去</strong>。由于 172.17.0.1 是内网 IP ，所以一般发出去之前会做 NAT 转换。由于要进过主机的协议栈并且要做 NAT 转换，所以性能上可能会差点，<strong>但是优点就是容器处于内网中，安全性相对要高点。</strong></p>
<p>默认情况下，创建的容器在没有使用 –network 参数指定要加入的 docker 网络时，默认都是加入 Docker 默认的单机桥接网络，也就是下面的 name 为 bridge 的网络。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">0dda6f303b8b        bridge              bridge              local</span><br></pre></td></tr></table></figure>

<h4 id="创建新的单机桥接网络"><a href="#创建新的单机桥接网络" class="headerlink" title="创建新的单机桥接网络"></a><strong>创建新的单机桥接网络</strong></h4><p>使用 <code>docker network create</code> 命令，我们可创建一个名为 “localnet” 的单机桥接网络，并且在内核中还会多出一个新的 Linux 网桥。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create -d bridge localnet</span><br><span class="line"></span><br><span class="line">$ docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">			......</span><br><span class="line">f55943e20201        localnet            bridge              local</span><br></pre></td></tr></table></figure>

<p>在创建完之后，我们可以通过 brctl 工具来查看系统中的 Linux 网桥。可以看到，<strong>输出的内容中包含了两个网桥，docker0 是默认的 Docker bridge 网络所使用的网桥，br-f55943e20201 是 Docker localnet 网络所使用的网桥。</strong>这两个网桥目前都没有任何设备接入（看 interface 列）。这两个网桥所处的网段是不同的，</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240604084900918.png" alt="image-20240604084900918"></p>
<h4 id="同个网络中的容器间通信"><a href="#同个网络中的容器间通信" class="headerlink" title="同个网络中的容器间通信"></a><strong>同个网络中的容器间通信</strong></h4><p>使用下面这条命令即可运行一个新的容器，并且让这个新容器加入到 localnet 这个网络中的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run -d --name demo1 --network localnet alpine sleep 3600</span><br></pre></td></tr></table></figure>

<p>我们查看网桥的情况，<strong>demo1</strong> 的网络接口连接到了网桥 br-f55943e20201 上，如图所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ brctl show</span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">br-f55943e20201 8000.02421d9aa3e1       no              vethf6a3fba</span><br><span class="line">docker0         8000.0242be6b61dc       no</span><br></pre></td></tr></table></figure>

<p>如果在<strong>相同的网络中继续接入新的容器，那么新接入的容器是可以通过 demo1 这个名称来 ping 通的</strong>。如下所示，我们创建了一个新的容器（demo2），并且在这个容器中直接 ping demo1 发现可以的 ping 通的。<strong>这是因为，demo2 运行了一个本地 DNS 解析器，该解析器会将该请求转发到 Docker 内部 DNS 服务器中。</strong>DNS 服务器中记录了容器启动时通过 –name 或者 –net-alias 参数指定的名称和容器之间的和映射关系。</p>
<h5 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h5><p>在你提供的例子中，<code>demo2</code> 容器中可以 <code>ping</code> 通 <code>demo1</code> 容器。这意味着 <code>demo2</code> 容器能够通过网络与 <code>demo1</code> 容器进行通信，<code>demo2</code> 可以成功发送 ICMP 回显请求数据包到 <code>demo1</code>，并接收到 <code>demo1</code> 的应答数据包。这种情况表明：</p>
<ol>
<li>两个容器处于同一个网络（如同一个 Docker 网络中）。</li>
<li>容器之间的 DNS 解析功能正常，<code>demo2</code> 能够通过容器名称 <code>demo1</code> 找到其对应的 IP 地址。</li>
<li>容器之间的网络连通性是正常的，没有防火墙等网络设备阻碍两者通信。</li>
</ol>
<p>下面是你提供的示例中的具体过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码# ping demo1</span><br><span class="line">PING demo1 (172.18.0.2): 56 data bytes</span><br><span class="line">64 bytes from 172.18.0.2: seq=0 ttl=64 time=0.230 ms</span><br><span class="line">64 bytes from 172.18.0.2: seq=1 ttl=64 time=0.161 ms</span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li>你在 <code>demo2</code> 容器中执行 <code>ping demo1</code> 命令。</li>
<li><code>demo2</code> 容器通过内部 DNS 解析 <code>demo1</code> 的名称并找到其 IP 地址 <code>172.18.0.2</code>。</li>
<li><code>demo2</code> 容器向 <code>172.18.0.2</code> 发送 ICMP 回显请求。</li>
<li><code>demo1</code> 容器接收到请求并返回 ICMP 回显应答。</li>
<li><code>demo2</code> 容器接收到应答，表明 <code>demo1</code> 容器是可达的，网络连通性正常。</li>
</ul>
<p>这就是为什么你可以在 <code>demo2</code> 中 <code>ping</code> 通 <code>demo1</code>。</p>
<hr>
<p>除此之外，我们可以看到 demo1 的 IP 地址是 172.18.0.2，这个与网桥 br-f55943e20201 是处于同一个网段内的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/ # ls</span><br><span class="line">bin    dev    etc    home   lib    media  mnt    opt    proc   root   run    sbin   srv    sys    tmp    usr    var</span><br><span class="line">/ # ping demo1</span><br><span class="line">PING demo1 (172.18.0.2): 56 data bytes</span><br><span class="line">64 bytes from 172.18.0.2: seq=0 ttl=64 time=0.230 ms</span><br><span class="line">64 bytes from 172.18.0.2: seq=1 ttl=64 time=0.161 ms</span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h2 id="ping的解释"><a href="#ping的解释" class="headerlink" title="ping的解释"></a>ping的解释</h2><p>当然，以下是对 <code>ping</code> 命令作用以及 “ping 通” 解释的详细说明：</p>
<h3 id="ping-命令的作用"><a href="#ping-命令的作用" class="headerlink" title="ping 命令的作用"></a><code>ping</code> 命令的作用</h3><p><code>ping</code>（Packet Internet Groper）是一个用于测试网络连接的命令行工具。其主要作用如下：</p>
<ol>
<li><p><strong>检测网络连通性</strong>：<code>ping</code> 可以用来检查一个设备是否能够与另一个设备进行网络通信。通过向目标地址发送ICMP（Internet Control Message Protocol）回显请求数据包，并等待回显应答来判断网络是否连通。</p>
</li>
<li><p><strong>测量网络延迟</strong>：<code>ping</code> 会显示从发送请求到接收应答所需的时间。这有助于测量网络的响应时间或延迟。</p>
</li>
<li><p><strong>诊断网络问题</strong>：通过观察 <code>ping</code> 的结果，可以帮助诊断网络中可能存在的问题。例如，如果 <code>ping</code> 不通，可能意味着网络不通、目标设备关闭或防火墙阻止了 ICMP 数据包。</p>
</li>
<li><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4></li>
</ol>
<h3 id="“ping-通”-的解释"><a href="#“ping-通”-的解释" class="headerlink" title="“ping 通” 的解释"></a>“ping 通” 的解释</h3><p>“ping 通” 指的是通过 <code>ping</code> 命令成功发送 ICMP 回显请求并收到目标设备的回显应答。这表明两个设备之间的网络连接正常，能够相互通信。具体来说：</p>
<ul>
<li>当你运行 <code>ping</code> 命令时，系统会向目标 IP 地址或域名发送 ICMP 回显请求数据包。</li>
<li>如果目标设备接收到这个数据包并回送一个回显应答数据包，那么 <code>ping</code> 命令就会在控制台上显示应答的信息，包括应答时间、数据包大小和 TTL（生存时间）。</li>
<li>多次 <code>ping</code> 通表示网络连接稳定，并且没有丢包或超时的情况。</li>
</ul>
<p>在你提供的示例中，<code>demo2</code> 容器通过 <code>ping demo1</code> 命令发送 ICMP 回显请求，并成功收到 <code>demo1</code> 容器的回显应答。这说明 <code>demo2</code> 和 <code>demo1</code> 之间的网络连接是正常的，可以相互通信。</p>
<h2 id="暴露端口"><a href="#暴露端口" class="headerlink" title="暴露端口"></a><strong>暴露端口</strong></h2><p>同一个网络中的容器之间虽然可以互相 ping 通，但是并不意味着可以任意访问容器中的任何服务。Docker 为容器增加了一套安全机制，<strong>只有容器自身允许的端口，才能被其他容器所访问。如下所示，我们可以通过 <code>docker container ls</code> 命令可以看到容器暴露给其他容器访问的端口是 80，那么我们只能容器的 80 端口进行访问，而不能对没有开放的 22 端口进行访问。</strong></p>
<p>我们可以在<strong>镜像创建的时候定义要暴露的端口，也可以在容器创建时定义要暴露的端口</strong>，使用 –expose。如下所示，就额外暴露了 20、22 这两个端口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run -d --name web --expose 22 --expose 20 nginx</span><br><span class="line"></span><br><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">4749dac32711        nginx               &quot;/docker-entrypoint.…&quot;   12 seconds ago      Up 10 seconds       20/tcp, 22/tcp, 80/tcp   web</span><br></pre></td></tr></table></figure>

<h4 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a><strong>端口映射</strong></h4><p>上面提到的桥接网络中的容器只能与位于相同网络中的容器进行通信，假如一个容器想对外提供服务的话，需要进行端口映射。端口映射将容器的某个端口映射到 Docker 主机端口上。那么任何发送到该端口的流量，都会被转发到容器中。如图所示，容器内部开放端口为 80，该端口被映射到了 Docker 主机的 10.0.0.15 的 5000 端口上。最终访问 10.0.0.15:5000 的所有流量都会被转发到容器的 80 端口。</p>
<h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a><strong>相关命令</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 列出运行在本地 docker 主机上的全部网络</span><br><span class="line">docker network ls</span><br><span class="line"></span><br><span class="line"># 提供 Docker 网络的详细配置信息</span><br><span class="line">docker network inspect &lt;NETWORK_NAME&gt;</span><br><span class="line"></span><br><span class="line"># 创建新的单机桥接网络，名为 localnet，其中 -d 不指定的话，默认是 bridge 驱动。并且主机内核中也会创建一个新的网桥。</span><br><span class="line">docker network create -d bridge localnet</span><br><span class="line"></span><br><span class="line"># 删除 Docker 主机上指定的网络</span><br><span class="line">docker network rm</span><br><span class="line"></span><br><span class="line"># 删除主机上全部未使用的网络</span><br><span class="line">docker network prune</span><br><span class="line"></span><br><span class="line"># 运行一个新的容器，并且让这个容器加入 Docker 的 localnet 这个网络中</span><br><span class="line">docker container run -d --name demo1 --network localnet alpine sleep 3600</span><br><span class="line"></span><br><span class="line"># 运行一个新的容器，并且让这个容器暴露 22、20 两个端口</span><br><span class="line">docker container run -d --name web --expose 22 --expose 20 nginx</span><br><span class="line"></span><br><span class="line"># 运行一个新的容器，并且将这个容器的 80 端口映射到主机的 5000 端口</span><br><span class="line">docker container run -d --name web --network localnet -p 5000:80 nginx</span><br><span class="line"></span><br><span class="line"># 查看系统中的网桥</span><br><span class="line">brctl show</span><br></pre></td></tr></table></figure>


      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/source/categories/Penetration-Testing/">Penetration Testing</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/source/tags/tools/">tools</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2024/07/08/Burpsuite 从入门到精通/"><span>Burpsuite 从入门到精通desu</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/07/08/Burpsuite 从入门到精通/" rel="bookmark">
        <time class="entry-date published" datetime="2024-07-08T15:09:07.000Z">
          2024-07-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="Burpsuite从入门到入土"><a href="#Burpsuite从入门到入土" class="headerlink" title="Burpsuite从入门到入土"></a>Burpsuite从入门到入土</h1><p>在Burp suite的使用中，会出现如下的选项</p>
<h2 id="Raw："><a href="#Raw：" class="headerlink" title="Raw："></a>Raw：</h2><p>视图主要显示web请求的真实格式，包含请求地址，http协议版本，主机头。浏览器信息，Accept可接受的内容类型，字符集，编码方式，cookie等。通过手工修改这些信息可以完成一些渗透测试的工作</p>
<h2 id="Params"><a href="#Params" class="headerlink" title="Params:"></a>Params:</h2><p>主要显示客户端请求的参数信息 ，包括GET和POST传参aders：</p>
<p>这个视图显示的信息和Raw的信息类似，只不过这个更加直观</p>
<h2 id="Hex："><a href="#Hex：" class="headerlink" title="Hex："></a>Hex：</h2><p>这个视图显示Raw的十六进制内容</p>
<p>一般开启Burp Proxy是不会拦截静态文件的，同时用户可以修改拦截作用域个性化Burp的使用效果。所有拦截到的信息和历史信息都可以通过右击弹出菜单，发送到其他组件。，<strong>如Scanner、Repeater、Intruder、Sequencer、Decoder、 Comparer、Extender等</strong></p>
<h2 id="数据拦截与控制"><a href="#数据拦截与控制" class="headerlink" title="数据拦截与控制"></a>数据拦截与控制</h2><p>较为基础</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240706203308670.png" alt="image-20240706203308670"></p>
<h1 id="Burp的相关配置"><a href="#Burp的相关配置" class="headerlink" title="Burp的相关配置"></a>Burp的相关配置</h1><p>当我们打开可选项设置选项卡Options，从界面显示来看，常用的部分主要包括以下几大板块（涉及 https的功能不包含在本章内容里，后面会一章专门叙述）：</p>
<h2 id="客户端请求消息拦截"><a href="#客户端请求消息拦截" class="headerlink" title="客户端请求消息拦截"></a>客户端请求消息拦截</h2><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240706203532487.png" alt="image-20240706203532487"></p>
<p>这个可以通过添加一些个性化的条件语句</p>
<h3 id="有四个选项"><a href="#有四个选项" class="headerlink" title="有四个选项"></a>有四个选项</h3><p>操作符的与或非</p>
<p>匹配类型（可以基于域名 IP地址 协议 请求方法 URL  文件类型 参数 cookies 头部</p>
<p>内容 状态码）</p>
<p>关系：关系则是匹配或不匹配</p>
<p>条件：条件则是对关键字的一些要求</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/YuiJar/article/details/81316478">正则表达式的语法及匹配规则（基础）_正则匹配位不定长度的-CSDN博客</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240706204059953.png" alt="image-20240706204059953"></p>
<p>勾选自动修复丢失行可以防止一些用户在修改数据包过程中的失误，比如请求空行忘记给出等</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240706204227208.png" alt="image-20240706204227208"></p>
<p>如果 自动更新文本长度被选中，则当请求消息被修改后，Content-Length也 会自动被修改，替换为与之相对应的值。</p>
<h2 id="服务端返回消息拦截"><a href="#服务端返回消息拦截" class="headerlink" title="服务端返回消息拦截"></a>服务端返回消息拦截</h2><p> 基本和代理拦截规则一致</p>
<h2 id="服务端返回消息修改"><a href="#服务端返回消息修改" class="headerlink" title="服务端返回消息修改"></a>服务端返回消息修改</h2><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240706204353108.png" alt="image-20240706204353108"></p>
<h2 id="正则表达式配置"><a href="#正则表达式配置" class="headerlink" title="正则表达式配置"></a>正则表达式配置</h2><p>正则表达式主要用于自动替换请求信息或者响应包返回信息的某些值和文本</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240706204545884.png" alt="image-20240706204545884"></p>
<h1 id="历史记录"><a href="#历史记录" class="headerlink" title="历史记录"></a>历史记录</h1><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240706204640322.png" alt="image-20240706204640322"></p>
<p>HTTP history界面由筛选过滤器、历史记录列表、消息详情3个部分组成。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240706204755399.png" alt="image-20240706204755399"></p>
<p>单击可以查看请求包和响应包</p>
<p><strong>在消息上双击则会弹出此条消息的详细对话框</strong></p>
<p>当我们在做系统的安全评估过程中，会在HTTP history中保存了大量的日志记录，为了更便捷的管理历 史消息，Burp提供了筛选过滤器功能。当我们点击HTTP history标签下的Filter时，将弹出筛选过滤器界 面。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240706204953362.png" alt="image-20240706204953362"></p>
<p>按照过滤条件的不同，筛选过滤器划分出7个子板块，分别是 </p>
<h2 id="按照请求类型过滤："><a href="#按照请求类型过滤：" class="headerlink" title="按照请求类型过滤："></a>按照请求类型过滤：</h2><p>你可以选择仅显示当前作用域的、仅显示有服务端响应的和仅显示带有请求参 数的消息。当你勾选“仅显示当前作用域”时，此作用域需要在Burp Target的Scope选项中进行配 置，需要搭配Burp Target使用（后面会说）。 </p>
<h2 id="按照MIME类型（多用途互联网邮件扩展类型）过滤："><a href="#按照MIME类型（多用途互联网邮件扩展类型）过滤：" class="headerlink" title="按照MIME类型（多用途互联网邮件扩展类型）过滤："></a>按照MIME类型（多用途互联网邮件扩展类型）过滤：</h2><p>你可以控制是否显示服务端返回的不同文件 类型的消息，比如只显示HTML、CSS或者图片。过滤器目前支持HTML、Script、XML、CSS、其 他文本、图片、Flash、二进制文件8种形式。 </p>
<h2 id="按照服务器返回的HTTP状态码过滤："><a href="#按照服务器返回的HTTP状态码过滤：" class="headerlink" title="按照服务器返回的HTTP状态码过滤："></a>按照服务器返回的HTTP状态码过滤：</h2><p>Burp根据服务器的状态码，按照2XX，3XX，4XX，5XX分别 进行过滤。比如，如果你只想显示返回状态码为200的请求成功消息，则勾选2XX。</p>
<h2 id="按照查找条件过滤："><a href="#按照查找条件过滤：" class="headerlink" title="按照查找条件过滤："></a>按照查找条件过滤：</h2><p>此过滤器是针对服务端返回的消息内容，与输入的关键字进行匹配，具体的匹 配方式，你可以选择 （1）正则表达式 （2）大小写敏感 （3）否定查找 三种方式可以任意组合，前面两种匹配方式容易理解，第3种匹配方式是指与关键字匹配上的将不 再显示。 </p>
<h2 id="按照文件类型过滤："><a href="#按照文件类型过滤：" class="headerlink" title="按照文件类型过滤："></a>按照文件类型过滤：</h2><p>通过文件类型在过滤消息列表，这里有两个选择可供操作。一是仅显示哪些， 另一个是不显示哪些。如果是仅显示哪些，在show only的输入框中填写显示的文件类型，同样， 如果不显示哪些文件类型，只要在hide的输入框中填写不需要显示的文件类型即可。</p>
<h2 id="按照注解过滤："><a href="#按照注解过滤：" class="headerlink" title="按照注解过滤："></a>按照注解过滤：</h2><p>此过滤器的功能是指，根据每一个消息拦截时候的备注或者是否高亮来作为筛选条 件控制哪些消息在历史列表中显示。 </p>
<h2 id="按照监听端口过滤："><a href="#按照监听端口过滤：" class="headerlink" title="按照监听端口过滤："></a>按照监听端口过滤：</h2><p>此过滤器通常使用于当我们在Proxy Listeners中多个监听端口时，仅仅显示某 个监听端口通信的消息，一般情况下，搭配中间件、数据库等漏洞使用。</p>
<h1 id="SSL和Proxy高级选项"><a href="#SSL和Proxy高级选项" class="headerlink" title="SSL和Proxy高级选项"></a>SSL和Proxy高级选项</h1><h2 id="HTTP协议信息的拦截和处理："><a href="#HTTP协议信息的拦截和处理：" class="headerlink" title="HTTP协议信息的拦截和处理："></a>HTTP协议信息的拦截和处理：</h2><h2 id="监听设置"><a href="#监听设置" class="headerlink" title="监听设置"></a>监听设置</h2><p>监听设置包含三块功能:</p>
<ol>
<li><h1 id="Binding（端口绑定模式）"><a href="#Binding（端口绑定模式）" class="headerlink" title="Binding（端口绑定模式）"></a>Binding（端口绑定模式）</h1><p>Binding绑定的端口是指Burp Proxy代理服务监听的端口，绑定IP地址 分为本地回路、所有接口、指定地址三种模式，在渗透测试中，无论选择哪种模式，需要明白一 点，当选择非本地回路IP地址时，同局域网内的其他电脑也可以访问你的监听地址</p>
<p>—也就是说,其他电脑的数据包也会被你的burpsuite拦截.但不要因此形成认知上的误区</p>
<p>虽然Burp Suite无法自动实现对整个局域网所有流量的监听，但通过手动配置代理或设置透明代理，可以在一定程度上实现对局域网内多个设备流量的拦截。需要注意的是，这些操作通常需要管理员权限和详细的网络配置</p>
</li>
<li><h1 id="Request-Handling（请求处理）"><a href="#Request-Handling（请求处理）" class="headerlink" title="Request Handling（请求处理）"></a>Request Handling（请求处理）</h1><p>主要是用来控制接收到Burp Proxy监听端口的请求后，如何对 请求进行处理的，即使用Burp再次转发。 </p>
<p>其具体配置可分为：主机名&#x2F;域名的转发、端口的转发、强制使用SSL和隐形代理4个部分。当我们 配置了主机或域名的转发，则所有的请求会转发到指定的主机或域名上；如果我们配置了端口的转 发时，所有的请求都会被转发到指定端口上。同时我们可以配置，通过Burp Proxy的消息是否强制 使用SSL，如果设置了此项，则请求若是http协议，经Burp Proxy代理后将转换为https协议。隐形 代理主要是用于测试富客户端应用或者是非浏览器代理方式的应用，当我们设置了它，访问这些应 用时，将通过<strong>非代理的方式，直接连接Burp Proxy的监听端口</strong>。</p>
<p>不挂代理的方式有其独特的意义和应用场景，特别是在一些特殊情况下，无法直接通过设置代理来拦截和分析流量。以下是一些不挂代理的方式及其意义：</p>
<h3 id="意义和应用场景"><a href="#意义和应用场景" class="headerlink" title="意义和应用场景"></a>意义和应用场景</h3><ol>
<li><strong>移动应用测试</strong>：有些移动应用不提供代理设置选项，或者应用的流量硬编码到特定的IP地址或域名。在这种情况下，使用代理进行流量拦截变得非常困难，通过非代理方式（如DNS欺骗或网络重定向）可以解决这个问题。</li>
<li><strong>嵌入式设备测试</strong>：一些嵌入式设备（如物联网设备、智能家居设备）不允许配置代理设置。通过网络设备（如路由器、防火墙）上的规则重定向流量，可以实现对这些设备流量的拦截和分析。</li>
<li><strong>绕过代理检测</strong>：某些系统或应用可能会检测并拒绝代理流量，使用非代理方式可以避免这种检测，从而进行更隐蔽的流量分析。</li>
<li><strong>网络设备测试</strong>：在测试一些需要透明代理或中间设备（如网关、VPN）的场景下，非代理方式可以帮助实现透明的流量拦截和分析，而不会对客户端配置造成影响。</li>
</ol>
</li>
</ol>
<h1 id="Burp-Target"><a href="#Burp-Target" class="headerlink" title="Burp Target"></a>Burp Target</h1><p>1. </p>
<p>Burp Target 组件主要包含<strong>站点地图、目标域、风险定义</strong>三部分组成</p>
<p>当前工作涉及哪些目标域、可能存在的攻击面等信息，下面我们就分别来看看 Burp Target的三个组成部分。</p>
<p>本章的主要内容有：</p>
<h2 id="目标域设置-Target-Scope"><a href="#目标域设置-Target-Scope" class="headerlink" title="目标域设置 Target Scope"></a>目标域设置 Target Scope</h2><p>Target Scope中作用域的定义比较宽泛，通常来说，在对某个系统进行渗透测试时，可以通过域名或者 主机名去限制拦截内容，这里的域名或主机名就是我们说的作用域。如果我们想限制得更为细粒度化， 比如，你只想拦截login目录下的所有请求，也可以在此设置，此时，作用域就是目录。总体来说， Target Scope主要使用于下面几种场景中：</p>
<p>限制站点地图和Proxy历史中的显示结果</p>
<p> 告诉Burp Proxy拦截哪些请求 </p>
<p>Burp Spider抓取哪些内容 </p>
<p>Burp Scan自动扫描哪些作用域的安全漏洞 </p>
<p>在Burp Intruder和Burp Repeater中指定URL 通过Target Scope我们能方便地控制Burp的拦截范围、操作对象，减少无效的噪音（此处演示一下）。 </p>
<h2 id="站点地图-Site-Map"><a href="#站点地图-Site-Map" class="headerlink" title="站点地图 Site Map"></a>站点地图 Site Map</h2><p>当我们设置了 Target Scope（默认全部为允许），使用Burp Proxy进行代理拦截，通过浏览器代理浏览 应用时，Burp会自动将浏览信息记录下来，包含每一个请求和应答的详细信息，保存在Target站点地图 中。</p>
<p>Site Map的左边为访问的URL，按照网站的层级和深度，树形展示整个网站的目 录结构和关联其他域的URL情况；</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707084335435.png" alt="image-20240707084335435"></p>
<p>对该树状结构进行扫描，还可以进行进一步的主动扫描，从而发现一些潜在的风险</p>
<h2 id="Target-工具的使用"><a href="#Target-工具的使用" class="headerlink" title="Target 工具的使用"></a>Target 工具的使用</h2><p>Target 工具的使用的使用主要包括以下部分：</p>
<h3 id="手工获取站点地图"><a href="#手工获取站点地图" class="headerlink" title="手工获取站点地图"></a>手工获取站点地图</h3><p>1、设置浏览器代理和Burp Proxy代理，并使之能正常工作。</p>
<p> 2、关闭Burp Proxy的拦截功能。</p>
<p> 3、手工浏览网页，这时，Target会自动记录站点地图信息。</p>
<p>手工获取站点地图可以使用户根据自己的需要和分析自主控制访问的内容。</p>
<p>记录的信息比较准确，但对于大型的系统而言依次点击一遍对渗透测试人员而言成本比较大</p>
<h3 id="站点比较"><a href="#站点比较" class="headerlink" title="站点比较"></a>站点比较</h3><p>站点比较更为简单,本质就是将站点的结构进行对比</p>
<h4 id="攻击面分析"><a href="#攻击面分析" class="headerlink" title="攻击面分析"></a>攻击面分析</h4><p>右击对应的站点，能够通过相关工具中的分析选项做攻击面分析</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707085712514.png" alt="image-20240707085712514"></p>
<p>概况视图主要展示当前站点动态URL数量、静态URL数量、参数的总数、唯一的参数名数目，通过这些 信息，可以快速帮助我们对当前站点的总体状况建立粗线条的了解。</p>
<p>动态URL和静态URL对应的都可以查看详细的请求包和响应包</p>
<p>参数视图有上中下三部分组成，上部为参数和参数计数统计区，你可以对参数的使用次数进行排序， 从而找出使用频繁的参数进行分析；中部为参数对应的使用情况列表，记录对应的参数每一次的使用记 录；下部为某一次使用过程中，请求消息和应答消息的详细信息。</p>
<p>实际使用中很多站点使用伪静态，如果请求的URL中不带有参数，则分析时无法区别，只能当作静态URL来分析</p>
<h2 id="Discover-Content"><a href="#Discover-Content" class="headerlink" title="Discover Content"></a>Discover Content</h2><p>存在于Burp Target中的站点信息,我们可以直接发送到spider中进行站点信息的爬取.在Burp1.7版本中,存在一个独立模块,叫做Burp Spider,而Burp2.0更新后的本本后,该模块被整合为Targe相关工具中的Discover Content</p>
<p>Discover Content主要用于大型操应用系统的测试</p>
<p>Discover Content的使用主要包含三个方面</p>
<h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><p>Discover Content 控制界面由发现会话状态（Discovery Session Status）和排列任务（Queued Tasks）两部分组成。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707091342086.png" alt="image-20240707091342086"></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>配置界面由Target,Filenames,File Extensions,Discovery Engine四个功能组成</p>
<p>对应的可以根据自己的需要进行一些筛选配置</p>
<h3 id="站点地图"><a href="#站点地图" class="headerlink" title="站点地图"></a>站点地图</h3><p>站点地图（Site Map） 爬取完成后形成的站点地图，和Target模块中的站点地图类似。</p>
<h1 id="Burp-Scan"><a href="#Burp-Scan" class="headerlink" title="Burp Scan"></a>Burp Scan</h1><p>Burp Scan的功能主要是用来自动检测Web系统的各种漏洞，可以使用Burp Scan代替测试人员手工去对 系统进行普通漏洞类型的渗透测试，从而使得测试人员能把更多精力放在那些需要人工验证的漏洞上。</p>
<p>BurpScan是很传统的扫描器,没有什么需要额外提及的</p>
<p>不过这里还是有一些点需要额外考虑</p>
<p>Burp使用被动扫描时为了使流量更接近于普通用户,几乎不额外构造请求进行爬虫或扫描,它基于已经存在的请求和响应进行简单的分析</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707092650449.png" alt="image-20240707092650449"></p>
<p>Burp使用主动扫描模式时则会对应用发送新的请求并通过payload验证漏洞,这种模式下的操作回产生大量的请求和响应数据,直接影响系统的性能,通常适用于非生产环境</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707095413391.png" alt="image-20240707095413391"></p>
<h2 id="扫描配置"><a href="#扫描配置" class="headerlink" title="扫描配置"></a>扫描配置</h2><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707095705268.png" alt="image-20240707095705268"></p>
<p>Scan Type：扫描类型，分为 Crawl and audit 和 Crawl，即爬虫和审计，或者仅爬虫。</p>
<p> URLs to Scan：扫描目标URL Detailed scope configuration：详细的范围配置，通过 Included URL prefixes（包括URL前缀）和 Excluded URL prefixes（不包括URL前缀）来配置扫描。</p>
<p> Use advanced scope control：使用高级的范围控制，如果勾选，将配置 Included URLs（包含的 URL）和Excluded URLs（不包含的URL）来配置扫描。 </p>
<p>点击 Add，弹出配置窗口：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707100020676.png" alt="image-20240707100020676"></p>
<p>**PS:**协议:包含HTTP和HTTPS或者任意</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707100240814.png" alt="image-20240707100240814"></p>
<p>如果需要登录,可以提前配置username和password</p>
<p>导出扫描报告</p>
<p> 1.在Target-&gt;Site Map，选择某个URL，右侧Issues按ctrl+a全选，右键，点击Report selected issues</p>
<p>2.选择报告格式 HTML：生成HTML格式的报告，以便在浏览器中打印或查看。 XML：生成XML格式的报告，适合导入其他工具或报告框架</p>
<h1 id="Burp-Intruder"><a href="#Burp-Intruder" class="headerlink" title="Burp Intruder"></a>Burp Intruder</h1><p>在渗透测试过程中，我们经常使用Burp Intruder，它的工作原理是：Intruder在原始请求数据的基础 上，通过修改各种请求参数，以获取不同的应答。每一次请求中，Intruder都会携带一个或多个有效攻 击载荷（payload），在不同位置进行攻击重放，通过应答数据的比对分析来获得需要的特征数据。</p>
<h2 id="Intruder使用场景"><a href="#Intruder使用场景" class="headerlink" title="Intruder使用场景"></a>Intruder使用场景</h2><h3 id="标识符枚举"><a href="#标识符枚举" class="headerlink" title="标识符枚举"></a>标识符枚举</h3><p>Web应用程序经常使用标识来引用用户,账户,资产等数据信息. 例如用户名 文件ID和账户密码</p>
<h3 id="提取有用数据"><a href="#提取有用数据" class="headerlink" title="提取有用数据"></a>提取有用数据</h3><p>在某些场景下,并非简单的识别有效标识符.而是通过识别标识符提取一些其他的数据.比如单个用户的个人空间ID,获取所欲用户在个人空间的昵称和年龄</p>
<h3 id="模糊测试"><a href="#模糊测试" class="headerlink" title="模糊测试"></a>模糊测试</h3><p>很多输入型的漏洞,如SQL注入,跨站脚本和文本路径遍历等都可以通过修改请求参数提交各种测试字符串. 可以通过Intruder的自动化来实现对Web应用的模糊测试</p>
<p>通常来说</p>
<p>BurpIntruder的测试主要遵循以下步骤</p>
<ol>
<li><p>确认BurpSuite安装正确并正常启动，且完成了浏览器的代理设置。</p>
</li>
<li><p>进入Burp Proxy选项卡，关闭代理拦截功能。</p>
</li>
<li><p>进行历史日志（History）子选项卡，查找可能存在问题的请求日志，并通过右击菜单，发送到 Intruder。 </p>
</li>
<li><p>进入 Intruder 选项卡，打开 Target 和 Positions 子选项卡。这时，你会看到上一步发送过来的请 求消息。</p>
</li>
<li><p>Burp Intrude<strong>r 攻击的基础是围绕刚刚发送过来的原始请求信息，在原始信息指定的位置上设置一 定数量的攻击载荷 Payload</strong>，通过替换 Payload 来发送不同的请求以获取应答消息。默认情况下<strong>， Burp Intruder 会对请求参数和 Cookie 参数设置成 Payload position，前缀添加 $ 进行标识，如 上图红色标注位置所示。当发送请求时，会将$标识的参数替换为 Payload 。</strong></p>
</li>
<li><p>在光标对应位置选择右侧选项,就可以添加或删除<strong>预留出的payload位置</strong></p>
<p>预留出payload位置则是为了使Intruder在对应位置中遍历预设的payload集,发送大批数据包</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707104227760.png" alt="image-20240707104227760"></p>
</li>
<li><p>在payload子选项卡中可以选择payload的生成策略,比如id&#x3D;1-100不断遍历</p>
</li>
<li><p>最后做一遍检查,便可以开始爆破,后续可以开始阅览Intruder返回的通信信息,查看是否有自己需要的信息</p>
</li>
<li><p>有些时候为了防止应答信息太多无法检索出我们需要的信息,通常在进行攻击前,会进行Options选项的相关配置,使用最多的是正则表达式匹配</p>
</li>
<li><p>攻击结果也是可以将展示出的信息做一些指定的,比如攻击时间和是否存在Error等</p>
</li>
</ol>
<h2 id="Payload类型与处理"><a href="#Payload类型与处理" class="headerlink" title="Payload类型与处理"></a>Payload类型与处理</h2><p>payload类型足足有18种可供选择,这里挑选常用的几种记录</p>
<h3 id="简单列表"><a href="#简单列表" class="headerlink" title="简单列表:"></a>简单列表:</h3><p>通过配置一个字符串列表作为payload,也可以手动添加字符串列表或者从文件加载字符串列表</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707111535806.png" alt="image-20240707111535806"></p>
<p>对应的 burp预设了很多组简单payload列表</p>
<p>包括XSS脚本 CGI脚本 SQL注入脚本 数字 大写小写字母  用户名 密码 表单域的字段名 IIS文件名和目录名等</p>
<h3 id="指定文件"><a href="#指定文件" class="headerlink" title="指定文件"></a>指定文件</h3><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707111717409.png" alt="image-20240707111717409">可以指定文件作为相对应payload位置上的列表</p>
<h3 id="自定义迭代器"><a href="#自定义迭代器" class="headerlink" title="自定义迭代器"></a>自定义迭代器</h3><p>这是一款功能强大的Payload，它共有8个占位，每一个占位 可以指定简单列表的Payload类型，然后根据占位的多少，与每一个简单列表的Payload进行笛卡 尔积（集合相乘的结果），生成最终的Payload列表</p>
<h4 id="payload设置"><a href="#payload设置" class="headerlink" title="payload设置"></a>payload设置</h4><p>如图例</p>
<p>位置1 –从列表选择用户名带入</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707114033155.png" alt="image-20240707114033155"></p>
<p>位置2 –可以直接设置值 比方说@@</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707114135696.png" alt="image-20240707114135696"></p>
<p>位置3 –也可以从文件加载</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707114300016.png" alt="image-20240707114300016"></p>
<p>最后攻击时生成的payload则会按照迭代的占位依次排列</p>
<p>如图所示</p>
<img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707115021293.png" alt="image-20240707115021293" style="zoom:200%;" />

<h3 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h3><p>– 顾名思义，<strong>该Payload的类型是对预定义的字符串进行替换后生成新的字符串。</strong>比如说，预定义字符串为ABCD，按照下图的替换规则设置后，将对AB的值 进行枚举后生成新的字符串</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707153759117.png" alt="image-20240707153759117"></p>
<p><strong>如图攻击,如果满足替换条件,它则会将原payload和修改后的payload一起发送到服务端.</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707153954509.png" alt="image-20240707153954509"></p>
<h3 id="大小写替换"><a href="#大小写替换" class="headerlink" title="大小写替换"></a>大小写替换</h3><p>对预定义的字符串，按照<strong>大小写规则进行替换</strong>。比如，预定义 的字符串为Peter Wiener，则按照下图的设置后，会生成新的Payload。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707154240220.png" alt="image-20240707154240220"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707154302311.png" alt="image-20240707154302311"></p>
<p>生成规则由上而下依次是：</p>
<p> No change（不改变，使用原始字符串）</p>
<p> To lower case（转为小写字母） </p>
<p>To upper case（转为大写字母） </p>
<p>To Propername（首字母大写，其他小写） </p>
<p>To ProperName（单词首字母大写，其他不改变)</p>
<p> 在实际使用中，可以根据自己的使用规则进行勾选设置。</p>
<h3 id="字符块"><a href="#字符块" class="headerlink" title="字符块"></a>字符块</h3><p>这种类型的Payload是指使用一个给出的输入字符串，根据指定设 置产生指定大小的字符块，表现形式为生成指定长度的字符串。它通常是用来绕过应用防火墙 （WAF）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707154649754.png" alt="image-20240707154649754"></p>
<h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><p>这种类型的payload是根据配置,生成一系列的数字作为payload.它的设置界面如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707154817322.png" alt="image-20240707154817322"></p>
<p>数字范围部分就是确定最大和最小值以及最大值和最小值所构成的范围中如何取数字,类型分为按顺序和随机遍历给出的数字集合</p>
<h3 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h3><p>根据配置生成一系列的日期</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707155611480.png" alt="image-20240707155611480"></p>
<p>配置比较简单 不过多赘述</p>
<h3 id="暴力字典（Brute-forcer）"><a href="#暴力字典（Brute-forcer）" class="headerlink" title="暴力字典（Brute forcer）"></a>暴力字典（Brute forcer）</h3><p>此类Payload生成包含一个指定字符集的所有特定长度排列的有效载 荷，通常用于枚举字典的生成，其设置界面如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707160307554.png" alt="image-20240707160307554"> </p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707160255421.png" alt="image-20240707160255421"></p>
<p>空类型（Null payloads）</p>
<p>这种负载类型产生的Payload，其值是一个空字符串。在攻击时，<strong>如果 需要同样的请求反复被执行</strong>，在不任何修改原始请求的场景下此Payload是非常有用的。<strong>它可用于 各种攻击，例如应用层DOS、或保持活会话令牌、资源竞争等。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707160640648.png" alt="image-20240707160640648"></p>
<p><strong>这样就近似于实现了单台机的DOS攻击</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707160655083.png" alt="image-20240707160655083"></p>
<h3 id="字符扮演者（Character-frobber）"><a href="#字符扮演者（Character-frobber）" class="headerlink" title="字符扮演者（Character frobber）"></a>字符扮演者（Character frobber）</h3><p>依次修改指定字符串在每 个字符位置的值（不做特殊说明的情况下就是指十进制），每次都是在原字符上递增1个该字符的 ASCII码。</p>
<h3 id="用户名生成器"><a href="#用户名生成器" class="headerlink" title="用户名生成器"></a>用户名生成器</h3><p>这种类型的Payload主要用于用户名和Email账号的自动 生成，其设置界面如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707160956758.png" alt="image-20240707160956758"></p>
<h2 id="攻击类型"><a href="#攻击类型" class="headerlink" title="攻击类型"></a>攻击类型</h2><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707161315912.png" alt="image-20240707161315912"></p>
<h2 id="可选项设置"><a href="#可选项设置" class="headerlink" title="可选项设置"></a>可选项设置</h2><h3 id="请求消息头设置"><a href="#请求消息头设置" class="headerlink" title="请求消息头设置"></a>请求消息头设置</h3><p>请求消息头设置中包含<strong>自动更新Content-Length</strong>和<strong>Set Connection: close</strong></p>
<p>如果选中了设置Connection报头,那么Burp Intruder则会在每个消息中都更新对应的Connection Close报头</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707162113734.png" alt="image-20240707162113734"></p>
<h3 id="攻击结果设置"><a href="#攻击结果设置" class="headerlink" title="攻击结果设置"></a>攻击结果设置</h3><p>这个设置主要用来控制从响应信息中提取结果项,如果 匹配,则在攻击结果中添加新列进行标明</p>
<p>比如在”密码不正确”攻击中遍历一个大字典,这个时候payload数量过大,这个时假设还无法从可疑的对话长度等方面入手,就chenggongv可以通过扫描诸如”Incorrect password”等等找到成功的登录.</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707161925846.png" alt="image-20240707161925846"></p>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>这些设置是主要用于控制执行攻击时Burp如何处理重定向,在实际使用中必须遵循重定向才能实现目的</p>
<p>比如密码猜测攻击中,如果密码错误可能会重定向响应到密码错误的提示界面,密码正确则会重定向到用户中心首页等</p>
<h3 id="Intruder攻击和结果分析"><a href="#Intruder攻击和结果分析" class="headerlink" title="Intruder攻击和结果分析"></a>Intruder攻击和结果分析</h3><p>攻击的发起分为两种方式,一种是经过对应的Target ,Positions,payloads,options等再经过启动进行攻击,另一种则是通过预攻击文件直接发起攻击,攻击结果页面如下所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707170729022.png" alt="image-20240707170729022"></p>
<p>从上图我们可以看出，其界面主要有菜单区、过滤区、消息记录区、请求&#x2F;响应区四部分组成。</p>
<p>菜单区——包含Attack菜单、Save菜单、Columns菜单。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707170959048.png" alt="image-20240707170959048"></p>
<p>过滤区——可以通过查询条件、服务器响应的状态码、注释对消息记录区的信息进行过滤。</p>
<p>消息记录区，又称结果列表（Results Table），记录Payload执行时请求和响应的所有信息，</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707171015761.png" alt="image-20240707171015761"></p>
<p>在对攻击结果的分析中，你可以通过单击任一列标题（升序排序，降序排序和未排序）重新排序表的内 容。有效的应答通常可以通过以下存在差异的内容进行判断：</p>
<h1 id="Burp-Repeater"><a href="#Burp-Repeater" class="headerlink" title="Burp Repeater"></a>Burp Repeater</h1><p> Repeater是对消息的手动改动和迭代的进程,在渗透测试过程中我们经常使用Repeater来进行请求与响应的消息验证分析,比如修改请求参数 验证输入的漏洞 验证逻辑越权等</p>
<p>其设置主要包括以下内容： </p>
<p>更新（Update Content-Length） 这个选项是用于控制Burp是否自动更新请求消息头中的 Content-Length。 </p>
<p>解压和压缩（Unpack gzip &#x2F; deflate） 这个选项主要用于控制Burp是否自动解压或压缩服务端响 应的内容。</p>
<p> 跳转控制（Follow redirections） 这个选项主要用于控制Burp是否自动跟随服务端进行请求跳 转，比如服务端返回状态码为302，是否跟着应答跳转到302指向的URL地址。 它有4个选项，分别 是永不跳转（Never），站内跳转（On-site only）、目标域内跳转（In-scope only）、始终跳转 （Always）。其中永不跳转、始终跳转比较好理解，站内跳转是指当前的同一站点内跳转，目标域 跳转是指Target scope中配置的域可以跳转。 </p>
<p>跳转中处理Cookie（Process cookies in redirections） 这个选项如果选中，则在跳转过程中设置 的Cookie信息，将会被带到跳转指向的URL页面，可以进行提交。</p>
<p> 视图控制（View） 这个选项是用来控制Repeater的视图布局。</p>
<p> 其他操作（Action） 通过子菜单方式，指向Burp的其他工具组件中</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/source/categories/Penetration-Testing-Basic/">Penetration Testing Basic</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/source/tags/tools/">tools</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2024/07/08/SQL注入/"><span>SQL注入 二开desu</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/07/08/SQL注入/" rel="bookmark">
        <time class="entry-date published" datetime="2024-07-08T02:55:30.535Z">
          2024-07-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="SQL注入二开"><a href="#SQL注入二开" class="headerlink" title="SQL注入二开"></a>SQL注入二开</h1><p>本教程基于SQL i-Labs,pikachu,dvwa等靶场做拓展</p>
<h1 id="基本原理和概念简介"><a href="#基本原理和概念简介" class="headerlink" title="基本原理和概念简介"></a>基本原理和概念简介</h1><p>SQL注入是黑客攻击最常见的方法，SQL注入作为OWASP中四大Web应用程序十大安全漏洞之一，也可以被一些没有太多网络安全技术“脚本小子”利用，因此掌握SQL注入原理和预防机制非常重要</p>
<h1 id="HOW-to-build-SQLI-Lab"><a href="#HOW-to-build-SQLI-Lab" class="headerlink" title="HOW to build SQLI-Lab"></a>HOW to build SQLI-Lab</h1><h3 id="简单的部署"><a href="#简单的部署" class="headerlink" title="简单的部署"></a>简单的部署</h3><p>图方便的话 直接通过Docker部署就可以了</p>
<p>也可以部署在Web应用系统平台，</p>
<h3 id="从０开始部署"><a href="#从０开始部署" class="headerlink" title="从０开始部署"></a>从０开始部署</h3><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240708172147084.png" alt="image-20240708172147084"></p>
<h3 id="Web应用程序系统"><a href="#Web应用程序系统" class="headerlink" title="Web应用程序系统"></a>Web应用程序系统</h3><p>Web应用程序系统的总体体系结构如图一所示</p>
<p>客户端是浏览器，服务端通常包括了Web服务器，数据库服务器和高级语言解释器，典型的Web服务器架构包括</p>
<p>Apache+PHP+MySQL</p>
<p>IIS＋ASP+MYSQL等</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240708171810391.png" alt="image-20240708171810391"></p>
<h1 id="HOW-does-it-form-–SQL-INJECTION"><a href="#HOW-does-it-form-–SQL-INJECTION" class="headerlink" title="HOW does it form –SQL INJECTION"></a>HOW does it form –SQL INJECTION</h1><p>SQL注入本质是攻击者在Web表单或者URL中插入SQL命令或者片段到查询字符串中,当Web服务器没有严格验证输入和传递字符串的有效性时,攻击者就可以达到<strong>欺骗数据库服务器</strong>,执行恶意SQL命令的效果</p>
<p>在此之前还要了解一个概念**’隐式转换’**</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240708173609585.png" alt="image-20240708173609585"></p>
<h1 id="SQL-INJECTION-LIST"><a href="#SQL-INJECTION-LIST" class="headerlink" title="SQL INJECTION LIST"></a>SQL INJECTION LIST</h1><p>包括了</p>
<p>同义SQL注入,联合注入,基于报错的注入,盲注.</p>
<h4 id="Tautologic-SQL注入-真理SQL"><a href="#Tautologic-SQL注入-真理SQL" class="headerlink" title="Tautologic SQL注入(真理SQL)"></a>Tautologic SQL注入(真理SQL)</h4><p>这是一种简单的攻击方法,在系统原SQL命令中插入了一个tautologic(常为正确的)条件子句,使原SQL语句的条件限定不起作用.</p>
<h4 id="联合SQL注入"><a href="#联合SQL注入" class="headerlink" title="联合SQL注入"></a>联合SQL注入</h4><p>本质上利用了SQL命令中的联合查询,从而可以执行插入的查询,从特定的数据表中窃取信息</p>
<p>建议在此之前 先学会基本的SQL注入的增删改查,并清除SQL库表的结构如何</p>
<h4 id="基于报错的SQL注入"><a href="#基于报错的SQL注入" class="headerlink" title="基于报错的SQL注入"></a>基于报错的SQL注入</h4><p>攻击者将格式错误的SQL命令作为攻击负载使系统返回一些报错,从而使系统返回一些过度暗示的信息</p>
<p>比如说Order by 1—–n(列溢出报错)</p>
<h4 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h4><p>对于盲注攻击,攻击者会构造一些SQL查询条件,系统对这些查询条件的不同状态会有不同响应,进而获得系统的内部信息</p>
<h1 id="SQL-injection-Begin"><a href="#SQL-injection-Begin" class="headerlink" title="SQL injection Begin"></a>SQL injection Begin</h1><h2 id="数字型—最基本的检验"><a href="#数字型—最基本的检验" class="headerlink" title="数字型—最基本的检验"></a>数字型—最基本的检验</h2><p>数字型可以检验程序本身是否有对用户的输入做任何的额外处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">------------------------测试步骤-----------------------</span><br><span class="line">1.加单引号</span><br><span class="line">URL:www.text.com/text.php?id=1&#x27;]</span><br><span class="line">对应数据服务器响应的SQL命令：</span><br><span class="line">select * from table where id =1&#x27;</span><br><span class="line">这时SQL语句出错，程序无法从数据库中查询出数据，此时可以判断出大概率存在注入，因为只有服务器将对应的单引号一起当作SQL语句执行了才会出现报错，但这也并不绝对，也有可能是程序本身的问题</span><br><span class="line">2.加 and 1=1</span><br><span class="line">URL：www.text.com/text.php?id=1 and 1=1</span><br><span class="line">对应数据服务器响应的SQL命令：</span><br><span class="line">select * from table where id =1 and 1=1</span><br><span class="line">这时语句执行一定是正常的，因为加入了tautologic式的条件子句</span><br><span class="line">3.加 and 1=2</span><br><span class="line">URL：www.text.com/text.php?id=1 and 1=2</span><br><span class="line">对应数据服务器响应的SQL命令</span><br><span class="line">select * from table where id =1 and 1=2</span><br><span class="line">这时语句可以正常执行但无法查询出任何结构，返回数据与原始网页会存在一定的差异</span><br></pre></td></tr></table></figure>

<p>如果这三个payload传入过后同上述代码块中提出的响应是一致的，那么程序本身就是并没有对用户的输入做任何额外处理的，则可以判断该URL存在数字型注入</p>
<h2 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h2><p>当传入的参数类型为字符串时，若存在漏洞则称为字符型漏洞，字符型和数字型最大的一个区别在于数字型不需要单引号来闭合而字符串一般需要单引号来闭合对应传入的参数</p>
<p>字符型语句如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where id = ‘admin’</span><br></pre></td></tr></table></figure>

<p>因此在构造payload时通过闭合单引号可以成功执行语句</p>
<p>比方</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240708200640557.png" alt="image-20240708200640557"></p>
<p>–为什么要这么做</p>
<p>首先服务端要求我们传入的参数是字符型 在传入的过程中需要将我们自己的恶意指令注入就需要首先满足隐式转换的条件–即先让它接收到需要的字符型变量，然后再通过一些条件子句代入我们自己的语句</p>
<p>也就是说 我们可以这么做</p>
<p>原本的查询语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where name =&#x27;（用户输入点）&#x27;+后续语句</span><br></pre></td></tr></table></figure>

<p>这个时候我们在输入点输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; or 1=1 #</span><br></pre></td></tr></table></figure>

<p>那么可以如此合成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where name =&#x27; 1&#x27; or 1=1 #&#x27;+后续语句</span><br></pre></td></tr></table></figure>

<p>可以发现不但闭合了前面的语句，同时通过条件语句插入了攻击者的语句，并注释（使无效化）后面可能会出现的另外一些条件语句。</p>
<p>可以用一句话很优雅的总结数字型和字符型</p>
<p>​                              <strong>—猎人往往以猎物的方式出现—</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240708201225404.png" alt="image-20240708201225404"></p>
<h2 id="Union注入"><a href="#Union注入" class="headerlink" title="Union注入"></a>Union注入</h2><p>联合查询可以一句SQL语句中执行多个查询任务，把查询任务从一个表追加到另外一个表，使用UNION或者UNION　ALL来实现</p>
<p>UNION ALL和UNION的区别是UNION ALL操作符可以查询重复的值</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240708202413083.png" alt="image-20240708202413083"></p>
<p>使用UNION注入也是有前提条件的,Union all左右两边查询的列数必须一致</p>
<p>以上图为例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id,first_name <span class="keyword">from</span> users <span class="keyword">where</span> user_id<span class="operator">=</span><span class="number">1</span> <span class="keyword">union</span> <span class="keyword">all</span> <span class="keyword">select</span> user_id,first_name,last_name <span class="keyword">from</span> users <span class="keyword">where</span> user_id<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这个时候你可以发现,union all操作符前的sql语句查询了users表中user_id&#x3D;1所对应的user_id列和first_name.而在union操作符后的sql语句则不同,其对应多查询了一个last_name参数，这个时候查询语句不成立。</p>
<h3 id="怎么确定字段数"><a href="#怎么确定字段数" class="headerlink" title="怎么确定字段数"></a>怎么确定字段数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># by2时回显正常</span><br><span class="line">order by 2#</span><br><span class="line"># by3时回显异常</span><br><span class="line">order by 3#</span><br></pre></td></tr></table></figure>

<p>思考：<br>1.为什么用order by 可以证明前面语句查询了三列数据呢？<br>2.我们为什么要知道前面查询了多少语句呢？<br>解：<br>第一题：<br>首先我们要知道order by的作用：order by 简单的来说 就是对前面查询的数据进行分组，分组依据是前面查询的内容的属性。比如说前面查询的数据是甲、乙、丙，我们可以根据这三种属性的一到三种进行分类，但是不能超过三种。所以上面order by 4 会报错误信息。因此可以依据此来判断前面查询了几列数据。<br>第二题：<br>因为使用union函数进行查询时，union前面查询语句查询的元素与后面查询语句查询的元素要数量上一样，所以我们必需要知道前面语句查询了多少个元素。比如，此语句：select 甲,乙,丙 union select 1,2,3 因为前面查询的语句有三个元素（甲，乙，丙），所以后面查询的语句必须是三个元素（1，2，3）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709100240768.png" alt="image-20240709100240768"></p>
<p>类似上图所说的 我们就可以通过联合查询得到一些关键性的信息</p>
<p>这里我们也可以介绍一个比较重要的知识点，在MYSQL５.０以上版本，存在一个自带的数据库:information_schema(重点)</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709101446333.png" alt="image-20240709101446333"></p>
<p>information_schema数据库中还要三个表非常重要：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SCHEMATA:　表里包含所有数据库的名字</span><br><span class="line">TABLES：　　表里包含所有数据库的所有表</span><br><span class="line">COLUMNS：　　表里包含所有数据库的所有表的所有字段</span><br></pre></td></tr></table></figure>

<p>联合注入的过程:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">１.判断是否存在注入，注入是字符型还是整数型</span><br><span class="line">２.猜解SQL查询语句中的字段数（ｏｒｄｅｒ　ｂｙ）</span><br><span class="line">３.确定显示位</span><br><span class="line">４.获取当前数据库（爆库</span><br><span class="line">５.获取数据库中的表（爆表</span><br><span class="line">６.获取表中的字段名（爆字段</span><br><span class="line">７.下载数据（爆数据</span><br><span class="line">这里以Pikachu联系平台为例</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709110242890.png" alt="image-20240709110242890"></p>
<p>这里截取一个基本的流程 以DVWA靶场为例</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709110813626.png" alt="image-20240709110813626"></p>
<p>一般爆出的密码是经过一层加密的,这个时候可以利用在线工具对应解码爆出真实的密码</p>
<p>这里附上在线工具</p>
<p><a target="_blank" rel="noopener" href="https://cmd5.com/">md5在线解密破解,md5解密加密 (cmd5.com)</a></p>
<h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><p>报错注入顾名思义主要是利用数据库报错来进行判断是否存在注入点，如果不符合数据库语法规则就会 报错并返回错误信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">常用的特殊字符：&#x27; \ ; %00 ) ( # &quot;</span><br></pre></td></tr></table></figure>

<p>在MySQL高版本中添加了对XML文档进行查询和修改的函数,这两个函数常用于报错注入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extractvalue()</span><br><span class="line">updatexml()</span><br></pre></td></tr></table></figure>

<p>原因:当这两个函数在执行时,如果出现XML文档路径错误就会产生报错.</p>
<h3 id="extractvalue"><a href="#extractvalue" class="headerlink" title="extractvalue()"></a>extractvalue()</h3><ul>
<li>此函数从目标XML中返回包含所查询值的字符串,语法:extractvalue(XML_document,xpath_string)</li>
</ul>
<p>第一个参数:</p>
<p>string格式,即XNL文档对象名称</p>
<p>第二个参数:Xpath_string(Xpath形式的字符串,为XML文档的路径)</p>
<p>extractvalue使用时若Xpath_string格式出错,mysql数据库服务器是会爆出错误的,<strong>对应的报错也会很明显的给我们指出错误类型为xpath语法错误</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709151441863.png" alt="image-20240709151441863"></p>
<p>extractvalue原本是用于从documentr返回包含string的字符串,那么string参数不符合xpath的语法就会爆出错误,将查询结果同步放在信息里.<strong>这本质上也是利用了该函数报错的危险特性,将我们想要查询的结果以非xpath语法格式强行放入该函数,”勒令”它帮我们查询需要的信息</strong></p>
<h4 id="这里突然插入-SQL注入的基本思路"><a href="#这里突然插入-SQL注入的基本思路" class="headerlink" title="-这里突然插入  SQL注入的基本思路-"></a>-这里突然插入  SQL注入的基本思路-</h4><p>SQL注入本质上其实也都明白了,就是利用现成的服务端给我们预留的查询语句进而实现从无关紧要的信息越位到更为重要更为核心的信息</p>
<p><strong>那么首先我们要搞懂的就是该如何利用这条服务端留给我们的现成的语句了</strong></p>
<p>其实道理很简单:</p>
<p>一,先搞清楚服务端目前供给我们来查询的是什么</p>
<p>那么这个时候就是可以通过思考SQL典型的树状结构,一步一步爆出我们想要的东西</p>
<p>SQL经典结构:   库(schema)–&gt;表(tables)—&gt;字段(column)</p>
<p>从这些最基本的出发,我们可以逐步摸清并加以利用,实现从边缘信息到重要信息的爬取</p>
<h4 id="注入思路实践简述"><a href="#注入思路实践简述" class="headerlink" title="注入思路实践简述"></a>注入思路实践简述</h4><p><strong>爆库名</strong>–&gt;<strong>爆表数</strong>–&gt;<strong>爆表名</strong>–&gt;<strong>爆列名</strong>–&gt;<strong>获得用户名和密码</strong></p>
<p>那么这里开始利用extractvalue()做一些经典的操作(doge)</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709192227234.png" alt="image-20240709192227234"></p>
<h3 id="updatexml-函数"><a href="#updatexml-函数" class="headerlink" title="updatexml()函数"></a>updatexml()函数</h3><p>updatexml()是一个使用不同的XML标记匹配和替换XML块的函数</p>
<p>作用:该百年文档中符合条件的节点的值</p>
<p>语法:</p>
<p>update(XML_document, xpath_string, new_value)</p>
<p>第一个参数;string格式,为XML文档对象的名称</p>
<p>第二个参数:代表路径,xpath形式的字符串例如&#x2F;title</p>
<p>第三个参数:string格式,替换查找到的符合条件的数据</p>
<p>updatexml使用同extractvalue()函数,都是当出现错误时爆出错误信息,并弹出对应的暗示信息,这个就没什么好说的了,直接截图套路即可,自行copy即可(doge)</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709192932960.png" alt="image-20240709192932960"></p>
<p>其实本质很简单,只是单纯的用两个0x7e占位罢了</p>
<h2 id="盲注-1"><a href="#盲注-1" class="headerlink" title="盲注"></a>盲注</h2><h3 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h3><p>盲注顾名思义,就是一抹黑,无回显无报错的查询.</p>
<h4 id="1-只能判断是否存在注入和注入的类型"><a href="#1-只能判断是否存在注入和注入的类型" class="headerlink" title="1.只能判断是否存在注入和注入的类型"></a>1.只能判断是否存在注入和注入的类型</h4><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709193722352.png" alt="image-20240709193722352"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709193749808.png" alt="image-20240709193749808"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709193815739.png" alt="image-20240709193815739"></p>
<p>由图可知,对应的盲注就是像上面这样只有两种反馈信息,要么就是查询到了,要么就是查询不到,那么我们该怎么判断是否成功注入了呢?那么就要推翻我们只能从查询信息和报错信息中汲取攻击面的固有思维,从别的方面深入,一击毙命.</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709194633365.png" alt="image-20240709194633365"></p>
<p>这里以pikachu靶场中的盲注题型为例,假设一开始我们已知用户vince,想爆出他们的密码</p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">构造ID取值</th>
<th align="center">反馈</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">vince</td>
<td align="center">存在信息回显</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">‘</td>
<td align="center">不存在信息回显</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">vince’ and 1&#x3D;1#</td>
<td align="center">存在信息回显</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">vince’ and 1&#x3D;2#</td>
<td align="center">不存在信息回显</td>
</tr>
</tbody></table>
<p>由条件3和4的构造真假返回对应不同的结果,可知存在SQL注入漏洞</p>
<p>不过只能知道存在是不够的,要加以利用才是硬道理</p>
<h4 id="2-猜解当前数据库名称"><a href="#2-猜解当前数据库名称" class="headerlink" title="2.猜解当前数据库名称"></a>2.猜解当前数据库名称</h4><h5 id="1-猜解数据库名称长度-二分法"><a href="#1-猜解数据库名称长度-二分法" class="headerlink" title="1)猜解数据库名称长度(二分法)"></a>1)猜解数据库名称长度(二分法)</h5><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709195523654.png" alt="image-20240709195523654"></p>
<h5 id="2）判断数据库名称的字符组成元素"><a href="#2）判断数据库名称的字符组成元素" class="headerlink" title="2）判断数据库名称的字符组成元素"></a>2）判断数据库名称的字符组成元素</h5><p>在给定的字符串中利用substr()函数，从指定位置开始截取指定长度的字符串，分离出数据库名称的每个 位置的元素，并分别将其转换为ASCII码，与对应的ASCII码值比较大小，找到比值相同时的字符，然后 逐个击破。</p>
<p><a target="_blank" rel="noopener" href="https://www.sojson.com/asciitable.html">ASCII码对照表|ASCII编码 (sojson.com)</a></p>
<h5 id="substr的用法"><a href="#substr的用法" class="headerlink" title="substr的用法"></a>substr的用法</h5><p>substr在这里主要用作将字符串中单单一个字符截取出来,后续我们使用ascil函数与二分法逐步迭代出我们需要的数字</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709200603601.png" alt="image-20240709200603601"></p>
<h5 id="猜解数据库中的表名"><a href="#猜解数据库中的表名" class="headerlink" title="猜解数据库中的表名"></a>猜解数据库中的表名</h5><p><strong>猜解表的个数</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709200545105.png" alt="image-20240709200545105"></p>
<p><strong>猜解表名–从长度到具体的字符组成</strong></p>
<p>这里是猜解长度</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709200844644.png" alt="image-20240709200844644"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709201142364.png" alt="image-20240709201142364"></p>
<p>剩下的字段名字段值不过多赘述,流程是一致的</p>
<p>最后如果密码有经过某些解密方法那么为只需要重新带回就好了.最后验证一下字段的有效性就可以了</p>
<p>最后在这里想说的是 手工爆破的工作量是很大的,可以尝试学习python自动化脚本精简掉大部分的内容</p>
<h3 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h3><p>倘若界面返回值只有一种True,无论输入任何值,返回情况都会按正常来处理,加入特定的时间函数,通过查看WEB页面返回的时间差来判断注入的语句是否正确.</p>
<h4 id="猜解数据库的名称"><a href="#猜解数据库的名称" class="headerlink" title="猜解数据库的名称"></a>猜解数据库的名称</h4><p>其实本质上和布尔盲注的区别就在于, 它将返回信息转化成了响应时间上的区别,若判断条件为真,则执行sleep(n)函数,达到正常响应时间短基础上再延迟相应时间n瞄的效果;若判断条件为假则返回设置的1,此时不执行sleep(n)函数</p>
<p>payload</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">and if(length(database())=4,sleep(5),1);#</span><br><span class="line">1&#x27; and if(ascii(substr(database(),1,1))=100,sleep(5),1);#</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>盲注需要这样集中函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">length（） 返回字符串的长度</span><br><span class="line">substr（） 截取字符串</span><br><span class="line">ascil（） 返回字符对应的ASCII码</span><br><span class="line">sleep（） 将程序挂起一段时间</span><br></pre></td></tr></table></figure>

<h2 id="堆叠查询注入"><a href="#堆叠查询注入" class="headerlink" title="堆叠查询注入"></a>堆叠查询注入</h2><p>堆叠注入，从名词的含义就可以看到应该是<strong>一堆 sql 语句（多条）一起执行，而在真实的运用中也是这样的</strong>。我们知道在Mysql中，主要是命令行中，每一条语句结尾加 ; 表示语句结束，<strong>这样我们就想到了是 不是可以多句一起使用。</strong>其原理也很简单，就是将原来的语句构造完后加上分号，代表该语句结束，后 面再输入的就是一个全新的SQL语句，这个时候使用增删改查毫无限制</p>
<p>堆叠注入的使用条件是十分有限的,极有可能收到API或者数据库引擎,又或者权限的限制,只有当调用数据库函数支持执行多条SQL语句时才能使用,</p>
<p>利用mysqli_multi_query()函数就支持多条SQL语句同时执行，但实际情况中，如PHP为了防止所谓的SQL注入机制，调用数据库的函数往往都只是mysqli_query()函数,只能执行一条语句,所以说堆叠注入的使用条件是十分有限的且实战中很少会有这种啥防护器也不上的网页()</p>
<p>因此SQL注入分类总结可以如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.根据查询字段：数字型，字符型</span><br><span class="line">2.根据查询方式：Union注入、堆叠注入</span><br><span class="line">3.根据回显：报错、盲注</span><br></pre></td></tr></table></figure>

<h2 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h2><p>二次注入是指存入存出的过程中,存入数据库的时候做了过滤但是去取出来的时候没有做过滤z,而产生的数据库注入.</p>
<h3 id="插入恶意数据"><a href="#插入恶意数据" class="headerlink" title="插入恶意数据"></a>插入恶意数据</h3><p>在第一次想数据库插入数据时,使用addslashes对其中的特殊字符进行转义,但是addslashes函数有一个特点;虽然参数过滤后添加\进行转义,但是\并不会插入到数据库中,写入时还是保留了原来的数据.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在MySQL中，反斜线在字符串中属于是转义字符，经过语法解析器解析时会进行一次转义，所以当我们插入反斜线也就是通过insert“\”时，如insert “\”在数据库中只会存储“”，第一个反斜线（\)被当作转义字符处理</span><br></pre></td></tr></table></figure>

<h3 id="引用恶意数据"><a href="#引用恶意数据" class="headerlink" title="引用恶意数据"></a>引用恶意数据</h3><p>在将数据存入到数据库中之后,开发者就认为数据可信了.在下一次进行需要进行查询的时候,直接从数据库中取出了脏数据,没有进行进一步的检验和处理,这样就会造成SQL的二次注入</p>
<p><strong>比如第一次插入数据的时候,数据中带有单引号,直接插入到了数据库中–然后下一次使用在拼凑的过程中就形成了二次注入.</strong></p>
<p>二次注入漏洞原理示意图</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709214142033.png" alt="image-20240709214142033"></p>
<h2 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h2><h3 id="宽字节概念"><a href="#宽字节概念" class="headerlink" title="宽字节概念"></a>宽字节概念</h3><p>1、如果一个字符的大小是一个字节的，称为窄字节；</p>
<p> 2、如果一个字符的大小是两个及以上字节的，称为宽字节； 像GB2312、GBK、GB18030、BIG5、Shift_JIS等编码都是常见的宽字节字符集。 英文默认占一个字节，中文占两个字节。</p>
<h3 id="宽字节注入原理"><a href="#宽字节注入原理" class="headerlink" title="宽字节注入原理"></a>宽字节注入原理</h3><p>宽字节注入利用给MYSQL的一个特性,利用GBK编码的时候,会认为两个字符是一个汉字,为了防止网站被SQL注入,网站开发人员自然也会做一些防护,最基础的就是对一些特殊字符进行转义</p>
<p><strong>统筹前面学习的内容,可以发现SQL注入最关键的一步就是让引号闭合和跳出引号,如果无法跳出引号,那么输入的内容就永远在引号里,即永远是字符串,无法实现SQL注入</strong></p>
<p>网站开发者也想到了这一步,于是他们痛定思痛开始进步,从最简单的一个措施开始做起:<strong>转义</strong>—<strong>对输入的敏感内容、特殊字符进行转换，比方将引号替换为null</strong></p>
<h4 id="addslashes（）函数"><a href="#addslashes（）函数" class="headerlink" title="addslashes（）函数"></a>addslashes（）函数</h4><p>1、该函数会在预定义字符之前添加反斜线进行转义，<br>2、预定义字符一般有：单引号 双引号 反斜线 null</p>
<p>所谓的转义就是将预定义字符加上反斜线，使其失去占位构造语句的作用，使预定义字符仅仅是一个普通的字符串</p>
<p><strong>以pikachu数据库中的member表为例：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709220531493.png" alt="image-20240709220531493"></p>
<p>通过前面的SQL注入实验可以发现，字符型的注入点都是通过单引号闭合前后的反馈来判断的，但遇到addslashes（）函数时，单引号会被转义，导致我们用来判断注入点的单引号失效，所以我们的目的就是使转义符\失效，使单引号逃逸</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1）kobe%df&#x27; or 1=1# //用户在前端输入</span><br><span class="line">2）kobe%df\&#x27; or 1=1# //addslashes()函数对用户输入进行检测，在单引号前面添加转义符</span><br><span class="line">\</span><br><span class="line">kobe%df%5c%27 or 1=1# //转义符 \ 编码成为%5c</span><br><span class="line">%df%5c = 運 //到达数据库，GBK编码</span><br><span class="line">3)kobe運&#x27; or 1=1#</span><br><span class="line">select id,email from member where username=&#x27;kobe運&#x27; or 1=1#&#x27; //从单引号中逃逸出来</span><br></pre></td></tr></table></figure>

<p>[GBK 编码范围, GBK 编码表 (qqxiuzi.cn)](<a target="_blank" rel="noopener" href="https://www.qqxiuzi.cn/zh/hanzi-gbk-bianma.php#:~:text=GBK%E7%BC%96%E7%A0%81%EF%BC%8C%E6%98%AF%E5%AF%B9GB2312%E7%BC%96%E7%A0%81%E7%9A%84%E6%89%A9%E5%B1%95%EF%BC%8C%E5%9B%A0%E6%AD%A4%E5%AE%8C%E5%85%A8%E5%85%BC%E5%AE%B9GB2312-80%E6%A0%87%E5%87%86%E3%80%82,GBK%E7%BC%96%E7%A0%81%E4%BE%9D%E7%84%B6%E9%87%87%E7%94%A8%E5%8F%8C%E5%AD%97%E8%8A%82%E7%BC%96%E7%A0%81%E6%96%B9%E6%A1%88%EF%BC%8C%E5%85%B6%E7%BC%96%E7%A0%81%E8%8C%83%E5%9B%B4%EF%BC%9A8140%EF%BC%8DFEFE%EF%BC%8C%E5%89%94%E9%99%A4xx7F%E7%A0%81%E4%BD%8D%EF%BC%8C%E5%85%B123940%E4%B8%AA%E7%A0%81%E4%BD%8D%E3%80%82">https://www.qqxiuzi.cn/zh/hanzi-gbk-bianma.php#:~:text=GBK编码，是对GB2312编码的扩展，因此完全兼容GB2312-80标准。,GBK编码依然采用双字节编码方案，其编码范围：8140－FEFE，剔除xx7F码位，共23940个码位。</a> 共收录汉字和图形符号21886个，其中汉字（包括部首和构件）21003个，图形符号883个。)</p>
<p>原理：前端输入 %df%27 时首先经过 addslashes() 函数转义变成了 %df%5c%27 （ %5c 是反斜杠 \ )， 之后在数据库查询前因为设置了GBK编码，即在汉字编码范围内两个字节都会被重新编码为一个汉字。 然后MySQL服务器就会对查询语句进行GBK编码，即 %df%5c 转换成了汉字”運”，使得单引号成功逃 逸，进而实现SQL注入漏洞</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%df%27 ===&gt; addslashes函数 ===&gt; %df%5c%27 ===&gt; 数据库GBK ===&gt; 運&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709224224722.png" alt="image-20240709224224722"></p>
<h2 id="http-header-和-cookie注入"><a href="#http-header-和-cookie注入" class="headerlink" title="http header 和 cookie注入"></a>http header 和 cookie注入</h2><p>HTTP头注入其实并不是一个新的SQL注入类型,而是指出现SQL注入漏洞的场景,有些时候,后台开发人员为了验证客户端头信息(比如常用的cookie验证),或者通过http header头信息获取客户端的一些资料–比如useragent、acceept字段等，会获取客户端的http header字段内容并用SQL进行处理，如果没有足够的安全检验则会导致对应的SQL注入漏洞。</p>
<p>进入pikachu的http header来进行一下测试:</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709225102261.png" alt="image-20240709225102261"></p>
<p>通过提示 ，我们通过基本的admin&#x2F;123456登录，并获得下列信息</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709225244173.png" alt="image-20240709225244173"></p>
<p>通过登录进去的信息可以猜测，系统后端是不是对http header里面的数据进行了获取，可能也进行了相 关数据库的操作。我们来看一下刚才的抓包，将它发送到Repeater里面，将User-Agent的值删掉，自己 构造一个，还是按照之前的思路，先输入一个单引号：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240710101424266.png" alt="image-20240710101424266"></p>
<p>这个时候发现引发了报错，因此这里基本确定了这里存在http header注入漏洞了，合理猜测数据库使用了insert（）函数进行处理，构造payload</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; or updatexml(1,concat(0x7e,database()),0) or &#x27;</span><br></pre></td></tr></table></figure>

<p>这里开始解释这个payload</p>
<h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="1-SQL-注入和报错利用"><a href="#1-SQL-注入和报错利用" class="headerlink" title="1. SQL 注入和报错利用"></a>1. SQL 注入和报错利用</h4><p>SQL 注入攻击不仅仅是为了修改或读取数据，还可以通过触发错误来泄露数据库内部信息。通过这种方法，攻击者可以获得数据库的架构信息、版本信息等。</p>
<h4 id="2-updatexml-函数的使用"><a href="#2-updatexml-函数的使用" class="headerlink" title="2. updatexml 函数的使用"></a>2. <code>updatexml</code> 函数的使用</h4><p><code>updatexml</code> 是一个 MySQL 函数，通常用于处理 XML 数据。当它的参数不合法时，会触发错误消息。攻击者可以利用这一点，将有用的信息嵌入到错误消息中。</p>
<h4 id="3-报错示例"><a href="#3-报错示例" class="headerlink" title="3. 报错示例"></a>3. 报错示例</h4><p>假设你的 SQL 查询如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sql</span><br><span class="line">复制代码</span><br><span class="line">INSERT INTO logs (user_agent) VALUES (&#x27;&#x27; or updatexml(1,concat(0x7e,database()),0) or &#x27;&#x27;)</span><br></pre></td></tr></table></figure>

<p>其中 <code>updatexml(1,concat(0x7e,database()),0)</code> 部分会触发错误，因为 <code>updatexml</code> 期望的是 XML 文档，但这里传入的是不合法的参数 <code>1</code>。因此，MySQL 会返回一个错误，错误消息中包含了 <code>concat(0x7e,database())</code> 的结果。</p>
<h3 id="触发错误和提取信息"><a href="#触发错误和提取信息" class="headerlink" title="触发错误和提取信息"></a>触发错误和提取信息</h3><p>当上述 SQL 查询执行时，由于 <code>updatexml</code> 函数的参数不合法，MySQL 会生成错误消息。错误消息中将包含 <code>concat(0x7e,database())</code> 的结果，其中 <code>0x7e</code> 是 ASCII 码 <code>~</code>，而 <code>database()</code> 函数返回当前数据库的名称。</p>
<p>错误消息可能类似于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plaintext</span><br><span class="line">复制代码</span><br><span class="line">ERROR 1105 (HY000): XPATH syntax error: &#x27;~current_database_name&#x27;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，错误消息泄露了当前数据库的名称 <code>current_database_name</code>。</p>
<h3 id="为什么需要or"><a href="#为什么需要or" class="headerlink" title="为什么需要or"></a>为什么需要<code>or</code></h3><p><code>or</code>在这里的主要作用是确保注入的代码在逻辑上总是会被评估并执行。即使前面的条件为假（例如空字符串），<code>or</code>会导致SQL引擎继续评估后面的条件。在这个特定的payload中，<code>updatexml</code>函数被设计为引发错误，从而泄露数据库名称。</p>
<h1 id="从MYSQL注入到GetShell"><a href="#从MYSQL注入到GetShell" class="headerlink" title="从MYSQL注入到GetShell"></a>从MYSQL注入到GetShell</h1><p>Mysql支持向外写文件,这里的外指的是服务器的外部,需要用到</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">into</span> outfile</span><br></pre></td></tr></table></figure>

<p>这个命令的作用是将被选择的一行代码写入一个文件中,文件被创建到服务器上,</p>
<p><strong>其中 select into outfile的使用前提是</strong></p>
<p>(1)要知道网站的绝对路径,可以通过开源程序,报错,phpinfo,404页面等一些方式做基本的信息收集</p>
<p>(2)对目录要有写权限,一般image之类的存放图片的目录y欧写入权限</p>
<p>(3)要有mysql file权限,即(能否对系统的文件读取和写操作),默认情况下只有root权限有, <strong>WARING:写的文件名一定是在网站中不存在的,不然会失败</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; union select 1,&quot;&lt;?php eval($_POST[&#x27;a&#x27;]);?&gt;&quot; into outfile &#x27;/var/www/html/shell2.php</span><br></pre></td></tr></table></figure>

<p>在DVWA Low等级的SQL injection中如此输入,后续访问对应的网站目录,可以发现成功注入,并通过蚁剑弹shell</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240710103522276.png" alt="image-20240710103522276"></p>
<h1 id="SQL注入绕过"><a href="#SQL注入绕过" class="headerlink" title="SQL注入绕过"></a>SQL注入绕过</h1><p>绕过的姿势很多,这里介绍几种</p>
<h2 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h2><p>用于只针对于小写或大写的关键字匹配技术,正则表达式&#x2F;express&#x2F;i 表达大小写不敏感,即无法绕过,这是最简单的绕过方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z.com/index.php?page_id=-15 uNIoN sELecT 1,2,3,4</span><br></pre></td></tr></table></figure>

<h2 id="替换关键字"><a href="#替换关键字" class="headerlink" title="替换关键字"></a>替换关键字</h2><p>一般情况下大小写转换无法绕过,而且正则表达式会替换或山粗和select,union这些比较危险的关键字,如果只匹配一次–(也就是不做二次校验,只删去一层危险关键字便通过用户的操作)–只需要<strong>双写关键字</strong>就很容易绕过</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">举例：z.com<span class="operator">/</span>index.php?page_id<span class="operator">=</span><span class="number">-15</span> UNIunionON SELselectECT <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span></span><br></pre></td></tr></table></figure>

<h2 id="使用编码"><a href="#使用编码" class="headerlink" title="使用编码"></a>使用编码</h2><h3 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h3><p>在浏览器中输入一个连接,浏览器会对非保留字符进行URL编码</p>
<p>空格-%20</p>
<p>单引号-%27</p>
<p>左右括号分别是%28 %29</p>
<p><strong>普通的URL编码可能无法实现绕过，需要结合实际场景来判断</strong></p>
<p><strong>比方说URL编码只进行了一次过滤，就可以再编码一次双重编码绕过</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1%2527id=1%252f%252a*/UNION%252f%252a%252a/SELECT</span><br></pre></td></tr></table></figure>

<p>首先，我们需要理解URL编码。<code>%25</code>是<code>%</code>的URL编码。因此，<code>%2527</code>解码后是<code>%27</code>，<code>%252f</code>解码后是<code>%2f</code>，<code>%252a</code>解码后是<code>%2a</code>。</p>
<h3 id="解码后的payload"><a href="#解码后的payload" class="headerlink" title="解码后的payload"></a>解码后的payload</h3><p>通过一次URL解码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plaintext</span><br><span class="line">复制代码</span><br><span class="line">1%27id=1%2f%2a*/UNION%2f%2a%2a/SELECT</span><br></pre></td></tr></table></figure>

<p>再次URL解码后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;id=1/*/UNION/**/SELECT</span><br></pre></td></tr></table></figure>

<h3 id="详细解析"><a href="#详细解析" class="headerlink" title="详细解析"></a>详细解析</h3><ol>
<li>**<code>1&#39;</code>**：这是一个单引号，通常用于结束字符串字面值，打开可能的SQL注入点。</li>
<li>**<code>id=1</code>**：这是一个常规的条件部分，可能是为了符合预期的SQL查询语法。</li>
<li>**<code>/\*/UNION/\**/SELECT</code>**：这是注入的主要部分，其中使用了SQL注释语法<code>/* ... */</code>来插入注释。</li>
</ol>
<h3 id="绕过防护机制"><a href="#绕过防护机制" class="headerlink" title="绕过防护机制"></a>绕过防护机制</h3><ol>
<li><p><strong>注释绕过</strong></p>
<p><code>/*</code>和<code>*/</code>是SQL中的多行注释符号。攻击者利用这些注释符号来分割注入的关键字，使得简单的防护机制难以检测到关键字（如<code>UNION</code>和<code>SELECT</code>）的完整匹配。</p>
<p>在这个例子中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/*/UNION/**/SELECT</span><br></pre></td></tr></table></figure>

<p>这实际上是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/ UNION / SELECT</span><br></pre></td></tr></table></figure>

<p>由于注释的存在，防护机制可能无法检测到完整的<code>UNION SELECT</code>关键字，从而绕过防护。</p>
</li>
</ol>
<h3 id="十六进制编码"><a href="#十六进制编码" class="headerlink" title="十六进制编码"></a>十六进制编码</h3><p>顾名思义用16进制转义</p>
<h2 id="注释绕过"><a href="#注释绕过" class="headerlink" title="注释绕过"></a>注释绕过</h2><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240710104600689.png" alt="image-20240710104600689"></h2><h2 id="等价函数与命令"><a href="#等价函数与命令" class="headerlink" title="等价函数与命令"></a>等价函数与命令</h2><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240710105238466.png" alt="image-20240710105238466"></p>
<h2 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h2><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240710105608748.png" alt="image-20240710105608748"></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/source/categories/Application-vulnerabilities/">Application vulnerabilities</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/source/tags/OWASP/">OWASP</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2024 Satoru
    
  </p>
</footer>
    
    
  </div>
</div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>