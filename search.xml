<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Burpsuite 从入门到精通desu</title>
    <url>/2024/07/08/Burpsuite%20%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/</url>
    <content><![CDATA[<h1 id="Burpsuite从入门到入土"><a href="#Burpsuite从入门到入土" class="headerlink" title="Burpsuite从入门到入土"></a>Burpsuite从入门到入土</h1><p>在Burp suite的使用中，会出现如下的选项</p>
<h2 id="Raw："><a href="#Raw：" class="headerlink" title="Raw："></a>Raw：</h2><p>视图主要显示web请求的真实格式，包含请求地址，http协议版本，主机头。浏览器信息，Accept可接受的内容类型，字符集，编码方式，cookie等。通过手工修改这些信息可以完成一些渗透测试的工作</p>
<h2 id="Params"><a href="#Params" class="headerlink" title="Params:"></a>Params:</h2><p>主要显示客户端请求的参数信息 ，包括GET和POST传参aders：</p>
<p>这个视图显示的信息和Raw的信息类似，只不过这个更加直观</p>
<h2 id="Hex："><a href="#Hex：" class="headerlink" title="Hex："></a>Hex：</h2><p>这个视图显示Raw的十六进制内容</p>
<p>一般开启Burp Proxy是不会拦截静态文件的，同时用户可以修改拦截作用域个性化Burp的使用效果。所有拦截到的信息和历史信息都可以通过右击弹出菜单，发送到其他组件。，<strong>如Scanner、Repeater、Intruder、Sequencer、Decoder、 Comparer、Extender等</strong></p>
<h2 id="数据拦截与控制"><a href="#数据拦截与控制" class="headerlink" title="数据拦截与控制"></a>数据拦截与控制</h2><p>较为基础</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240706203308670.png" alt="image-20240706203308670"></p>
<h1 id="Burp的相关配"><a href="#Burp的相关配" class="headerlink" title="Burp的相关配"></a>Burp的相关配</h1><p>当我们打开可选项设置选项卡Options，从界面显示来看，常用的部分主要包括以下几大板块（涉及 https的功能不包含在本章内容里，后面会一章专门叙述）：</p>
<h2 id="客户端请求消息拦截"><a href="#客户端请求消息拦截" class="headerlink" title="客户端请求消息拦截"></a>客户端请求消息拦截</h2><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240706203532487.png" alt="image-20240706203532487"></p>
<p>这个可以通过添加一些个性化的条件语句</p>
<h3 id="有四个选项"><a href="#有四个选项" class="headerlink" title="有四个选项"></a>有四个选项</h3><p>操作符的与或非</p>
<p>匹配类型（可以基于域名 IP地址 协议 请求方法 URL  文件类型 参数 cookies 头部</p>
<p>内容 状态码）</p>
<p>关系：关系则是匹配或不匹配</p>
<p>条件：条件则是对关键字的一些要求</p>
<p><a href="https://blog.csdn.net/YuiJar/article/details/81316478">正则表达式的语法及匹配规则（基础）_正则匹配位不定长度的-CSDN博客</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240706204059953.png" alt="image-20240706204059953"></p>
<p>勾选自动修复丢失行可以防止一些用户在修改数据包过程中的失误，比如请求空行忘记给出等</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240706204227208.png" alt="image-20240706204227208"></p>
<p>如果 自动更新文本长度被选中，则当请求消息被修改后，Content-Length也 会自动被修改，替换为与之相对应的值。</p>
<h2 id="服务端返回消息拦截"><a href="#服务端返回消息拦截" class="headerlink" title="服务端返回消息拦截"></a>服务端返回消息拦截</h2><p> 基本和代理拦截规则一致</p>
<h2 id="服务端返回消息修改"><a href="#服务端返回消息修改" class="headerlink" title="服务端返回消息修改"></a>服务端返回消息修改</h2><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240706204353108.png" alt="image-20240706204353108"></p>
<h2 id="正则表达式配置"><a href="#正则表达式配置" class="headerlink" title="正则表达式配置"></a>正则表达式配置</h2><p>正则表达式主要用于自动替换请求信息或者响应包返回信息的某些值和文本</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240706204545884.png" alt="image-20240706204545884"></p>
<h1 id="历史记录"><a href="#历史记录" class="headerlink" title="历史记录"></a>历史记录</h1><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240706204640322.png" alt="image-20240706204640322"></p>
<p>HTTP history界面由筛选过滤器、历史记录列表、消息详情3个部分组成。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240706204755399.png" alt="image-20240706204755399"></p>
<p>单击可以查看请求包和响应包</p>
<p><strong>在消息上双击则会弹出此条消息的详细对话框</strong></p>
<p>当我们在做系统的安全评估过程中，会在HTTP history中保存了大量的日志记录，为了更便捷的管理历 史消息，Burp提供了筛选过滤器功能。当我们点击HTTP history标签下的Filter时，将弹出筛选过滤器界 面。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240706204953362.png" alt="image-20240706204953362"></p>
<p>按照过滤条件的不同，筛选过滤器划分出7个子板块，分别是 </p>
<h2 id="按照请求类型过滤："><a href="#按照请求类型过滤：" class="headerlink" title="按照请求类型过滤："></a>按照请求类型过滤：</h2><p>你可以选择仅显示当前作用域的、仅显示有服务端响应的和仅显示带有请求参 数的消息。当你勾选“仅显示当前作用域”时，此作用域需要在Burp Target的Scope选项中进行配 置，需要搭配Burp Target使用（后面会说）。 </p>
<h2 id="按照MIME类型（多用途互联网邮件扩展类型）过滤："><a href="#按照MIME类型（多用途互联网邮件扩展类型）过滤：" class="headerlink" title="按照MIME类型（多用途互联网邮件扩展类型）过滤："></a>按照MIME类型（多用途互联网邮件扩展类型）过滤：</h2><p>你可以控制是否显示服务端返回的不同文件 类型的消息，比如只显示HTML、CSS或者图片。过滤器目前支持HTML、Script、XML、CSS、其 他文本、图片、Flash、二进制文件8种形式。 </p>
<h2 id="按照服务器返回的HTTP状态码过滤："><a href="#按照服务器返回的HTTP状态码过滤：" class="headerlink" title="按照服务器返回的HTTP状态码过滤："></a>按照服务器返回的HTTP状态码过滤：</h2><p>Burp根据服务器的状态码，按照2XX，3XX，4XX，5XX分别 进行过滤。比如，如果你只想显示返回状态码为200的请求成功消息，则勾选2XX。</p>
<h2 id="按照查找条件过滤："><a href="#按照查找条件过滤：" class="headerlink" title="按照查找条件过滤："></a>按照查找条件过滤：</h2><p>此过滤器是针对服务端返回的消息内容，与输入的关键字进行匹配，具体的匹 配方式，你可以选择 （1）正则表达式 （2）大小写敏感 （3）否定查找 三种方式可以任意组合，前面两种匹配方式容易理解，第3种匹配方式是指与关键字匹配上的将不 再显示。 </p>
<h2 id="按照文件类型过滤："><a href="#按照文件类型过滤：" class="headerlink" title="按照文件类型过滤："></a>按照文件类型过滤：</h2><p>通过文件类型在过滤消息列表，这里有两个选择可供操作。一是仅显示哪些， 另一个是不显示哪些。如果是仅显示哪些，在show only的输入框中填写显示的文件类型，同样， 如果不显示哪些文件类型，只要在hide的输入框中填写不需要显示的文件类型即可。</p>
<h2 id="按照注解过滤："><a href="#按照注解过滤：" class="headerlink" title="按照注解过滤："></a>按照注解过滤：</h2><p>此过滤器的功能是指，根据每一个消息拦截时候的备注或者是否高亮来作为筛选条 件控制哪些消息在历史列表中显示。 </p>
<h2 id="按照监听端口过滤："><a href="#按照监听端口过滤：" class="headerlink" title="按照监听端口过滤："></a>按照监听端口过滤：</h2><p>此过滤器通常使用于当我们在Proxy Listeners中多个监听端口时，仅仅显示某 个监听端口通信的消息，一般情况下，搭配中间件、数据库等漏洞使用。</p>
<h1 id="SSL和Proxy高级选项"><a href="#SSL和Proxy高级选项" class="headerlink" title="SSL和Proxy高级选项"></a>SSL和Proxy高级选项</h1><h2 id="HTTP协议信息的拦截和处理："><a href="#HTTP协议信息的拦截和处理：" class="headerlink" title="HTTP协议信息的拦截和处理："></a>HTTP协议信息的拦截和处理：</h2><h2 id="监听设置"><a href="#监听设置" class="headerlink" title="监听设置"></a>监听设置</h2><p>监听设置包含三块功能:</p>
<ol>
<li><h1 id="Binding（端口绑定模式）"><a href="#Binding（端口绑定模式）" class="headerlink" title="Binding（端口绑定模式）"></a>Binding（端口绑定模式）</h1><p>Binding绑定的端口是指Burp Proxy代理服务监听的端口，绑定IP地址 分为本地回路、所有接口、指定地址三种模式，在渗透测试中，无论选择哪种模式，需要明白一 点，当选择非本地回路IP地址时，同局域网内的其他电脑也可以访问你的监听地址</p>
<p>—也就是说,其他电脑的数据包也会被你的burpsuite拦截.但不要因此形成认知上的误区</p>
<p>虽然Burp Suite无法自动实现对整个局域网所有流量的监听，但通过手动配置代理或设置透明代理，可以在一定程度上实现对局域网内多个设备流量的拦截。需要注意的是，这些操作通常需要管理员权限和详细的网络配置</p>
</li>
<li><h1 id="Request-Handling（请求处理）"><a href="#Request-Handling（请求处理）" class="headerlink" title="Request Handling（请求处理）"></a>Request Handling（请求处理）</h1><p>主要是用来控制接收到Burp Proxy监听端口的请求后，如何对 请求进行处理的，即使用Burp再次转发。 </p>
<p>其具体配置可分为：主机名&#x2F;域名的转发、端口的转发、强制使用SSL和隐形代理4个部分。当我们 配置了主机或域名的转发，则所有的请求会转发到指定的主机或域名上；如果我们配置了端口的转 发时，所有的请求都会被转发到指定端口上。同时我们可以配置，通过Burp Proxy的消息是否强制 使用SSL，如果设置了此项，则请求若是http协议，经Burp Proxy代理后将转换为https协议。隐形 代理主要是用于测试富客户端应用或者是非浏览器代理方式的应用，当我们设置了它，访问这些应 用时，将通过<strong>非代理的方式，直接连接Burp Proxy的监听端口</strong>。</p>
<p>不挂代理的方式有其独特的意义和应用场景，特别是在一些特殊情况下，无法直接通过设置代理来拦截和分析流量。以下是一些不挂代理的方式及其意义：</p>
<h3 id="意义和应用场景"><a href="#意义和应用场景" class="headerlink" title="意义和应用场景"></a>意义和应用场景</h3><ol>
<li><strong>移动应用测试</strong>：有些移动应用不提供代理设置选项，或者应用的流量硬编码到特定的IP地址或域名。在这种情况下，使用代理进行流量拦截变得非常困难，通过非代理方式（如DNS欺骗或网络重定向）可以解决这个问题。</li>
<li><strong>嵌入式设备测试</strong>：一些嵌入式设备（如物联网设备、智能家居设备）不允许配置代理设置。通过网络设备（如路由器、防火墙）上的规则重定向流量，可以实现对这些设备流量的拦截和分析。</li>
<li><strong>绕过代理检测</strong>：某些系统或应用可能会检测并拒绝代理流量，使用非代理方式可以避免这种检测，从而进行更隐蔽的流量分析。</li>
<li><strong>网络设备测试</strong>：在测试一些需要透明代理或中间设备（如网关、VPN）的场景下，非代理方式可以帮助实现透明的流量拦截和分析，而不会对客户端配置造成影响。</li>
</ol>
</li>
</ol>
<h1 id="Burp-Target"><a href="#Burp-Target" class="headerlink" title="Burp Target"></a>Burp Target</h1><p>1. </p>
<p>Burp Target 组件主要包含<strong>站点地图、目标域、风险定义</strong>三部分组成</p>
<p>当前工作涉及哪些目标域、可能存在的攻击面等信息，下面我们就分别来看看 Burp Target的三个组成部分。</p>
<p>本章的主要内容有：</p>
<h2 id="目标域设置-Target-Scope"><a href="#目标域设置-Target-Scope" class="headerlink" title="目标域设置 Target Scope"></a>目标域设置 Target Scope</h2><p>Target Scope中作用域的定义比较宽泛，通常来说，在对某个系统进行渗透测试时，可以通过域名或者 主机名去限制拦截内容，这里的域名或主机名就是我们说的作用域。如果我们想限制得更为细粒度化， 比如，你只想拦截login目录下的所有请求，也可以在此设置，此时，作用域就是目录。总体来说， Target Scope主要使用于下面几种场景中：</p>
<p>限制站点地图和Proxy历史中的显示结果</p>
<p> 告诉Burp Proxy拦截哪些请求 </p>
<p>Burp Spider抓取哪些内容 </p>
<p>Burp Scan自动扫描哪些作用域的安全漏洞 </p>
<p>在Burp Intruder和Burp Repeater中指定URL 通过Target Scope我们能方便地控制Burp的拦截范围、操作对象，减少无效的噪音（此处演示一下）。 </p>
<h2 id="站点地图-Site-Map"><a href="#站点地图-Site-Map" class="headerlink" title="站点地图 Site Map"></a>站点地图 Site Map</h2><p>当我们设置了 Target Scope（默认全部为允许），使用Burp Proxy进行代理拦截，通过浏览器代理浏览 应用时，Burp会自动将浏览信息记录下来，包含每一个请求和应答的详细信息，保存在Target站点地图 中。</p>
<p>Site Map的左边为访问的URL，按照网站的层级和深度，树形展示整个网站的目 录结构和关联其他域的URL情况；</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707084335435.png" alt="image-20240707084335435"></p>
<p>对该树状结构进行扫描，还可以进行进一步的主动扫描，从而发现一些潜在的风险</p>
<h2 id="Target-工具的使用"><a href="#Target-工具的使用" class="headerlink" title="Target 工具的使用"></a>Target 工具的使用</h2><p>Target 工具的使用的使用主要包括以下部分：</p>
<h3 id="手工获取站点地图"><a href="#手工获取站点地图" class="headerlink" title="手工获取站点地图"></a>手工获取站点地图</h3><p>1、设置浏览器代理和Burp Proxy代理，并使之能正常工作。</p>
<p> 2、关闭Burp Proxy的拦截功能。</p>
<p> 3、手工浏览网页，这时，Target会自动记录站点地图信息。</p>
<p>手工获取站点地图可以使用户根据自己的需要和分析自主控制访问的内容。</p>
<p>记录的信息比较准确，但对于大型的系统而言依次点击一遍对渗透测试人员而言成本比较大</p>
<h3 id="站点比较"><a href="#站点比较" class="headerlink" title="站点比较"></a>站点比较</h3><p>站点比较更为简单,本质就是将站点的结构进行对比</p>
<h4 id="攻击面分析"><a href="#攻击面分析" class="headerlink" title="攻击面分析"></a>攻击面分析</h4><p>右击对应的站点，能够通过相关工具中的分析选项做攻击面分析</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707085712514.png" alt="image-20240707085712514"></p>
<p>概况视图主要展示当前站点动态URL数量、静态URL数量、参数的总数、唯一的参数名数目，通过这些 信息，可以快速帮助我们对当前站点的总体状况建立粗线条的了解。</p>
<p>动态URL和静态URL对应的都可以查看详细的请求包和响应包</p>
<p>参数视图有上中下三部分组成，上部为参数和参数计数统计区，你可以对参数的使用次数进行排序， 从而找出使用频繁的参数进行分析；中部为参数对应的使用情况列表，记录对应的参数每一次的使用记 录；下部为某一次使用过程中，请求消息和应答消息的详细信息。</p>
<p>实际使用中很多站点使用伪静态，如果请求的URL中不带有参数，则分析时无法区别，只能当作静态URL来分析</p>
<h2 id="Discover-Content"><a href="#Discover-Content" class="headerlink" title="Discover Content"></a>Discover Content</h2><p>存在于Burp Target中的站点信息,我们可以直接发送到spider中进行站点信息的爬取.在Burp1.7版本中,存在一个独立模块,叫做Burp Spider,而Burp2.0更新后的本本后,该模块被整合为Targe相关工具中的Discover Content</p>
<p>Discover Content主要用于大型操应用系统的测试</p>
<p>Discover Content的使用主要包含三个方面</p>
<h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><p>Discover Content 控制界面由发现会话状态（Discovery Session Status）和排列任务（Queued Tasks）两部分组成。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707091342086.png" alt="image-20240707091342086"></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>配置界面由Target,Filenames,File Extensions,Discovery Engine四个功能组成</p>
<p>对应的可以根据自己的需要进行一些筛选配置</p>
<h3 id="站点地图"><a href="#站点地图" class="headerlink" title="站点地图"></a>站点地图</h3><p>站点地图（Site Map） 爬取完成后形成的站点地图，和Target模块中的站点地图类似。</p>
<h1 id="Burp-Scan"><a href="#Burp-Scan" class="headerlink" title="Burp Scan"></a>Burp Scan</h1><p>Burp Scan的功能主要是用来自动检测Web系统的各种漏洞，可以使用Burp Scan代替测试人员手工去对 系统进行普通漏洞类型的渗透测试，从而使得测试人员能把更多精力放在那些需要人工验证的漏洞上。</p>
<p>BurpScan是很传统的扫描器,没有什么需要额外提及的</p>
<p>不过这里还是有一些点需要额外考虑</p>
<p>Burp使用被动扫描时为了使流量更接近于普通用户,几乎不额外构造请求进行爬虫或扫描,它基于已经存在的请求和响应进行简单的分析</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707092650449.png" alt="image-20240707092650449"></p>
<p>Burp使用主动扫描模式时则会对应用发送新的请求并通过payload验证漏洞,这种模式下的操作回产生大量的请求和响应数据,直接影响系统的性能,通常适用于非生产环境</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707095413391.png" alt="image-20240707095413391"></p>
<h2 id="扫描配置"><a href="#扫描配置" class="headerlink" title="扫描配置"></a>扫描配置</h2><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707095705268.png" alt="image-20240707095705268"></p>
<p>Scan Type：扫描类型，分为 Crawl and audit 和 Crawl，即爬虫和审计，或者仅爬虫。</p>
<p> URLs to Scan：扫描目标URL Detailed scope configuration：详细的范围配置，通过 Included URL prefixes（包括URL前缀）和 Excluded URL prefixes（不包括URL前缀）来配置扫描。</p>
<p> Use advanced scope control：使用高级的范围控制，如果勾选，将配置 Included URLs（包含的 URL）和Excluded URLs（不包含的URL）来配置扫描。 </p>
<p>点击 Add，弹出配置窗口：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707100020676.png" alt="image-20240707100020676"></p>
<p>**PS:**协议:包含HTTP和HTTPS或者任意</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707100240814.png" alt="image-20240707100240814"></p>
<p>如果需要登录,可以提前配置username和password</p>
<p>导出扫描报告</p>
<p> 1.在Target-&gt;Site Map，选择某个URL，右侧Issues按ctrl+a全选，右键，点击Report selected issues</p>
<p>2.选择报告格式 HTML：生成HTML格式的报告，以便在浏览器中打印或查看。 XML：生成XML格式的报告，适合导入其他工具或报告框架</p>
<h1 id="Burp-Intruder"><a href="#Burp-Intruder" class="headerlink" title="Burp Intruder"></a>Burp Intruder</h1><p>在渗透测试过程中，我们经常使用Burp Intruder，它的工作原理是：Intruder在原始请求数据的基础 上，通过修改各种请求参数，以获取不同的应答。每一次请求中，Intruder都会携带一个或多个有效攻 击载荷（payload），在不同位置进行攻击重放，通过应答数据的比对分析来获得需要的特征数据。</p>
<h2 id="Intruder使用场景"><a href="#Intruder使用场景" class="headerlink" title="Intruder使用场景"></a>Intruder使用场景</h2><h3 id="标识符枚举"><a href="#标识符枚举" class="headerlink" title="标识符枚举"></a>标识符枚举</h3><p>Web应用程序经常使用标识来引用用户,账户,资产等数据信息. 例如用户名 文件ID和账户密码</p>
<h3 id="提取有用数据"><a href="#提取有用数据" class="headerlink" title="提取有用数据"></a>提取有用数据</h3><p>在某些场景下,并非简单的识别有效标识符.而是通过识别标识符提取一些其他的数据.比如单个用户的个人空间ID,获取所欲用户在个人空间的昵称和年龄</p>
<h3 id="模糊测试"><a href="#模糊测试" class="headerlink" title="模糊测试"></a>模糊测试</h3><p>很多输入型的漏洞,如SQL注入,跨站脚本和文本路径遍历等都可以通过修改请求参数提交各种测试字符串. 可以通过Intruder的自动化来实现对Web应用的模糊测试</p>
<p>通常来说</p>
<p>BurpIntruder的测试主要遵循以下步骤</p>
<ol>
<li><p>确认BurpSuite安装正确并正常启动，且完成了浏览器的代理设置。</p>
</li>
<li><p>进入Burp Proxy选项卡，关闭代理拦截功能。</p>
</li>
<li><p>进行历史日志（History）子选项卡，查找可能存在问题的请求日志，并通过右击菜单，发送到 Intruder。 </p>
</li>
<li><p>进入 Intruder 选项卡，打开 Target 和 Positions 子选项卡。这时，你会看到上一步发送过来的请 求消息。</p>
</li>
<li><p>Burp Intrude<strong>r 攻击的基础是围绕刚刚发送过来的原始请求信息，在原始信息指定的位置上设置一 定数量的攻击载荷 Payload</strong>，通过替换 Payload 来发送不同的请求以获取应答消息。默认情况下<strong>， Burp Intruder 会对请求参数和 Cookie 参数设置成 Payload position，前缀添加 $ 进行标识，如 上图红色标注位置所示。当发送请求时，会将$标识的参数替换为 Payload 。</strong></p>
</li>
<li><p>在光标对应位置选择右侧选项,就可以添加或删除<strong>预留出的payload位置</strong></p>
<p>预留出payload位置则是为了使Intruder在对应位置中遍历预设的payload集,发送大批数据包</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707104227760.png" alt="image-20240707104227760"></p>
</li>
<li><p>在payload子选项卡中可以选择payload的生成策略,比如id&#x3D;1-100不断遍历</p>
</li>
<li><p>最后做一遍检查,便可以开始爆破,后续可以开始阅览Intruder返回的通信信息,查看是否有自己需要的信息</p>
</li>
<li><p>有些时候为了防止应答信息太多无法检索出我们需要的信息,通常在进行攻击前,会进行Options选项的相关配置,使用最多的是正则表达式匹配</p>
</li>
<li><p>攻击结果也是可以将展示出的信息做一些指定的,比如攻击时间和是否存在Error等</p>
</li>
</ol>
<h2 id="Payload类型与处理"><a href="#Payload类型与处理" class="headerlink" title="Payload类型与处理"></a>Payload类型与处理</h2><p>payload类型足足有18种可供选择,这里挑选常用的几种记录</p>
<h3 id="简单列表"><a href="#简单列表" class="headerlink" title="简单列表:"></a>简单列表:</h3><p>通过配置一个字符串列表作为payload,也可以手动添加字符串列表或者从文件加载字符串列表</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707111535806.png" alt="image-20240707111535806"></p>
<p>对应的 burp预设了很多组简单payload列表</p>
<p>包括XSS脚本 CGI脚本 SQL注入脚本 数字 大写小写字母  用户名 密码 表单域的字段名 IIS文件名和目录名等</p>
<h3 id="指定文件"><a href="#指定文件" class="headerlink" title="指定文件"></a>指定文件</h3><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707111717409.png" alt="image-20240707111717409">可以指定文件作为相对应payload位置上的列表</p>
<h3 id="自定义迭代器"><a href="#自定义迭代器" class="headerlink" title="自定义迭代器"></a>自定义迭代器</h3><p>这是一款功能强大的Payload，它共有8个占位，每一个占位 可以指定简单列表的Payload类型，然后根据占位的多少，与每一个简单列表的Payload进行笛卡 尔积（集合相乘的结果），生成最终的Payload列表</p>
<h4 id="payload设置"><a href="#payload设置" class="headerlink" title="payload设置"></a>payload设置</h4><p>如图例</p>
<p>位置1 –从列表选择用户名带入</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707114033155.png" alt="image-20240707114033155"></p>
<p>位置2 –可以直接设置值 比方说@@</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707114135696.png" alt="image-20240707114135696"></p>
<p>位置3 –也可以从文件加载</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707114300016.png" alt="image-20240707114300016"></p>
<p>最后攻击时生成的payload则会按照迭代的占位依次排列</p>
<p>如图所示</p>
<img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707115021293.png" alt="image-20240707115021293" style="zoom:200%;" />

<h3 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h3><p>– 顾名思义，<strong>该Payload的类型是对预定义的字符串进行替换后生成新的字符串。</strong>比如说，预定义字符串为ABCD，按照下图的替换规则设置后，将对AB的值 进行枚举后生成新的字符串</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707153759117.png" alt="image-20240707153759117"></p>
<p><strong>如图攻击,如果满足替换条件,它则会将原payload和修改后的payload一起发送到服务端.</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707153954509.png" alt="image-20240707153954509"></p>
<h3 id="大小写替换"><a href="#大小写替换" class="headerlink" title="大小写替换"></a>大小写替换</h3><p>对预定义的字符串，按照<strong>大小写规则进行替换</strong>。比如，预定义 的字符串为Peter Wiener，则按照下图的设置后，会生成新的Payload。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707154240220.png" alt="image-20240707154240220"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707154302311.png" alt="image-20240707154302311"></p>
<p>生成规则由上而下依次是：</p>
<p> No change（不改变，使用原始字符串）</p>
<p> To lower case（转为小写字母） </p>
<p>To upper case（转为大写字母） </p>
<p>To Propername（首字母大写，其他小写） </p>
<p>To ProperName（单词首字母大写，其他不改变)</p>
<p> 在实际使用中，可以根据自己的使用规则进行勾选设置。</p>
<h3 id="字符块"><a href="#字符块" class="headerlink" title="字符块"></a>字符块</h3><p>这种类型的Payload是指使用一个给出的输入字符串，根据指定设 置产生指定大小的字符块，表现形式为生成指定长度的字符串。它通常是用来绕过应用防火墙 （WAF）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707154649754.png" alt="image-20240707154649754"></p>
<h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><p>这种类型的payload是根据配置,生成一系列的数字作为payload.它的设置界面如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707154817322.png" alt="image-20240707154817322"></p>
<p>数字范围部分就是确定最大和最小值以及最大值和最小值所构成的范围中如何取数字,类型分为按顺序和随机遍历给出的数字集合</p>
<h3 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h3><p>根据配置生成一系列的日期</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707155611480.png" alt="image-20240707155611480"></p>
<p>配置比较简单 不过多赘述</p>
<h3 id="暴力字典（Brute-forcer）"><a href="#暴力字典（Brute-forcer）" class="headerlink" title="暴力字典（Brute forcer）"></a>暴力字典（Brute forcer）</h3><p>此类Payload生成包含一个指定字符集的所有特定长度排列的有效载 荷，通常用于枚举字典的生成，其设置界面如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707160307554.png" alt="image-20240707160307554"> </p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707160255421.png" alt="image-20240707160255421"></p>
<p>空类型（Null payloads）</p>
<p>这种负载类型产生的Payload，其值是一个空字符串。在攻击时，<strong>如果 需要同样的请求反复被执行</strong>，在不任何修改原始请求的场景下此Payload是非常有用的。<strong>它可用于 各种攻击，例如应用层DOS、或保持活会话令牌、资源竞争等。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707160640648.png" alt="image-20240707160640648"></p>
<p><strong>这样就近似于实现了单台机的DOS攻击</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707160655083.png" alt="image-20240707160655083"></p>
<h3 id="字符扮演者（Character-frobber）"><a href="#字符扮演者（Character-frobber）" class="headerlink" title="字符扮演者（Character frobber）"></a>字符扮演者（Character frobber）</h3><p>依次修改指定字符串在每 个字符位置的值（不做特殊说明的情况下就是指十进制），每次都是在原字符上递增1个该字符的 ASCII码。</p>
<h3 id="用户名生成器"><a href="#用户名生成器" class="headerlink" title="用户名生成器"></a>用户名生成器</h3><p>这种类型的Payload主要用于用户名和Email账号的自动 生成，其设置界面如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707160956758.png" alt="image-20240707160956758"></p>
<h2 id="攻击类型"><a href="#攻击类型" class="headerlink" title="攻击类型"></a>攻击类型</h2><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707161315912.png" alt="image-20240707161315912"></p>
<h2 id="可选项设置"><a href="#可选项设置" class="headerlink" title="可选项设置"></a>可选项设置</h2><h3 id="请求消息头设置"><a href="#请求消息头设置" class="headerlink" title="请求消息头设置"></a>请求消息头设置</h3><p>请求消息头设置中包含<strong>自动更新Content-Length</strong>和<strong>Set Connection: close</strong></p>
<p>如果选中了设置Connection报头,那么Burp Intruder则会在每个消息中都更新对应的Connection Close报头</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707162113734.png" alt="image-20240707162113734"></p>
<h3 id="攻击结果设置"><a href="#攻击结果设置" class="headerlink" title="攻击结果设置"></a>攻击结果设置</h3><p>这个设置主要用来控制从响应信息中提取结果项,如果 匹配,则在攻击结果中添加新列进行标明</p>
<p>比如在”密码不正确”攻击中遍历一个大字典,这个时候payload数量过大,这个时假设还无法从可疑的对话长度等方面入手,就chenggongv可以通过扫描诸如”Incorrect password”等等找到成功的登录.</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707161925846.png" alt="image-20240707161925846"></p>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>这些设置是主要用于控制执行攻击时Burp如何处理重定向,在实际使用中必须遵循重定向才能实现目的</p>
<p>比如密码猜测攻击中,如果密码错误可能会重定向响应到密码错误的提示界面,密码正确则会重定向到用户中心首页等</p>
<h3 id="Intruder攻击和结果分析"><a href="#Intruder攻击和结果分析" class="headerlink" title="Intruder攻击和结果分析"></a>Intruder攻击和结果分析</h3><p>攻击的发起分为两种方式,一种是经过对应的Target ,Positions,payloads,options等再经过启动进行攻击,另一种则是通过预攻击文件直接发起攻击,攻击结果页面如下所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707170729022.png" alt="image-20240707170729022"></p>
<p>从上图我们可以看出，其界面主要有菜单区、过滤区、消息记录区、请求&#x2F;响应区四部分组成。</p>
<p>菜单区——包含Attack菜单、Save菜单、Columns菜单。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707170959048.png" alt="image-20240707170959048"></p>
<p>过滤区——可以通过查询条件、服务器响应的状态码、注释对消息记录区的信息进行过滤。</p>
<p>消息记录区，又称结果列表（Results Table），记录Payload执行时请求和响应的所有信息，</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707171015761.png" alt="image-20240707171015761"></p>
<p>在对攻击结果的分析中，你可以通过单击任一列标题（升序排序，降序排序和未排序）重新排序表的内 容。有效的应答通常可以通过以下存在差异的内容进行判断：</p>
<h1 id="Burp-Repeater"><a href="#Burp-Repeater" class="headerlink" title="Burp Repeater"></a>Burp Repeater</h1><p> Repeater是对消息的手动改动和迭代的进程,在渗透测试过程中我们经常使用Repeater来进行请求与响应的消息验证分析,比如修改请求参数 验证输入的漏洞 验证逻辑越权等</p>
<p>其设置主要包括以下内容： </p>
<p>更新（Update Content-Length） 这个选项是用于控制Burp是否自动更新请求消息头中的 Content-Length。 </p>
<p>解压和压缩（Unpack gzip &#x2F; deflate） 这个选项主要用于控制Burp是否自动解压或压缩服务端响 应的内容。</p>
<p> 跳转控制（Follow redirections） 这个选项主要用于控制Burp是否自动跟随服务端进行请求跳 转，比如服务端返回状态码为302，是否跟着应答跳转到302指向的URL地址。 它有4个选项，分别 是永不跳转（Never），站内跳转（On-site only）、目标域内跳转（In-scope only）、始终跳转 （Always）。其中永不跳转、始终跳转比较好理解，站内跳转是指当前的同一站点内跳转，目标域 跳转是指Target scope中配置的域可以跳转。 </p>
<p>跳转中处理Cookie（Process cookies in redirections） 这个选项如果选中，则在跳转过程中设置 的Cookie信息，将会被带到跳转指向的URL页面，可以进行提交。</p>
<p> 视图控制（View） 这个选项是用来控制Repeater的视图布局。</p>
<p> 其他操作（Action） 通过子菜单方式，指向Burp的其他工具组件中</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/07/08/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/07/08/XSS/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>SQL注入 二开desu</title>
    <url>/2024/07/08/SQL%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="SQL注入二开"><a href="#SQL注入二开" class="headerlink" title="SQL注入二开"></a>SQL注入二开</h1><p>本教程基于SQL i-Labs</p>
<h2 id="基本原理和概念简介"><a href="#基本原理和概念简介" class="headerlink" title="基本原理和概念简介"></a>基本原理和概念简介</h2><p>SQL注入是黑客攻击最常见的方法，SQL注入作为OWASP中四大Web应用程序十大安全漏洞之一，也可以被一些没有太多网络安全技术“脚本小子”利用，因此掌握SQL注入原理和预防机制非常重要</p>
<h2 id="HOW-to-build-SQLI-Lab"><a href="#HOW-to-build-SQLI-Lab" class="headerlink" title="HOW to build SQLI-Lab"></a>HOW to build SQLI-Lab</h2><h3 id="简单的部署"><a href="#简单的部署" class="headerlink" title="简单的部署"></a>简单的部署</h3><p>图方便的话 直接通过Docker部署就可以了</p>
<p>也可以部署在Web应用系统平台，</p>
<h3 id="从０开始部署"><a href="#从０开始部署" class="headerlink" title="从０开始部署"></a>从０开始部署</h3><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240708172147084.png" alt="image-20240708172147084"></p>
<h3 id="Web应用程序系统"><a href="#Web应用程序系统" class="headerlink" title="Web应用程序系统"></a>Web应用程序系统</h3><p>Web应用程序系统的总体体系结构如图一所示</p>
<p>客户端是浏览器，服务端通常包括了Web服务器，数据库服务器和高级语言解释器，典型的Web服务器架构包括</p>
<p>Apache+PHP+MySQL</p>
<p>IIS＋ASP+MYSQL等</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240708171810391.png" alt="image-20240708171810391"></p>
<h2 id="HOW-does-it-form-–SQL-INJECTION"><a href="#HOW-does-it-form-–SQL-INJECTION" class="headerlink" title="HOW does it form –SQL INJECTION"></a>HOW does it form –SQL INJECTION</h2><p>SQL注入本质是攻击者在Web表单或者URL中插入SQL命令或者片段到查询字符串中,当Web服务器没有严格验证输入和传递字符串的有效性时,攻击者就可以达到<strong>欺骗数据库服务器</strong>,执行恶意SQL命令的效果</p>
<p>在此之前还要了解一个概念’隐式转换’</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240708173609585.png" alt="image-20240708173609585"></p>
<h3 id="SQL-INJECTION-LIST"><a href="#SQL-INJECTION-LIST" class="headerlink" title="SQL INJECTION LIST"></a>SQL INJECTION LIST</h3><p>包括了</p>
<p>同义SQL注入,联合注入,基于报错的注入,盲注.</p>
<h4 id="Tautologic-SQL注入-真理SQL"><a href="#Tautologic-SQL注入-真理SQL" class="headerlink" title="Tautologic SQL注入(真理SQL)"></a>Tautologic SQL注入(真理SQL)</h4><p>这是一种简单的攻击方法,在系统原SQL命令中插入了一个tautologic(常为正确的)条件子句,使原SQL语句的条件限定不起作用.</p>
<h4 id="联合SQL注入"><a href="#联合SQL注入" class="headerlink" title="联合SQL注入"></a>联合SQL注入</h4><p>本质上利用了SQL命令中的联合查询,从而可以执行插入的查询,从特定的数据表中窃取信息</p>
<p>建议在此之前 先学会基本的SQL注入的增删改查,并清除SQL库表的结构如何</p>
<h4 id="基于报错的SQL注入"><a href="#基于报错的SQL注入" class="headerlink" title="基于报错的SQL注入"></a>基于报错的SQL注入</h4><p>攻击者将格式错误的SQL命令作为攻击负载使系统返回一些报错,从而使系统返回一些过度暗示的信息</p>
<p>比如说Order by 1—–n(列溢出报错)</p>
<h4 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h4><p>对于盲注攻击,攻击者会构造一些SQL查询条件,系统对这些查询条件的不同状态会有不同响应,进而获得系统的内部信息</p>
<h2 id="SQL-injection-Begin"><a href="#SQL-injection-Begin" class="headerlink" title="SQL injection Begin"></a>SQL injection Begin</h2><h3 id="数字型—最基本的检验"><a href="#数字型—最基本的检验" class="headerlink" title="数字型—最基本的检验"></a>数字型—最基本的检验</h3><p>数字型可以检验程序本身是否有对用户的输入做任何的额外处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">------------------------测试步骤-----------------------</span><br><span class="line">1.加单引号</span><br><span class="line">URL:www.text.com/text.php?id=1&#x27;]</span><br><span class="line">对应数据服务器响应的SQL命令：</span><br><span class="line">select * from table where id =1&#x27;</span><br><span class="line">这时SQL语句出错，程序无法从数据库中查询出数据，此时可以判断出大概率存在注入，因为只有服务器将对应的单引号一起当作SQL语句执行了才会出现报错，但这也并不绝对，也有可能是程序本身的问题</span><br><span class="line">2.加 and 1=1</span><br><span class="line">URL：www.text.com/text.php?id=1 and 1=1</span><br><span class="line">对应数据服务器响应的SQL命令：</span><br><span class="line">select * from table where id =1 and 1=1</span><br><span class="line">这时语句执行一定是正常的，因为加入了tautologic式的条件子句</span><br><span class="line">3.加 and 1=2</span><br><span class="line">URL：www.text.com/text.php?id=1 and 1=2</span><br><span class="line">对应数据服务器响应的SQL命令</span><br><span class="line">select * from table where id =1 and 1=2</span><br><span class="line">这时语句可以正常执行但无法查询出任何结构，返回数据与原始网页会存在一定的差异</span><br></pre></td></tr></table></figure>

<p>如果这三个payload传入过后同上述代码块中提出的响应是一致的，那么程序本身就是并没有对用户的输入做任何额外处理的，则可以判断该URL存在数字型注入</p>
<h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><p>当传入的参数类型为字符串时，若存在漏洞则称为字符型漏洞，字符型和数字型最大的一个区别在于数字型不需要单引号来闭合而字符串一般需要单引号来闭合对应传入的参数</p>
<p>字符型语句如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from table where id = ‘admin’</span><br></pre></td></tr></table></figure>

<p>因此在构造payload时通过闭合单引号可以成功执行语句</p>
<p>比方</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240708200640557.png" alt="image-20240708200640557"></p>
<p>–为什么要这么做</p>
<p>首先服务端要求我们传入的参数是字符型 在传入的过程中需要将我们自己的恶意指令注入就需要首先满足隐式转换的条件–即先让它接收到需要的字符型变量，然后再通过一些条件子句代入我们自己的语句</p>
<p>也就是说 我们可以这么做</p>
<p>原本的查询语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from table where name =&#x27;（用户输入点）&#x27;+后续语句</span><br></pre></td></tr></table></figure>

<p>这个时候我们在输入点输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; or 1=1 #</span><br></pre></td></tr></table></figure>

<p>那么可以如此合成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from table where name =&#x27; 1&#x27; or 1=1 #&#x27;+后续语句</span><br></pre></td></tr></table></figure>

<p>可以发现不但闭合了前面的语句，同时通过条件语句插入了攻击者的语句，并注释（使无效化）后面可能会出现的另外一些条件语句。</p>
<p>可以用一句话很优雅的总结数字型和字符型</p>
<p>​                              <strong>—猎人往往以猎物的方式出现—</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240708201225404.png" alt="image-20240708201225404"></p>
<h3 id="Union注入"><a href="#Union注入" class="headerlink" title="Union注入"></a>Union注入</h3><p>联合查询可以一句SQL语句中执行多个查询任务，把查询任务从一个表追加到另外一个表，使用UNION或者UNION　ALL来实现</p>
<p>UNION ALL和UNION的区别是UNION ALL操作符可以查询重复的值</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240708202413083.png" alt="image-20240708202413083"></p>
<p>使用UNION注入也是有前提条件的,Union all左右两边查询的列数必须一致</p>
<p>以上图为例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id,first_name <span class="keyword">from</span> users <span class="keyword">where</span> user_id<span class="operator">=</span><span class="number">1</span> <span class="keyword">union</span> <span class="keyword">all</span> <span class="keyword">select</span> user_id,first_name,last_name <span class="keyword">from</span> users <span class="keyword">where</span> user_id<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这个时候你可以发现,union all操作符前的sql语句查询了users表中user_id&#x3D;1所对应的user_id列和first_name.而在union操作符后的sql语句则不同,其对应</p>
]]></content>
  </entry>
</search>
