<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>更底层更方便的一些部署 | Sat0ru_G0j0 | むりょうくうきょ</title>

  
  <meta name="author" content="Satoru">
  

  
  <meta name="description" content="不当了 不当高手！">
  

  
  <meta name="keywords" content="Penetration Testing">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="更底层更方便的一些部署"/>

  <meta property="og:site_name" content="Sat0ru_G0j0"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Sat0ru_G0j0" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Sat0ru_G0j0</a>
    </h1>
    <p class="site-description">むりょうくうきょ</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/archives">文档</a></li>
      
        <li><a href="/categories">分类</a></li>
      
        <li><a href="/tags">标签</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>更底层更方便的一些部署</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2024/07/09/vscode和html，javascript和Docker/" rel="bookmark">
        <time class="entry-date published" datetime="2024-07-09T01:06:05.172Z">
          2024-07-09
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>WARNING ：<strong>请先有一定的linux命令基础再接触并进行部署</strong></p>
<h1 id="WHAT-IS-蜜罐"><a href="#WHAT-IS-蜜罐" class="headerlink" title="WHAT IS 蜜罐"></a>WHAT IS 蜜罐</h1><p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240512091639288.png" alt="image-20240512091639288"></p>
<p>蜜罐是一种安全威胁的主动防御技术，<strong>它通过模拟一个或多个易受攻击的主机或服务来吸引攻击者，捕获攻击流量与样本，发现网络威胁、提取威胁特征，</strong>蜜罐的价值在于被探测、攻陷。其在本质上来说，<strong>是一个与攻击者进行攻防博弈的过程。</strong>蜜罐提供服务，攻击者提供访问，通过蜜罐对攻击者的吸引，攻击者对蜜罐进行攻击，在攻击的过程中，有经验的攻击者也可能识别出目标是一个蜜罐。为此，<strong>为更好的吸引攻击者，蜜罐也需要提供强悍的攻击诱骗能力。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240512092050232.png" alt="image-20240512092050232"></p>
<h1 id="Web服务中间件"><a href="#Web服务中间件" class="headerlink" title="Web服务中间件"></a><strong>Web服务中间件</strong></h1><p>类似Apache  Tomcat  Nginx将用户的HTTP请求解析，并返回到浏览器</p>
<h1 id="钓鱼网站制作"><a href="#钓鱼网站制作" class="headerlink" title="钓鱼网站制作"></a>钓鱼网站制作</h1><p>ctrl+s保存当前全部静态网页 并本地部署</p>
<p><strong>开始测试 打开本地网站发包</strong> </p>
<p>观察自身请求 <strong>可以发送请求后打开F12</strong></p>
<p>然后<strong>点击network并观察对应路径名–即可知请求发向文件</strong></p>
<p><strong>全局检索对应路径 然后直接替换接收数据文件</strong></p>
<h1 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h1><p><a target="_blank" rel="noopener" href="https://www.runoob.com/js/js-tutorial.html">JavaScript 教程 | 菜鸟教程 (runoob.com)</a></p>
<p>不会就查就行了</p>
<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p><a target="_blank" rel="noopener" href="https://docker-practice.github.io/zh-cn/">前言 · Docker – 从入门到实践 (docker-practice.github.io)</a></p>
<p>Docker是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任意一个搭载windows或者linux的机器上</p>
<p><strong>也可以实现虚拟化，容器完全使用沙箱机制，相互之间并无接口</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240525111213269.png" alt="image-20240525111213269"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240525111358970.png" alt="image-20240525111358970"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240525111550258.png" alt="image-20240525111550258"></p>
<h2 id="更新kali-apt源"><a href="#更新kali-apt源" class="headerlink" title="更新kali apt源"></a>更新kali apt源</h2><p>编辑 &#x2F;etc&#x2F;apt&#x2F;sources.list 文件， 在文件最前面添加以下条目：</p>
<p>**#**<strong>中科大稳定版分支</strong> <strong>Kali</strong> <strong>源</strong> </p>
<p>deb <a target="_blank" rel="noopener" href="https://mirrors.ustc.edu.cn/kali">https://mirrors.ustc.edu.cn/kali</a> kali-rolling main non-free non-free-firmware contrib</p>
<p>deb-src <a target="_blank" rel="noopener" href="https://mirrors.ustc.edu.cn/kali">https://mirrors.ustc.edu.cn/kali</a> kali-rolling main non-free non-free-firmware contrib</p>
<p>sudo nano &#x2F;etc&#x2F;apt&#x2F;sources.list</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/12790161/1716608995166-e9089a93-d685-4257-bb94-0822a054dd55.png" alt="img"></p>
<p>sudo apt update</p>
<h2 id="Linux安装docker"><a href="#Linux安装docker" class="headerlink" title="Linux安装docker"></a>Linux安装docker</h2><p>以kali 2024.1 为例，安装docker</p>
<h3 id="添加使用-HTTPS-传输的软件包以及-CA-证书"><a href="#添加使用-HTTPS-传输的软件包以及-CA-证书" class="headerlink" title="添加使用 HTTPS 传输的软件包以及 CA 证书"></a>添加使用 HTTPS 传输的软件包以及 CA 证书</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install \</span><br><span class="line">     apt-transport-https \</span><br><span class="line">     ca-certificates \</span><br><span class="line">     curl \</span><br><span class="line">     gnupg \</span><br><span class="line">     lsb-release</span><br></pre></td></tr></table></figure>

<h3 id="添加软件源的-GPG-密钥"><a href="#添加软件源的-GPG-密钥" class="headerlink" title="添加软件源的 GPG 密钥"></a>添加软件源的 GPG 密钥</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br></pre></td></tr></table></figure>

<h3 id="sources-list-中添加-Docker-软件源"><a href="#sources-list-中添加-Docker-软件源" class="headerlink" title="sources.list 中添加 Docker 软件源"></a>sources.list 中添加 Docker 软件源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/debian \</span></span><br><span class="line"><span class="string">  buster stable&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></pre></td></tr></table></figure>

<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line">$ sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure>

<p>如果无需体验最新版的docker，也可以直接执行下面命令安装</p>
<p>apt install docker.io</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://docker-practice.github.io/zh-cn/install/debian.html">https://docker-practice.github.io/zh-cn/install/debian.html</a></p>
<h3 id="Docker部署"><a href="#Docker部署" class="headerlink" title="Docker部署"></a><strong>Docker部署</strong></h3><p><a target="_blank" rel="noopener" href="https://hub.docker.com/?_gl=1*1k7v6iz*_ga*MTg4MjkxMTk4MS4xNzE2NjA3NDU1*_ga_XJWPQMJYHQ*MTcxNjYxODY3OC4yLjEuMTcxNjYxODY5Ni40Mi4wLjA.">Dockerhub</a></p>
<h2 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h2><h4 id="三件套"><a href="#三件套" class="headerlink" title="三件套"></a><strong>三件套</strong></h4><p>docker search 寻找想要的镜像 同时可以标签筛选</p>
<p>docker pull 拉取想要的镜像</p>
<p>docker run 运行镜像</p>
<p>docker stop {container id}</p>
<p><strong>查看对应容器信息</strong></p>
<p>docker ps </p>
<p><em>里面就有包含</em></p>
<h4 id="删除对应镜像"><a href="#删除对应镜像" class="headerlink" title="删除对应镜像"></a>删除对应镜像</h4><p>docker rmi {container id}</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240525144321937.png" alt="image-20240525144321937"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240525151120882.png" alt="image-20240525151120882"></p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-command-manual.html">Docker 命令大全 | 菜鸟教程 (runoob.com)</a></p>
<p><strong>创建镜像后能做什么</strong> <strong>镜像的特性是什么</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240529201943078.png" alt="image-20240529201943078"></p>
<h1 id="VS-Code-Remote-ssh-远程控制Windows主机-免密登录-内网穿透"><a href="#VS-Code-Remote-ssh-远程控制Windows主机-免密登录-内网穿透" class="headerlink" title="VS Code Remote-ssh 远程控制Windows主机 + 免密登录 + 内网穿透"></a>VS Code Remote-ssh 远程控制Windows主机 + 免密登录 + 内网穿透</h1><h2 id="VS-Code-Remote-ssh-远程控制Windows主机-免密登录-内网穿透-1"><a href="#VS-Code-Remote-ssh-远程控制Windows主机-免密登录-内网穿透-1" class="headerlink" title="VS Code Remote-ssh 远程控制Windows主机 + 免密登录 + 内网穿透"></a>VS Code Remote-ssh 远程控制Windows主机 + 免密登录 + 内网穿透</h2><p>1 我们为什么需要远程连接服务器？（使用需求+场景）<br>炼丹的研究生：在我们炼丹过程中，经常需要连接远程的服务器（通常是实验室的服务器）进行炼丹。通常情况下，我们会使用Pycharm的远程开发功能，同步服务器与本地的项目文件，使用远程解释器进行开发。但是使用过的同学都知道，重量级的Pycharm每次远程同步、加载远程解释器都需要相当长的时间。如果我们想要随时切换工位、宿舍、家里的各个场景，Pycharm的同步、加载就成了一场噩梦。特别是当我们的python环境安装了很多依赖包，项目生成了大量文件的时候更是这样。<strong>直到VS Code推出了Remote Development开发包，便完全解决了这个问题。让我可以在不同的场景快速切换，无需等待同步文件、环境。</strong>因为VS Code远程开发完全是运行在服务器上的，我们本地的VS Code只是一个前端界面，所以<strong>根本无需同步服务器上的文件</strong>、解释器依赖库就可以体验到与本地开发完全相同的体验。在远程连接服务器后，只需要使用可以随身携带的笔记本进行Coding，而炼丹就交由服务器来完成。优雅！<br>2 远程办公：<strong>将自己的台式机当成一个服务器在服务器上训练&#x2F;测试模型。这样自己远程办公时，可以通过ssh远程连接到自己的台式机在公司开会时，用笔记本远程连接自己的台式机</strong><br>3 以上只是列举出来的一些常见的使用场景，但具体到每个人都是不尽相同的，但是需求都是相似的——优化我们的工作流。</p>
<h2 id="为什么需要内网穿透？"><a href="#为什么需要内网穿透？" class="headerlink" title="为什么需要内网穿透？"></a>为什么需要内网穿透？</h2><p>通常<strong>服务器是在一个局域网下的，没有公网ip，需要通过局域网内的NAT</strong>（Network Address Translation）讲局域网内的私有IP地址转换为公网IP才能正常通信。如果想要远程连接，要么和服务器处在同一个局域网下，但这通常限制了我们使用场景，如果离开这个局域网，就没法远程开发了。因此需要内网穿透，解决处于使用了NAT设备的私有TCP&#x2F;IP网络中的主机之间建立连接的问题。但是如果你有公网IP，就没有这么多b事了。但是99%的可能你都没有公网IP，其中的原因也比较简单，公网IP地址是一种稀缺的有限的资源，而Internet是老美搞的，简单讲有人多了，就一定会有人少了，就得通各种各样的方式来提高我们为数不多的公网IP地址的利用率，以满足我国人民日益增长的上网需求doge。<br>什么是内网穿透？<br>内网穿透是一种网络技术，它允许在私有局域网（内网）中的设备或服务可以通过公共网络（如互联网）进行访问。通常情况下，内网设备由于NAT 设备屏蔽或防火墙等网络设备所保护，无法直接从公网访问。通过使用内网穿透技术，可以建立起公网和内网之间的通道，使得外部用户可以通过公网连接到内网中的设备，就像这些设备直接连接在公网上一样。内网穿透简单来说就是<strong>将内网外网通过隧道打通,让内网的数据让外网可以获取</strong>。</p>
<h3 id="什么是SSH？"><a href="#什么是SSH？" class="headerlink" title="什么是SSH？"></a>什么是SSH？</h3><p>安全外壳协议（Secure Shell Protocol，简称SSH）<strong>是一种运行在应用层的（默认端口号为22）加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境。</strong>SSH通过在网络中建立安全隧道来实现SSH客户端与服务器之间的连接。最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。SSH最常见的用途是远程登录系统，人们通常利用SSH来传输命令行界面和远程执行命令。SSH使用频率最高的场合是类Unix系统，但是Windows操作系统也能有限度地使用SSH。<strong>2015年，微软宣布将在未来的操作系统中提供原生SSH协议支持，Windows 10 1803版本已提供OpenSSH工具。</strong><br>SSH以非对称加密实现身份验证。身份验证有多种途径：</p>
<p>其中一种方法是使用自<strong>动生成的公钥-私钥对来简单地加密网络连接，随后使用密码认证进行登录</strong>；<br>另一种方法是<strong>人工生成一对公钥和私钥，通过生成的密钥进行认证，这样就可以在不输入密码的情况下登录。任何人都可以自行生成密钥。</strong>公钥需要放在待访问的电脑之中，而对应的私钥需要由用户自行保管。认证过程基于生成出来的私钥，但整个认证过程中私钥本身不会传输到网络中。其中公钥用于让对方加密信息，而自己的私钥可以解密经过自己公钥加密后的信息，这就是非对称加密。</p>
<p>SSH以非对称加密实现身份验证。身份验证有多种途径：</p>
<p>其中一种方法是使用自动生成的公钥-私钥对来简单地加密网络连接，随后使用密码认证进行登录；<br>另一种方法是人工生成一对公钥和私钥，通过生成的密钥进行认证，这样就可以在不输入密码的情况下登录。任何人都可以自行生成密钥。公钥需要放在待访问的电脑之中，而对应的私钥需要由用户自行保管。认证过程基于生成出来的私钥，但整个认证过程中私钥本身不会传输到网络中。其中公钥用于让对方加密信息，而自己的私钥可以解密经过自己公钥加密后的信息，这就是非对称加密。</p>
<h3 id="SSH远程连接之后能干什么？"><a href="#SSH远程连接之后能干什么？" class="headerlink" title="SSH远程连接之后能干什么？"></a>SSH远程连接之后能干什么？</h3><p>SSH远程连接之后，就可以像操作本地的机器一样操作远程机器。当需要操控的机器不在本地时就可以使用ssh协议远程连接操控。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240606153525709.png" alt="image-20240606153525709"></p>
<p><strong>在Powershell（管理员）中确保添加了防火墙规则</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">在Powershell（管理员）中确保添加了防火墙规则</span><br><span class="line"></span><br><span class="line"># 启动sshd服务</span><br><span class="line">Start-Service sshd</span><br><span class="line"></span><br><span class="line"># 将sshd服务设置为自动启动，若不设置需要在每次重启后重新开启sshd</span><br><span class="line">Set-Service -Name sshd -StartupType &#x27;Automatic&#x27;</span><br><span class="line"></span><br><span class="line"># 确认防火墙规则，一般在安装时会配置好</span><br><span class="line">Get-NetFirewallRule -Name *ssh*</span><br><span class="line"></span><br><span class="line"># 若安装时未添加防火墙规则&quot;OpenSSH-Server-In-TCP&quot;，则通过以下命令添加</span><br><span class="line">New-NetFirewallRule -Name sshd -DisplayName &#x27;OpenSSH Server (sshd)&#x27; -Enabled True -Direction Inbound -Protocol TCP -Action Allow -LocalPort 22</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二步：连接到 OpenSSH 服务器<br><strong>在第一次连接之前，我们先来了解两个概念</strong>：<strong>username和servername&#x2F;hostname。在windows的SSH服务器中也就是在你的远程主机中</strong></p>
<p>username可以用你激活电脑时使用的用户名，即文件资源管理器中C:\Users\username的username。<br>而servername则是“设置”&gt;“系统”&gt;“关于”里的“设备名称”<br>其中输入密码应该是你的远程主机的开机密码，并且这一次连接应该确保是在同一网络下进行的，因为我们并没有进行内网穿透操作</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240606154856346.png" alt="image-20240606154856346"></p>
<p><strong>如果你成果的看到了以下输出，恭喜你成功的连接上了你的远程主机，并且已经成功了一大半了。接下来我们去VS Code中连接，操作都是类似的。</strong></p>
<h3 id="在VS-Code中连接你的远程主机"><a href="#在VS-Code中连接你的远程主机" class="headerlink" title="在VS Code中连接你的远程主机"></a>在VS Code中连接你的远程主机</h3><p>这部分内容遵循VS Code的官方教程，但在此基础上做了精简，官方教程写的好的部分会直接贴出来。这一次的连接同样应该确保是在同一网络下进行的，因为我们并没有进行内网穿透操作。<br><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240606155050660.png" alt="image-20240606155050660"></p>
<h1 id="Vscode远程连接Docker"><a href="#Vscode远程连接Docker" class="headerlink" title="Vscode远程连接Docker"></a>Vscode远程连接<strong>Docker</strong></h1><p>Author ：探姬</p>
<p>原文于语雀发布，地址为：<a target="_blank" rel="noopener" href="https://www.yuque.com/probius/cs_wp/fegz0w">https://www.yuque.com/probius/cs_wp/fegz0w</a></p>
<p>本文也有配套视频，建议结合食用：(给个三连吧www)</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1684y1z7L6">https://www.bilibili.com/video/BV1684y1z7L6</a></p>
<h2 id="About"><a href="#About" class="headerlink" title="About"></a>About</h2><p>本文档完整的流程可以帮助您在<strong>Kali Linux</strong>上完成Docker环境，并且基于Vscode的Remote功能，利用SSH协议，构建 VSCODE + SSH + Docker 的工作流，提高效率。</p>
<p>同样，本文档也考虑了非Kali，用于开发&#x2F;生产环境的 <strong>Ubuntu &#x2F; Debian</strong> 系统 ，如果您想要在开发&#x2F;生产中使用该工作流，可以直接从<strong>Get Docker</strong> 或者 <strong>Build SSH＋vscode + docker Workflow</strong> 章节开始。</p>
<p>笔者水平有限，错误疏漏之处在所难免，烦请各位师傅斧正。</p>
<p>以及非常感谢 <strong>陈橘墨(@<strong>Randark_JMT</strong>)师傅</strong>提供的帮助。</p>
<h2 id="Get-Kali"><a href="#Get-Kali" class="headerlink" title="Get Kali"></a>Get Kali</h2><h3 id="Download"><a href="#Download" class="headerlink" title="Download"></a>Download</h3><p>在Kali官网下载即可，建议直接下载封装好的虚拟机版本：</p>
<p><a target="_blank" rel="noopener" href="https://www.kali.org/get-kali/#kali-virtual-machines">https://www.kali.org/get-kali/#kali-virtual-machines</a></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665941610725-938968ad-7947-4e8b-9030-e3758268b763.png" alt="img"></p>
<p>解压下载好的压缩包到您想要放置虚拟机的位置，然后双击配置文件直接打开自动添加，或者在VMware中手动添加：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665941724211-28de32c3-f423-4a93-9834-e73779c30df1.png" alt="img"></p>
<p>添加完成后，启动即可：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665941756080-5769f591-f33d-4acb-bc6d-d3e6b05d214f.png" alt="img"></p>
<p>（当然，作为DockerRuner，您可能需要设置一个稍微大点的内存值）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665941814497-37c98101-8d6b-4c1d-80c1-a63fc7952de8.png" alt="img"></p>
<h3 id="ChangeResource？"><a href="#ChangeResource？" class="headerlink" title="ChangeResource？"></a>ChangeResource？</h3><p>笔者并不建议换源，Kali官方源的速度还是不错的，换源可能会导致您软件管理出现问题。</p>
<h1 id="虚拟机迁移发现远程连接消失"><a href="#虚拟机迁移发现远程连接消失" class="headerlink" title="虚拟机迁移发现远程连接消失?"></a>虚拟机迁移发现远程连接消失?</h1><p>VM虚拟机移动后IP修改，要做一些什么操作，就可以在自己电脑上使用了<br>第一步：我们打开虚拟机<br>你要在虚拟机文件的里面打开你创建保存的虚拟机文件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240609004828634.png" alt="image-20240609004828634"></p>
<p>打开后是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240609004907612.png" alt="image-20240609004907612"></p>
<p>你可以打开并且允许虚拟机了，但是他就是连不上xshell，这个是问题是你的那个虚拟编辑器上面的网关和xshell之前的网关不一样，所以他就连接不上。<br>打开虚拟编辑器</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240609004921035.png" alt="image-20240609004921035"><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240609004934951.png" alt="image-20240609004934951"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240609004955897.png" alt="image-20240609004955897"></p>
<p>看看上面箭头的有没有钩选上。其中将主机虚拟机适配器连接到网络和使用本地DHCP必须选择上，不然你的虚拟机就是另外一个问题。</p>
<p>记住自己的子网ip:192.168.xxx.xxx</p>
<p>我们先:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 dhclient  自己获取IP的一个命令</span><br><span class="line">2 然后 ip add</span><br><span class="line">3 查看自动获取的ip地址</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240609005029453.png" alt="image-20240609005029453"></p>
<p>我们输入下面这个可以修改网关的ip的命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 vi /etc/sysconfig/network-scripts/ifcfg-ens33</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240609005049558.png" alt="image-20240609005049558"></p>
<p>上这个图片是和7有个参考，如果你是拷贝其他人的虚拟机，就改那个IPADDR就行，因为，其他的别人都改好的。</p>
<p>IPPADDR，我们最好改成我们刚刚ip add 自动获取的那个ip.</p>
<p>改好后我们保存退出：</p>
<p>按esc wq保存退出：</p>
<p>下面我们开始重新启动网卡：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 systemctl restart network.service</span><br><span class="line">2 如果这个命令不行就用：service network restart 重新启动网关</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>重新启动后面，我们就再</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 ip add</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>后面，我试试虚拟机连接网络：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure>







<h2 id="Get-Docker"><a href="#Get-Docker" class="headerlink" title="Get Docker"></a>Get Docker</h2><h3 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h3><p>docker安装目前有两个版本，一个是官方的<strong>docker.ce</strong>版本，一个是有Debian团队维护的<strong>docker.io</strong>版本。</p>
<p>之前有争议说 docker.io 是旧版本的docker 而新版的docker是 dockers.ce</p>
<p>然而docker.io的版本有时会比docker.ce高，事实上，两者只是负责维护的组织不同，前者是Debian官方维护，后者则为Docker官方维护，并没后新旧之分：</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/45023363/what-is-docker-io-in-relation-to-docker-ce-and-docker-ee-now-called-mirantis-k">https://stackoverflow.com/questions/45023363/what-is-docker-io-in-relation-to-docker-ce-and-docker-ee-now-called-mirantis-k</a></p>
<h4 id="docker-io"><a href="#docker-io" class="headerlink" title="docker.io"></a>docker.io</h4><p>该版本由Debian团队维护，采用 apt 的方式管理依赖</p>
<p>安装过程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665991778767-3780c1b4-c778-4896-b0eb-70651e627778.png" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install docker.io</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665991813089-2477e73a-9650-4eae-b3b4-0f338801b331.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665991905446-84b04c96-1d8d-46b7-a569-945ed7041921.png" alt="img"></p>
<h4 id="docker-ce"><a href="#docker-ce" class="headerlink" title="docker.ce"></a>docker.ce</h4><p> 由docker官方维护的版本，采用 go 的方式管理依赖，如果您要在开发&#x2F;生产环境中使用docker，推荐使用该版本。</p>
<p>如果您的Linux版本为Ubuntu&#x2F;Debian，可以使用一下命令自动安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO- https://get.docker.com/ | sh</span><br></pre></td></tr></table></figure>

<p>（注意，Docker并不支持Kali一键安装，同样笔者也不推荐您用kali作为开发生产环境，Kali满足日常需要，使用io版本即可，当然您也可以使用.ce版本的手动安装）</p>
<p>手动安装：</p>
<p>可以参考Docker官方的 Docker Engine安装步骤：</p>
<p><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/debian/">https://docs.docker.com/engine/install/debian/</a></p>
<p>但是该步骤在 Kali Linux上面可能会存在一定问题，以Kali为例，完整的按照流程如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg \</span><br><span class="line">    lsb-release</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666080331410-5ec0dec8-2032-404b-82a4-ae31e0ad436d.png" alt="img"></p>
<p>选项选择Yes就好。</p>
<p>然后按照官网提示，添加Docker官方的 GPG key：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/apt/keyrings</span><br><span class="line">curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span><br></pre></td></tr></table></figure>

<p>然后设置仓库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=<span class="subst">$(dpkg --print-architecture)</span> signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian \</span></span><br><span class="line"><span class="string">  <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></pre></td></tr></table></figure>

<p>然后开始安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure>

<p>随后，如果您是Kali Linux，您可能会遭遇以下报错：</p>
<p><a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/630643/how-to-install-docker-ce-in-kali-linux">How to install docker-ce in kali-linux?</a></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666080964792-ad4bf959-2049-4979-9924-48c11bc2641d.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666080978683-d1a1900c-fea3-4134-b2cb-98ed2d2c5a42.png" alt="img"></p>
<p>这是由于Docker官方并没有提供直接支持Kali的源，所以我们使用Debian的源就好：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%s\n&quot;</span> <span class="string">&quot;deb [arch=amd64] https://download.docker.com/linux/debian buster stable&quot;</span> |\</span><br><span class="line">sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/docker-ce.list</span><br></pre></td></tr></table></figure>

<p>并且添加对应的密钥：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure>

<p>注意不要忘了给密钥相应权限：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chmod</span> a+r /etc/apt/keyrings/docker.gpg</span><br></pre></td></tr></table></figure>

<p>此时再跑一次 <code>sudo apt-get update</code>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<p>您可能会遇到一个找不到的源，这个是正常的。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666081542730-3abaa686-0c14-4ee9-835b-c9244e7a601c.png" alt="img"></p>
<p>接下来安装docker：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure>

<p>就能正常获取了：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666081606647-ba60b180-36d3-4d71-9696-63ff6fb0068f.png" alt="img"></p>
<p>安装完成后，执行hello-world，得到图示则安装成功。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666083076099-29da6da2-2c69-4862-a93b-0d343b5e78f7.png" alt="img"></p>
<h3 id="DockerHub"><a href="#DockerHub" class="headerlink" title="DockerHub"></a>DockerHub</h3><p><a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<p>尝试登录您的<code>**DockerHub**</code>账号：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665992062442-9121927b-e352-4d24-8494-e073942e856a.png" alt="img"></p>
<p>如果出现类似错误，请手动配置DNS：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/resolv.conf</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665992104653-95449c6a-2e19-49a3-8ccc-f57ecf3b0b93.png" alt="img"></p>
<p>保存，再次尝试即可成功登录：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665992136237-ce188b31-9008-4375-95ef-f06d4ac013a7.png" alt="img"></p>
<h2 id="Build-SSH＋vscode-docker-Workflow"><a href="#Build-SSH＋vscode-docker-Workflow" class="headerlink" title="Build SSH＋vscode + docker Workflow"></a>Build SSH＋vscode + docker Workflow</h2><p>该步骤适用于支持SSH协议的Linux（废话，哪个Linux没有个SSH），除了在本地的Kali或者其他Linux上面构建，也支持远程构建该工作流。</p>
<h3 id="Start-SSH-Service"><a href="#Start-SSH-Service" class="headerlink" title="Start SSH Service"></a>Start SSH Service</h3><h4 id="Kali-Linux"><a href="#Kali-Linux" class="headerlink" title="Kali Linux"></a>Kali Linux</h4><p>Kali虚拟机默认是没有开启ssh服务的 （ssh状态：<code>/etc/init.d/ssh status</code>）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665992570893-88f65a45-ca5e-4295-a9fb-932fc2f9db2f.png" alt="img"></p>
<p>所以需要手动启动一下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/ssh start </span><br></pre></td></tr></table></figure>

<p>当然，为了方便，我们将ssh添加到开机自启中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo update-rc.d ssh <span class="built_in">enable</span></span><br><span class="line"><span class="comment"># Or use:</span></span><br><span class="line">systemctl <span class="built_in">enable</span> ssh.service</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665992653697-a499a2eb-da24-435e-87f3-4fda32a2669d.png" alt="img"></p>
<p>启动之后就可以开始后面的步骤了。</p>
<h4 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h4><p>由于ubuntu默认不自带openssh-server，所以这里需要手动安装。</p>
<p>安装openssh-server：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure>

<p>安装完成后启动服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service ssh start</span><br></pre></td></tr></table></figure>

<h3 id="Get-Remote-SSH"><a href="#Get-Remote-SSH" class="headerlink" title="Get Remote - SSH"></a>Get Remote - SSH</h3><p>为了使用vscode的远程ssh功能 您可能需要在扩展中安装<code> Remote - SSH</code>插件：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666002987439-4e307846-0b99-4578-9b54-ddd628aefd77.png" alt="img"></p>
<h3 id="Let-Vscode-Connect-to-host"><a href="#Let-Vscode-Connect-to-host" class="headerlink" title="Let Vscode Connect to host"></a>Let Vscode Connect to host</h3><p>连接方式有两种：<code>密码连接</code> 和 <code>ssh的公私钥</code>。</p>
<p>一般情况下我们使用密码连接，这样的方法安全性较低，而且每次连接和每次切换目录的时候都会要求输入密码，所以在确保能够密码连接情况下，我们可以进一步使用公私钥验证的方式来提升安全性和优化操作友好性。</p>
<h4 id="Using-password-connection"><a href="#Using-password-connection" class="headerlink" title="Using password connection"></a>Using password connection</h4><p>打开vscode，点击左下角的远程连接（绿色的部分）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665992886788-3aa8ff94-7d9f-461a-a1fb-4e108cffd83d.png" alt="img"></p>
<p>接着在弹出的窗口中选择 Connect to Host</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665992849406-4490a1c9-c017-4952-9930-c7845e7efd7e.png" alt="img"></p>
<p>选择 <code>Add New SSH Host</code>：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665992979730-8b19217b-f803-4298-8537-fcd5af749130.png" alt="img"></p>
<p>按照要求输入对应的指令：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665993031322-111547cb-b185-4ca5-a767-e8c3ee49506f.png" alt="img"></p>
<p>IP可通过 <code>ip a</code> 获取</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665993103994-c44e4858-ef69-45d9-9b5d-38150e83f710.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh kali@192.168.28.145 -A</span><br></pre></td></tr></table></figure>

<p>保存位置默认第一个就好：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665993185976-069830bf-af5d-4a79-9a1d-3958e9b99274.png" alt="img"></p>
<p>然后连接：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665993196349-e231aea3-bdd0-422d-b475-c4669252a75d.png" alt="img"></p>
<p>选择对应的系统：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665993227789-8b0ec6b0-d9eb-4bcb-b0fd-94368350a908.png" alt="img"></p>
<p>选择继续：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665993257173-dfc7b2ab-a5ee-4821-9e7e-3a7af8ac7cc7.png" alt="img"></p>
<p>输入密码：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665993277058-231f6520-9afc-4375-9bf4-7c42f1718163.png" alt="img"></p>
<p>初始化完成后就连接上了：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665993334466-214c5073-08fc-4492-9674-29b9e6e8fff3.png" alt="img"></p>
<h4 id="Using-public-and-private-keys"><a href="#Using-public-and-private-keys" class="headerlink" title="Using public and private keys"></a>Using public and private keys</h4><h5 id="Create-public-and-private-keys"><a href="#Create-public-and-private-keys" class="headerlink" title="Create public and private keys"></a>Create public and private keys</h5><p>首先在本机上生成对应的公钥私钥：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666022363207-1faad277-da27-4d65-9a77-7f65f22cc0d3.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter file in which to save the key (C:\Users\Probius/.ssh/id_rsa):</span><br></pre></td></tr></table></figure>

<p>输入保存路径，如果为空默认为 <code>C:\Users\USERNAME/.ssh/id_rsa</code>，这里笔者直接输入了名字，让其以该名字直接保存在当前目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase):</span><br></pre></td></tr></table></figure>

<p>输入私钥密码，为空则没有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter same passphrase again:</span><br></pre></td></tr></table></figure>

<p>注意：如果您使用了私钥密码，那么在进行ssh登录的时候，会提示您输入私钥密码，相当于再使用公私钥登录的情况下又加了一层密码，安全性有很大的提升，但是这样会变得和密码登录一样每次都要输入，这里笔者建议，如果是本地一路回车就好了，如果是远程资源的管理，可以综合安全性考虑</p>
<p>生成过后，得到的<code>id_rsa.pub</code>(Kali_test.pub)是<strong>公钥</strong>，<code>id_rsa</code>(Kali_test)是<strong>私钥</strong> </p>
<p>将得到的私钥放在我们的.ssh(C:\Users\USERNAME.ssh)中。</p>
<p>(您也可以在生成的时候就让他防止在此，当然这并不是重点）</p>
<h5 id="Configuring-Remote-Host"><a href="#Configuring-Remote-Host" class="headerlink" title="Configuring Remote Host"></a>Configuring Remote Host</h5><p>将得到的公钥上传到 Kali&#x2F;服务器中对应用户的.ssh文件夹中(请确保该文件夹至少有700的权限)：</p>
<p>（注意 kali默认没有该文件夹，需要用户手动创建，并且赋700权限 <code>mkdir ~/.ssh</code> ）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666023486280-3163a1ad-2809-44a8-a9e2-a8f29b452de3.png" alt="img"></p>
<p>在此处打开终端，用公钥文件来生成 authorized_keys：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> id_ras.pub &gt;&gt; authorized_keys</span><br><span class="line"><span class="comment"># 此处既 cat Kali_test.pub &gt;&gt; authorized_keys</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666023722693-73b3cecc-1273-4a42-88f8-9ed336a90588.png" alt="img"></p>
<p>由于Linux系统对.ssh拥有比较严格的权限限制，请确保权限配置正确：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chmod</span> 600 authorized_keys</span><br><span class="line">sudo <span class="built_in">chmod</span> 700 ~/.ssh</span><br></pre></td></tr></table></figure>

<p>编辑ssh配置文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>

<p>确保拥有以下条目：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RSAAuthentication <span class="built_in">yes</span></span><br><span class="line">PubkeyAuthentication <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>

<p>注意Kali的ssh默认配置是没有上诉两项的，需要自行添加：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666026484050-a32d3cb9-76dc-4635-bfa1-087cc833ee2d.png" alt="img"></p>
<p>然后搞定一切后 重启SSH服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service ssh restart</span><br></pre></td></tr></table></figure>

<p>Linux部分的配置这样就搞定啦~</p>
<p>（在您确保您的连接无误后，如果是服务器等远程设备，可以在config中关闭密码登录以提升安全性：</p>
<p><code>PasswordAuthentication no</code>）</p>
<h5 id="Configuring-Local-Host"><a href="#Configuring-Local-Host" class="headerlink" title="Configuring Local Host"></a>Configuring Local Host</h5><p>然后是Windows，也就是vscode这边的配置：</p>
<p>添加NewHost：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666028378220-501e16a9-549c-4312-8afd-3e73b559abe5.png" alt="img"></p>
<p>使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh USERNAME@IP -i C:\\Users\\Probius\\.ssh\\RAS_ID</span><br></pre></td></tr></table></figure>

<p>（注意使用指令添加时，务必使用双斜杠）</p>
<p>当然，也可以在已经添加的配置文件上改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host 192.168.28.145</span><br><span class="line">	HostName 192.168.28.145</span><br><span class="line">	User kali</span><br><span class="line">	IdentityFile C:\Users\Probius\.ssh\Kali_test</span><br></pre></td></tr></table></figure>

<p>如果操作无误，且没有设置私钥密码，那么点击连接之后无需其他额外操作即可连接；如果设置了私钥密码，那么按照提示输入即可。</p>
<h5 id="Other-About-SSH-key-login"><a href="#Other-About-SSH-key-login" class="headerlink" title="Other_About SSH key login"></a>Other_About SSH key login</h5><p>关于ssh密钥登录的更多知识可以看这一篇文章：</p>
<p><a target="_blank" rel="noopener" href="https://wangdoc.com/ssh/key.html">https://wangdoc.com/ssh/key.html</a></p>
<h3 id="Get-The-Docker-Extension"><a href="#Get-The-Docker-Extension" class="headerlink" title="Get The Docker Extension"></a>Get The Docker Extension</h3><h4 id="Install-extension"><a href="#Install-extension" class="headerlink" title="Install extension"></a>Install extension</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665993503285-4cad91c3-c5be-42f1-949b-b06dd63b3dce.png" alt="img"></p>
<p>（当然 如果显示的是 <code>安装</code>也是一样的）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665993640582-33e0292d-1a01-4a4e-bdb4-5052a3cc658d.png" alt="img"></p>
<h4 id="Solve-error"><a href="#Solve-error" class="headerlink" title="Solve error"></a>Solve error</h4><p>如果您使用自动安装，应该不会遇到该问题，自动安装的sh会自动完成用户组添加的操作。</p>
<p>由于权限原因，我们可能无法访问到  <code>/var/run/docker.sock</code></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666085731016-37a5a8a0-770c-4759-ac00-4c124fcd5165.png" alt="img"></p>
<h5 id="By-add-user-group"><a href="#By-add-user-group" class="headerlink" title="By add user group"></a>By add user group</h5><p>一劳永逸的解决权限问题，将当前用户组添加到docker组即可。</p>
<p>创建docker用户组，默认安装时就会自动创建，所以执行可能会显示<code>exist</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd docker </span><br></pre></td></tr></table></figure>

<p>添加当前用户到该组：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker <span class="variable">$&#123;USER&#125;</span> </span><br></pre></td></tr></table></figure>

<p>然后重新启动容器服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart docker </span><br></pre></td></tr></table></figure>

<p>再次重新登入即可，如果重新登录之后依旧报错无法读取，请尝试重启：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>

<h5 id="By-chmod"><a href="#By-chmod" class="headerlink" title="By chmod"></a>By chmod</h5><p>也可以使用<code> sudo chmod 777 /var/run/docker.sock</code>，但是每次重启之后权限都会重置，不推荐</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665993792130-55218849-ff43-4565-8b31-b7a7d81a99f6.png" alt="img"></p>
<p>然后就能正常访问了：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665993848043-242f6244-7db2-4cd0-bfe4-5f1c5456ce0b.png" alt="img"></p>
<h3 id="Start-Use"><a href="#Start-Use" class="headerlink" title="Start Use"></a>Start Use</h3><p>（以下操作使用<strong>DockerHub</strong>演示）</p>
<p>因为在安装Docker的时候登录过DockerHub所以这里连接之后，系统会自动获取您的凭证，您可以在这查看您的DockerHub仓库：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665994063185-82918af8-46ea-43a3-a524-f5a66280d2b2.png" alt="img"></p>
<p>当然，您也可以添加其他仓库，具体的用法可以参考官方文档：</p>
<p><a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/containers/quickstart-container-registries">https://code.visualstudio.com/docs/containers/quickstart-container-registries</a></p>
<h4 id="Pull-Image"><a href="#Pull-Image" class="headerlink" title="Pull Image"></a>Pull Image</h4><p>当然 对于自己仓库的镜像还是比较方便的233：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665995599834-3c92a723-9476-43d9-aa8f-9553055a3403.png" alt="img"></p>
<p>当然如果是公开镜像的话 还是免不了指令啦，不过还是比较方便的，旁边就是终端：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665995757090-9bd04c4b-fb0b-47a1-b96c-c6393e110ba4.png" alt="img"></p>
<p>完成之后就能在IMAGES栏看到了：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665995915572-4b40f768-d4d5-4f32-a536-ffadb2421c86.png" alt="img"></p>
<h4 id="Run-Docker"><a href="#Run-Docker" class="headerlink" title="Run Docker"></a>Run Docker</h4><p>运行容器有两个选项Run &#x2F; Run Ineractive</p>
<h5 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h5><p>默认后台运行，Run执行后效果和在Linux执行 -d的效果相同：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666116092112-5dc775b4-197e-48b1-a345-3bde2132a8ac.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665997253030-26e1cb0b-0014-4c19-b2e6-f219945e510a.png" alt="img"></p>
<h5 id="Run-Interacitve"><a href="#Run-Interacitve" class="headerlink" title="Run Interacitve"></a>Run Interacitve</h5><p>该选项运行执行后，除了运行容器，还会跳到容器的汇总shell处，这里会实时打印容器日志，</p>
<p>效果和 <code>View Log</code>效果相同：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666116324737-328fd245-853d-416c-acf7-6adfd5f1e7e3.png" alt="img"></p>
<h4 id="View-Log"><a href="#View-Log" class="headerlink" title="View Log"></a>View Log</h4><p>直达容器后台日志，如果在运行的时候选择<code>Run Interacitve</code>那么也会跳转到该log页面。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665998996602-944ea384-cf80-4711-9989-b937c4bd02a6.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665999366319-2a41bc0f-4f89-4b63-9cd5-253b54bcd031.png" alt="img"></p>
<h4 id="Attach-Shell"><a href="#Attach-Shell" class="headerlink" title="Attach Shell"></a>Attach Shell</h4><p>右键选中之后可以直接建立一个容器内部的shell，省去<code>docker exec -i -t  ID /bin/bash</code></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665998911154-243825b7-d7be-47fa-9a30-214d7591f75f.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665999322527-061fab7c-02b4-471c-92bd-b64a716ee583.png" alt="img"></p>
<h4 id="Edit-Container"><a href="#Edit-Container" class="headerlink" title="Edit Container"></a>Edit Container</h4><p>在CONTAINERS中下拉一个容器的file可以对其进行查看和编辑：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665997210054-cc018f63-7e66-4201-a27c-2aa6c78d7b0a.png" alt="img"></p>
<p>可以看到对于容器来说 修改是即时的（支持热更新的）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665997987509-8642ebda-72c7-45a8-b2f4-9e1ef04ac2da.png" alt="img"></p>
<h4 id="Attach-Container（Advanced-Edit？）"><a href="#Attach-Container（Advanced-Edit？）" class="headerlink" title="Attach Container（Advanced Edit？）"></a>Attach Container（Advanced Edit？）</h4><p>我们也可以用Vscode建立类似SSH的连接，直接连接到整个容器：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665998467833-cf59f140-9f33-43c1-a2b2-c635c6662598.png" alt="img"></p>
<p>并且操作同步：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665998565856-6d6953de-1afd-4a98-b99f-a9076387a9b3.png" alt="img"></p>
<p>而且容器支持文件拖拽，相比单纯的COPY指令 拥有更好的体验（个人感觉</p>
<h4 id="Port-Forward"><a href="#Port-Forward" class="headerlink" title="Port Forward"></a>Port Forward</h4><p>通过SSH直接将远程端口转发到本地，免除防火墙困扰ww</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1665999460970-c81a131d-6712-4ab9-9b30-d0fd0084a6cb.png" alt="img"></p>
<p>一般来讲在您启动容器的时候 vscode会自动配置 当然为了更好的区分和避免冲突 也可以手动分配</p>
<p>配置如图：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666000511669-34c924ab-ac4a-42d5-92cb-8b658afe39f1.png" alt="img"></p>
<h4 id="Open-in-Borrow"><a href="#Open-in-Borrow" class="headerlink" title="Open in Borrow"></a>Open in Borrow</h4><p>如果您配置完成了端口转发(或者vscode自动为您完成配置）那么点击Open in Borrow将在您的默认浏览器中快速打开该端口对应的页面：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666117172873-9d4b7fb4-574d-426d-8dd3-b62b5c1b71e1.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666117247770-7b5c5b4c-a8f9-4c70-9bdc-61b21790fb28.png" alt="img"></p>
<h4 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h4><p>其他用法，就请佬们自行探索啦ww</p>
<h2 id="ExtensionRecommend"><a href="#ExtensionRecommend" class="headerlink" title="ExtensionRecommend"></a>ExtensionRecommend</h2><h3 id="Thunder-Client"><a href="#Thunder-Client" class="headerlink" title="Thunder Client"></a>Thunder Client</h3><p>Thunder Client is a lightweight Rest API Client Extension for Visual Studio Code, hand-crafted by Ranga Vadhineni with simple and clean design.</p>
<p>要注意的是 该插件基于远程运行（既本体在虚拟机&#x2F;服务器上），在测试的时候请确保url指向正确。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/21803058/1666002204613-bd552d8b-851a-4528-baf0-fbe018d7ad51.png" alt="img"></p>
<h1 id="win11虚拟机部署pikachu"><a href="#win11虚拟机部署pikachu" class="headerlink" title="win11虚拟机部署pikachu"></a>win11虚拟机部署pikachu</h1><p>Phpstudy，Phpstorm，pikachu、外加的话浏览器别太老。<br>Phpstudy：<a target="_blank" rel="noopener" href="https://www.xp.cn/">https://www.xp.cn/</a><br>Phpstorm：<a target="_blank" rel="noopener" href="https://www.jetbrains.com/zh-cn/phpstorm/">https://www.jetbrains.com/zh-cn/phpstorm/</a><br>pikachu：<a target="_blank" rel="noopener" href="https://github.com/zhuifengshaonianhanlu/pikachu">https://github.com/zhuifengshaonianhanlu/pikachu</a></p>
<p>这里我并没有一步一步截图，因为碰壁很多次，所以，我将针对我所遇到的问题以及解决方法展开阐述，仅供参考。<br>1、win11本机搭建步骤</p>
<p>1、安装Phpstudy以及Phpstorm软件，并启动apacha以及mysql<br><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240530151311289.png" alt="image-20240530151311289"><br>其实，这里一个版本就行。</p>
<p>2、这下去pikachu的那个文件进行把mysql的root密码写进去，这里如果你的密码不是初始密码root的话，那么这里则需要修改两个Php中的密码：</p>
<p>3、修改密码</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240530151238531.png" alt="image-20240530151238531"></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240530151250834.png" alt="image-20240530151250834"></p>
<p>4、ctrl+c以及ctrl+v将修改之后的pikachu文件放在phpstudy安装之后文件夹的www文件目录中；</p>
<p>5、修改完之后我就又碰见了问题四，也就是执行127.0.0.1&#x2F;pikachu之后报错<br>说有个文件的14行有错误。详见问题四：</p>
<p>6、直接进入浏览器输入127.0.0.1&#x2F;pikachu<br><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240530151224015.png" alt="image-20240530151224015"><br>7、当然，这里是win主机搭建的靶机，而且即使到这一步依旧没有结束<br>因为还要进行安装初始化：<br>所以，在URL输入框中，我们输入127.0.0.1&#x2F;pikachu&#x2F;install.php<br>然后回车就可以看到安装以及初始化了：<br><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240530151158114.png" alt="image-20240530151158114"><br>我所碰见的问题以及解决方式：</p>
<p>1、文件打不开，也就是pikachu的那个ins配置文件直接打不开，这个我觉得和电脑以及环境有关，我使用的是win11，之前win10还没碰见过这种情况：<br>解决方式：<br>这里我采用的是直接关机重启，这里注意进程，最好别有什么系统程序执行</p>
<p>2、至于上面pikachu配置文件更改，也就是给那个里面写入root的密码，双击那个文件直接卡住的情况：<br>解决方式：<br>这里直接打开Phpstorm软件进行选中文件打开，这里自己找到文件的路径进行打开。<br>这里路径不好找？可以去搜everthing官网进行下载（搜索文件很快）。<br><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240530150821979.png" alt="image-20240530150821979"></p>
<p>3、主机与虚拟机win2012进行连接实现文件传输达不到，使用moba以及winSCP都无法连接到，那么文件该如何传输到虚拟机中？<br><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240530150808530.png" alt="image-20240530150808530"><br>解决方式：<br>这里用到了VMware tools，首先，我们将win2012先关闭客户机：<br>然后点击编辑虚拟机设置——&gt;选项——&gt;共享文件夹<br><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240530150759674.png" alt="image-20240530150759674">这里创建一个共享文件夹实现本机与win2012的文件互通。</p>
<p>4、这里浏览器输出127.0.0.1&#x2F;pikachu的图像，这里报错了，很明显可以看到是mysql的密码导致的错误，可这里并没有出错，两个文件都配置的是root用户名以及root密码：<br>解决方式：<br>这里在小皮也就是Phpstudy中添加创建一个数据库：<br><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240530150749344.png" alt="image-20240530150749344"><br>点击上面的创建数据库，如果出现了root密码未修改，那么一修改，然后继续创建数据库，同样设置6位以上的密码，没什么讲究的。这下即可成功进入靶场。</p>
<p>5、我进行安装以及初始化之后，浏览器中改变URL之后回车，链接后面便加上一个#号，同时界面是一个固定的界面，不能进行跳转界面：<br>解决方法：<br>嗯······我当时使用的是win2012的浏览器，这里换个浏览器重新在虚拟机访问127.0.0.1&#x2F;pikachu便好······没什么技术要求，以及在本机访问中，也就不会出现这样的情况了。</p>
<p>好了，pikachu靶场搭建就分享到这，希望能帮到各位。<br>————————————————</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_63172698/article/details/131498908">https://blog.csdn.net/weixin_63172698/article/details/131498908</a></p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p><a target="_blank" rel="noopener" href="https://www.runoob.com/mysql/mysql-tutorial.html">MySQL 教程 | 菜鸟教程 (runoob.com)</a></p>
<p>可以使用phpstudy自带的sql_front或navicat通过pikachu数据库进行一系列实践</p>
<p>或者我之前的个人笔记也有的</p>
<h1 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h1><h2 id="Docker网络理论"><a href="#Docker网络理论" class="headerlink" title="Docker网络理论"></a>Docker网络理论</h2><p>容器网络实际上是<strong>由Docker为应用程序所创造的虚拟环境的一部分，它能够使应用从宿主机操作系统的网络系统中独立出来。</strong>形成容器自有的网络设备、IP 协议栈、端口套接字、IP 路由表、防火墙等等与网络相关的模块。</p>
<h3 id="CNM"><a href="#CNM" class="headerlink" title="CNM"></a><strong>CNM</strong></h3><p>Docker 网络架构采用的设计规范是 CNM（Container Network Model）：<strong>CNM 中规定了 Docker 网络的基础组成要素：Sandbox、Endpoint、Network。如图所示，</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240604004145261.png" alt="image-20240604004145261"></p>
<ul>
<li>Sandbox，提供了<strong>容器的虚拟网络栈</strong>，也即端口套接字、IP 路由表、防火墙、DNS 配置等内容。<strong>主要用于隔离容器网络与宿主机网络</strong>，形成了完全独立的容器网络环境。</li>
<li>Network，Docker 内部的虚拟子网，网络内的参与者相互可见并能够进行通讯。<strong>Docker 的虚拟网路和宿主机网络是存在隔离关系的，其目的主要是形成容器间的安全通讯环境。</strong></li>
<li>Endpoint，<strong>就是虚拟网络的接口</strong>，就像普通网络接口一样，Endpoint 的主要职责是<strong>负责创建连接。在 CNM 中，终端负责将沙盒连接到网络。</strong>个人理解：Endpoint 与常见的网络适配器类似，也就意味着 Endpoint 只能接入某一个网络。<strong>因此，如果容器需要接入到多个网络，就需要多个 Endpoint。</strong></li>
</ul>
<h3 id="Libnetwork"><a href="#Libnetwork" class="headerlink" title="Libnetwork"></a><strong>Libnetwork</strong></h3><p>Libnetwork 是 CNM 的标准实现。Libnetwork 是开源库，采用 Go 语言编写（跨平台的），也是 Docker 所使用的库，Docker 网络架构的核心代码都在这个库中。</p>
<h2 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a><strong>驱动</strong></h2><p>“驱动”在计算机和电子设备领域中，通常指的是设备驱动程序（Device Driver），是一种特殊的软件程序，负责控制硬件设备的操作并与操作系统进行通信。<strong>驱动程序充当硬件与操作系统或应用程序之间的中介，</strong>使得软件可以通过标准化的接口与硬件设备进行交互，而无需了解硬件设备的具体实现细节。</p>
<h3 id="驱动的主要功能"><a href="#驱动的主要功能" class="headerlink" title="驱动的主要功能"></a>驱动的主要功能</h3><ol>
<li><p><strong>硬件初始化</strong>：</p>
<ul>
<li>驱动程序在设备启动时初始化硬件，使其处于可以正常工作的状态。</li>
</ul>
</li>
<li><p><strong>中断处理</strong>：</p>
<ul>
<li>处理来自硬件设备的中断信号，并将相应的信息传递给操作系统或应用程序。</li>
</ul>
</li>
<li><p><strong>数据传输</strong>：</p>
<ul>
<li>管理硬件设备的数据传输，包括读取和写入操作。比如，从硬盘读取数据或向打印机发送打印作业。</li>
</ul>
</li>
<li><p><strong>提供接口</strong>：</p>
<ul>
<li>提供标准化的接口，使得操作系统和应用程序能够通过统一的方法访问硬件设备的功能。</li>
</ul>
</li>
</ol>
<h3 id="驱动程序的类型"><a href="#驱动程序的类型" class="headerlink" title="驱动程序的类型"></a>驱动程序的类型</h3><p>驱动程序可以根据不同的设备类型进行分类，以下是一些常见的驱动程序类型：</p>
<ol>
<li><p><strong>设备驱动程序</strong>：</p>
<ul>
<li>控制特定硬件设备的驱动程序，如键盘、鼠标、打印机、硬盘等。</li>
</ul>
</li>
<li><p><strong>内核驱动程序</strong>：</p>
<ul>
<li>运行在操作系统内核中的驱动程序，<strong>提供低级别的硬件控制和管理。</strong></li>
</ul>
</li>
<li><p><strong>文件系统驱动程序</strong>：</p>
<ul>
<li>负责管理文件系统的驱动程序，使得操作系统能够读取和写入存储设备上的文件。</li>
</ul>
</li>
<li><p><strong>网络驱动程序</strong>：</p>
<ul>
<li>管理网络接口卡（NIC）或其他网络设备的驱动程序，负责网络通信和数据传输。</li>
</ul>
</li>
</ol>
<h3 id="驱动程序的安装与更新"><a href="#驱动程序的安装与更新" class="headerlink" title="驱动程序的安装与更新"></a>驱动程序的安装与更新</h3><p>驱动程序通常由硬件设备制造商提供，可以通过以下几种方式安装和更新：</p>
<ol>
<li><p><strong>操作系统自带</strong>：</p>
<ul>
<li>操作系统通常自带一些常用硬件设备的驱动程序，安装操作系统时会自动安装这些驱动程序。</li>
</ul>
</li>
<li><p><strong>设备制造商提供</strong>：</p>
<ul>
<li>硬件设备通常附带驱动程序安装光盘或下载链接，用户可以通过制造商的网站下载最新的驱动程序。</li>
</ul>
</li>
<li><p><strong>自动更新</strong>：</p>
<ul>
<li>现代操作系统（如Windows Update）提供自动更新功能，可以自动检测并安装最新的驱动程序。</li>
</ul>
</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以下是一些具体的驱动程序示例：</p>
<ol>
<li><p><strong>显卡驱动程序（Graphics Driver）</strong>：</p>
<ul>
<li>控制显卡硬件，提供图形显示和渲染功能。例如，NVIDIA或AMD提供的显卡驱动程序。</li>
</ul>
</li>
<li><p><strong>声卡驱动程序（Audio Driver）</strong>：</p>
<ul>
<li>控制声卡硬件，提供音频输入和输出功能。例如，Realtek声卡驱动程序。</li>
</ul>
</li>
<li><p><strong>网络适配器驱动程序（Network Adapter Driver）</strong>：</p>
<ul>
<li>控制网络适配器硬件，提供网络连接和数据传输功能。例如，Intel或Broadcom网络适配器驱动程序。</li>
</ul>
</li>
</ol>
<h3 id="驱动程序的工作原理"><a href="#驱动程序的工作原理" class="headerlink" title="驱动程序的工作原理"></a>驱动程序的工作原理</h3><p>驱动程序通常包括以下几个主要部分：</p>
<ol>
<li><p><strong>硬件接口</strong>：</p>
<ul>
<li>直接与硬件设备交互，发送命令和接收数据。</li>
</ul>
</li>
<li><p><strong>操作系统接口</strong>：</p>
<ul>
<li>提供给操作系统的标准化接口，使得操作系统能够通过系统调用与硬件设备交互。</li>
</ul>
</li>
<li><p><strong>中断处理</strong>：</p>
<ul>
<li>处理硬件设备发出的中断信号，并通知操作系统进行相应的处理。</li>
</ul>
</li>
<li><p><strong>内存管理</strong>：</p>
<ul>
<li>管理硬件设备使用的内存空间，包括数据缓冲区和控制寄存器。</li>
</ul>
</li>
</ol>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><strong>驱动程序在计算机系统中扮演着关键角色，通过提供标准化的接口，使得操作系统和应用程序能够高效、安全地与各种硬件设备进行交互。</strong>了解驱动程序的基本原理和类型，有助于更好地管理和维护计算机系统，确保硬件设备的正常运行和最佳性能。</p>
<h3 id="驱动-for-Docker"><a href="#驱动-for-Docker" class="headerlink" title="驱动　 for　Ｄｏｃｋｅｒ"></a>驱动　 for　Ｄｏｃｋｅｒ</h3><p>驱动就负责实现数据层。比如<strong>网络的连通性和隔离性是由驱动来处理的</strong>。驱动通过实现特定网络类型的方式扩展了 Docker 网络栈，例如桥接网络和覆盖网络。</p>
<p>Docker 内置了若干驱动，通常被称作原生驱动或者本地驱动。比如 <strong>Bridge Driver</strong>、<strong>Host Driver</strong>、<strong>Overlay Driver</strong>、<strong>MacLan Driver</strong>、<strong>None Driver</strong> 等等。第三方也可以编写 Docker 网络驱动，这些驱动被叫做远程驱动，例如 Calico、Contiv、Kuryr 以及 Weave 等。每个驱动负责创建其上所有网络资源的创建和管理。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240604004633142.png" alt="image-20240604004633142"></p>
<p>在 Docker 安装时，会自动安装一块 Docker 网卡称为 docker0，用于 Docker 各容器及宿主机的网络通信。</p>
<h1 id="桥接网络基本概念"><a href="#桥接网络基本概念" class="headerlink" title="桥接网络基本概念"></a>桥接网络基本概念</h1><p>桥接网络（Bridging Network）是一种网络配置方法，通过使用网络桥接（network bridging）技术将两个或多个网络段连接在一起，使它们能够作为一个统一的网络进行通信。这种技术常用于局域网（LAN）环境中，以扩展网络的覆盖范围或连接不同的网络类型。</p>
<h4 id="网络桥接的基本概念"><a href="#网络桥接的基本概念" class="headerlink" title="网络桥接的基本概念"></a>网络桥接的基本概念</h4><p>网络桥接的基本概念包括以下几个方面：</p>
<ol>
<li><p><strong>网络桥（Bridge）</strong>：</p>
<ul>
<li>网络桥是一种网络设备，可以是专用硬件设备或软件实现的虚拟桥。<strong>其主要功能是连接两个或多个网络段，使它们能够互相通信</strong>。</li>
<li>桥接设备会在<strong>不同的网络段之间转发数据包</strong>，使用媒体访问控制（MAC）地址来决定数据包的转发路径。</li>
</ul>
</li>
<li><p><strong>透明桥（Transparent Bridge）</strong>：</p>
<ul>
<li>透明桥是最常见的一种网络桥，它在连接的网络段之间转发数据包，而不会对网络协议进行任何修改。</li>
<li>透明桥通过学习网络设备的MAC地址来建立内部地址表，从而智能地转发数据包，仅将数据包发送到目标网络段。</li>
</ul>
</li>
</ol>
<h4 id="桥接网络的用途"><a href="#桥接网络的用途" class="headerlink" title="桥接网络的用途"></a>桥接网络的用途</h4><p>桥接网络可以用于多种用途，包括但不限于：</p>
<ol>
<li><p><strong>扩展网络覆盖范围</strong>：</p>
<ul>
<li>通过将两个或多个物理分开的网络段桥接在一起，可以扩展网络的覆盖范围，使更多的设备能够互相通信。</li>
</ul>
</li>
<li><p><strong>连接不同类型的网络</strong>：</p>
<ul>
<li>桥接可以<strong>连接不同类型的网络，例如以太网和无线网络</strong>，使得有线设备和无线设备能够在同一个网络中通信。</li>
</ul>
</li>
<li><p><strong>增强网络性能</strong>：</p>
<ul>
<li>通过合理的桥接配置，可以减少网络中的广播域，从而减少网络拥塞，提高整体网络性能。</li>
</ul>
</li>
</ol>
<h4 id="桥接网络的类型"><a href="#桥接网络的类型" class="headerlink" title="桥接网络的类型"></a>桥接网络的类型</h4><p>桥接网络可以有多种配置方式，以下是几种常见的类型：</p>
<ol>
<li><p><strong>以太网桥接（Ethernet Bridging）</strong>：</p>
<ul>
<li>通过以太网桥将多个以太网段连接在一起，使它们成为一个逻辑上的单一网络。</li>
</ul>
</li>
<li><p><strong>无线桥接（Wireless Bridging）</strong>：</p>
<ul>
<li>使用无线设备（如无线接入点）将两个或多个无线网络段连接在一起，常用于扩展无线网络的覆盖范围。</li>
</ul>
</li>
<li><p><strong>混合桥接（Hybrid Bridging）</strong>：</p>
<ul>
<li>结合有线和无线桥接，将有线网络段和无线网络段连接在一起。</li>
</ul>
</li>
</ol>
<h4 id="桥接网络的实现"><a href="#桥接网络的实现" class="headerlink" title="桥接网络的实现"></a>桥接网络的实现</h4><p>桥接网络可以通过硬件设备或软件配置来实现：</p>
<ol>
<li><p><strong>硬件实现</strong>：</p>
<ul>
<li>使用专用的网络桥设备或交换机（具有桥接功能）来连接不同的网络段。</li>
</ul>
</li>
<li><p><strong>软件实现</strong>：</p>
<ul>
<li>在操作系统中使用虚拟桥接软件（如Linux的<code>brctl</code>工具或Windows的网络桥接功能）来实现桥接网络。</li>
</ul>
</li>
</ol>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>假设有两个局域网（LAN），分别位于两个不同的楼层，每个楼层都有一个交换机连接所有的计算机。通过在两个交换机之间连接一个网络桥，可以使两个楼层的计算机互相通信，如同它们在同一个网络中一样。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>桥接网络是一种有效的网络配置方法，可以扩展网络的覆盖范围、连接不同类型的网络和增强网络性能。通过使用网络桥设备或软件实现桥接网络，可以将多个物理上分离的网络段连接在一起，形成一个逻辑上的统一网络。</p>
<p><strong>Docker 的 bridge 网络采用内置的 bridge 驱动，而 bridge 的底层采用的是</strong> <strong>Linux</strong> <strong>内核中 Linux bridge 技术</strong>（这意味着 bridge 是高性能并且是非常稳定的）。</p>
<h2 id="桥接网络-for-Docker"><a href="#桥接网络-for-Docker" class="headerlink" title="桥接网络 for Docker"></a>桥接网络 for Docker</h2><p>Docker 的 bridge 网络采用内置的 bridge 驱动，而 bridge 的底层采用的是 Linux 内核中 Linux bridge 技术（这意味着 bridge 是高性能并且是非常稳定的）。</p>
<p><strong>由于容器运行在自己单独的 network namespace 中，所以有单独的协议栈。</strong>容器中配置网关为 172.17.0.1，发出去的数据包<strong>先到达 br0</strong>，然后交给主机的协议栈，由于<strong>目的 IP 是外网 IP</strong>，且主机会开启 IP forward 功能，于是<strong>数据包通过主机的 eth0 发出去</strong>。由于 172.17.0.1 是内网 IP ，所以一般发出去之前会做 NAT 转换。由于要进过主机的协议栈并且要做 NAT 转换，所以性能上可能会差点，<strong>但是优点就是容器处于内网中，安全性相对要高点。</strong></p>
<p>默认情况下，创建的容器在没有使用 –network 参数指定要加入的 docker 网络时，默认都是加入 Docker 默认的单机桥接网络，也就是下面的 name 为 bridge 的网络。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">0dda6f303b8b        bridge              bridge              local</span><br></pre></td></tr></table></figure>

<h4 id="创建新的单机桥接网络"><a href="#创建新的单机桥接网络" class="headerlink" title="创建新的单机桥接网络"></a><strong>创建新的单机桥接网络</strong></h4><p>使用 <code>docker network create</code> 命令，我们可创建一个名为 “localnet” 的单机桥接网络，并且在内核中还会多出一个新的 Linux 网桥。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create -d bridge localnet</span><br><span class="line"></span><br><span class="line">$ docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">			......</span><br><span class="line">f55943e20201        localnet            bridge              local</span><br></pre></td></tr></table></figure>

<p>在创建完之后，我们可以通过 brctl 工具来查看系统中的 Linux 网桥。可以看到，<strong>输出的内容中包含了两个网桥，docker0 是默认的 Docker bridge 网络所使用的网桥，br-f55943e20201 是 Docker localnet 网络所使用的网桥。</strong>这两个网桥目前都没有任何设备接入（看 interface 列）。这两个网桥所处的网段是不同的，</p>
<p><img src="https://cdn.jsdelivr.net/gh/xzb666-hub/myblogimage@img/image/image-20240604084900918.png" alt="image-20240604084900918"></p>
<h4 id="同个网络中的容器间通信"><a href="#同个网络中的容器间通信" class="headerlink" title="同个网络中的容器间通信"></a><strong>同个网络中的容器间通信</strong></h4><p>使用下面这条命令即可运行一个新的容器，并且让这个新容器加入到 localnet 这个网络中的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run -d --name demo1 --network localnet alpine sleep 3600</span><br></pre></td></tr></table></figure>

<p>我们查看网桥的情况，<strong>demo1</strong> 的网络接口连接到了网桥 br-f55943e20201 上，如图所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ brctl show</span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">br-f55943e20201 8000.02421d9aa3e1       no              vethf6a3fba</span><br><span class="line">docker0         8000.0242be6b61dc       no</span><br></pre></td></tr></table></figure>

<p>如果在<strong>相同的网络中继续接入新的容器，那么新接入的容器是可以通过 demo1 这个名称来 ping 通的</strong>。如下所示，我们创建了一个新的容器（demo2），并且在这个容器中直接 ping demo1 发现可以的 ping 通的。<strong>这是因为，demo2 运行了一个本地 DNS 解析器，该解析器会将该请求转发到 Docker 内部 DNS 服务器中。</strong>DNS 服务器中记录了容器启动时通过 –name 或者 –net-alias 参数指定的名称和容器之间的和映射关系。</p>
<h5 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h5><p>在你提供的例子中，<code>demo2</code> 容器中可以 <code>ping</code> 通 <code>demo1</code> 容器。这意味着 <code>demo2</code> 容器能够通过网络与 <code>demo1</code> 容器进行通信，<code>demo2</code> 可以成功发送 ICMP 回显请求数据包到 <code>demo1</code>，并接收到 <code>demo1</code> 的应答数据包。这种情况表明：</p>
<ol>
<li>两个容器处于同一个网络（如同一个 Docker 网络中）。</li>
<li>容器之间的 DNS 解析功能正常，<code>demo2</code> 能够通过容器名称 <code>demo1</code> 找到其对应的 IP 地址。</li>
<li>容器之间的网络连通性是正常的，没有防火墙等网络设备阻碍两者通信。</li>
</ol>
<p>下面是你提供的示例中的具体过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码# ping demo1</span><br><span class="line">PING demo1 (172.18.0.2): 56 data bytes</span><br><span class="line">64 bytes from 172.18.0.2: seq=0 ttl=64 time=0.230 ms</span><br><span class="line">64 bytes from 172.18.0.2: seq=1 ttl=64 time=0.161 ms</span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li>你在 <code>demo2</code> 容器中执行 <code>ping demo1</code> 命令。</li>
<li><code>demo2</code> 容器通过内部 DNS 解析 <code>demo1</code> 的名称并找到其 IP 地址 <code>172.18.0.2</code>。</li>
<li><code>demo2</code> 容器向 <code>172.18.0.2</code> 发送 ICMP 回显请求。</li>
<li><code>demo1</code> 容器接收到请求并返回 ICMP 回显应答。</li>
<li><code>demo2</code> 容器接收到应答，表明 <code>demo1</code> 容器是可达的，网络连通性正常。</li>
</ul>
<p>这就是为什么你可以在 <code>demo2</code> 中 <code>ping</code> 通 <code>demo1</code>。</p>
<hr>
<p>除此之外，我们可以看到 demo1 的 IP 地址是 172.18.0.2，这个与网桥 br-f55943e20201 是处于同一个网段内的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/ # ls</span><br><span class="line">bin    dev    etc    home   lib    media  mnt    opt    proc   root   run    sbin   srv    sys    tmp    usr    var</span><br><span class="line">/ # ping demo1</span><br><span class="line">PING demo1 (172.18.0.2): 56 data bytes</span><br><span class="line">64 bytes from 172.18.0.2: seq=0 ttl=64 time=0.230 ms</span><br><span class="line">64 bytes from 172.18.0.2: seq=1 ttl=64 time=0.161 ms</span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h2 id="ping的解释"><a href="#ping的解释" class="headerlink" title="ping的解释"></a>ping的解释</h2><p>当然，以下是对 <code>ping</code> 命令作用以及 “ping 通” 解释的详细说明：</p>
<h3 id="ping-命令的作用"><a href="#ping-命令的作用" class="headerlink" title="ping 命令的作用"></a><code>ping</code> 命令的作用</h3><p><code>ping</code>（Packet Internet Groper）是一个用于测试网络连接的命令行工具。其主要作用如下：</p>
<ol>
<li><p><strong>检测网络连通性</strong>：<code>ping</code> 可以用来检查一个设备是否能够与另一个设备进行网络通信。通过向目标地址发送ICMP（Internet Control Message Protocol）回显请求数据包，并等待回显应答来判断网络是否连通。</p>
</li>
<li><p><strong>测量网络延迟</strong>：<code>ping</code> 会显示从发送请求到接收应答所需的时间。这有助于测量网络的响应时间或延迟。</p>
</li>
<li><p><strong>诊断网络问题</strong>：通过观察 <code>ping</code> 的结果，可以帮助诊断网络中可能存在的问题。例如，如果 <code>ping</code> 不通，可能意味着网络不通、目标设备关闭或防火墙阻止了 ICMP 数据包。</p>
</li>
<li><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4></li>
</ol>
<h3 id="“ping-通”-的解释"><a href="#“ping-通”-的解释" class="headerlink" title="“ping 通” 的解释"></a>“ping 通” 的解释</h3><p>“ping 通” 指的是通过 <code>ping</code> 命令成功发送 ICMP 回显请求并收到目标设备的回显应答。这表明两个设备之间的网络连接正常，能够相互通信。具体来说：</p>
<ul>
<li>当你运行 <code>ping</code> 命令时，系统会向目标 IP 地址或域名发送 ICMP 回显请求数据包。</li>
<li>如果目标设备接收到这个数据包并回送一个回显应答数据包，那么 <code>ping</code> 命令就会在控制台上显示应答的信息，包括应答时间、数据包大小和 TTL（生存时间）。</li>
<li>多次 <code>ping</code> 通表示网络连接稳定，并且没有丢包或超时的情况。</li>
</ul>
<p>在你提供的示例中，<code>demo2</code> 容器通过 <code>ping demo1</code> 命令发送 ICMP 回显请求，并成功收到 <code>demo1</code> 容器的回显应答。这说明 <code>demo2</code> 和 <code>demo1</code> 之间的网络连接是正常的，可以相互通信。</p>
<h2 id="暴露端口"><a href="#暴露端口" class="headerlink" title="暴露端口"></a><strong>暴露端口</strong></h2><p>同一个网络中的容器之间虽然可以互相 ping 通，但是并不意味着可以任意访问容器中的任何服务。Docker 为容器增加了一套安全机制，<strong>只有容器自身允许的端口，才能被其他容器所访问。如下所示，我们可以通过 <code>docker container ls</code> 命令可以看到容器暴露给其他容器访问的端口是 80，那么我们只能容器的 80 端口进行访问，而不能对没有开放的 22 端口进行访问。</strong></p>
<p>我们可以在<strong>镜像创建的时候定义要暴露的端口，也可以在容器创建时定义要暴露的端口</strong>，使用 –expose。如下所示，就额外暴露了 20、22 这两个端口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run -d --name web --expose 22 --expose 20 nginx</span><br><span class="line"></span><br><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">4749dac32711        nginx               &quot;/docker-entrypoint.…&quot;   12 seconds ago      Up 10 seconds       20/tcp, 22/tcp, 80/tcp   web</span><br></pre></td></tr></table></figure>

<h4 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a><strong>端口映射</strong></h4><p>上面提到的桥接网络中的容器只能与位于相同网络中的容器进行通信，假如一个容器想对外提供服务的话，需要进行端口映射。端口映射将容器的某个端口映射到 Docker 主机端口上。那么任何发送到该端口的流量，都会被转发到容器中。如图所示，容器内部开放端口为 80，该端口被映射到了 Docker 主机的 10.0.0.15 的 5000 端口上。最终访问 10.0.0.15:5000 的所有流量都会被转发到容器的 80 端口。</p>
<h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a><strong>相关命令</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 列出运行在本地 docker 主机上的全部网络</span><br><span class="line">docker network ls</span><br><span class="line"></span><br><span class="line"># 提供 Docker 网络的详细配置信息</span><br><span class="line">docker network inspect &lt;NETWORK_NAME&gt;</span><br><span class="line"></span><br><span class="line"># 创建新的单机桥接网络，名为 localnet，其中 -d 不指定的话，默认是 bridge 驱动。并且主机内核中也会创建一个新的网桥。</span><br><span class="line">docker network create -d bridge localnet</span><br><span class="line"></span><br><span class="line"># 删除 Docker 主机上指定的网络</span><br><span class="line">docker network rm</span><br><span class="line"></span><br><span class="line"># 删除主机上全部未使用的网络</span><br><span class="line">docker network prune</span><br><span class="line"></span><br><span class="line"># 运行一个新的容器，并且让这个容器加入 Docker 的 localnet 这个网络中</span><br><span class="line">docker container run -d --name demo1 --network localnet alpine sleep 3600</span><br><span class="line"></span><br><span class="line"># 运行一个新的容器，并且让这个容器暴露 22、20 两个端口</span><br><span class="line">docker container run -d --name web --expose 22 --expose 20 nginx</span><br><span class="line"></span><br><span class="line"># 运行一个新的容器，并且将这个容器的 80 端口映射到主机的 5000 端口</span><br><span class="line">docker container run -d --name web --network localnet -p 5000:80 nginx</span><br><span class="line"></span><br><span class="line"># 查看系统中的网桥</span><br><span class="line">brctl show</span><br></pre></td></tr></table></figure>


      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/source/categories/Penetration-Testing/">Penetration Testing</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/source/tags/tools/">tools</a>
    </span>
    

    </div>

    
  </div>
</article>

  









    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2024 Satoru
    
  </p>
</footer>
    
    
  </div>
</div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>